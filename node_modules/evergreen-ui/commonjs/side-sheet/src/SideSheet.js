'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _uiBox = require('ui-box');

var _layers = require('../../layers');

var _overlay = require('../../overlay');

var _SheetClose = require('./SheetClose');

var _SheetClose2 = _interopRequireDefault(_SheetClose);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var paneProps = {
  height: '100vh',
  position: 'absolute',
  right: 0
};

var animationEasing = {
  deceleration: 'cubic-bezier(0.0, 0.0, 0.2, 1)',
  acceleration: 'cubic-bezier(0.4, 0.0, 1, 1)'
};

var ANIMATION_DURATION = 240;

var slideInAnimation = _uiBox.css.keyframes('slideInAnimation', {
  from: {
    transform: 'translateX(100%)'
  },
  to: {
    transform: 'translateX(0)'
  }
});

var slideOutAnimation = _uiBox.css.keyframes('slideOutAnimation', {
  from: {
    transform: 'translateX(0)'
  },
  to: {
    transform: 'translateX(100%)'
  }
});

var animationStyles = {
  transform: 'translateX(100%)',
  '&[data-state="entering"], &[data-state="entered"]': {
    animation: slideInAnimation + ' ' + ANIMATION_DURATION + 'ms ' + animationEasing.deceleration + ' both'
  },
  '&[data-state="exiting"]': {
    animation: slideOutAnimation + ' ' + ANIMATION_DURATION + 'ms ' + animationEasing.acceleration + ' both'
  }
};

var SideSheet = function (_React$Component) {
  _inherits(SideSheet, _React$Component);

  function SideSheet() {
    _classCallCheck(this, SideSheet);

    return _possibleConstructorReturn(this, (SideSheet.__proto__ || Object.getPrototypeOf(SideSheet)).apply(this, arguments));
  }

  _createClass(SideSheet, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          width = _props.width,
          isShown = _props.isShown,
          children = _props.children,
          containerProps = _props.containerProps,
          onOpenComplete = _props.onOpenComplete,
          onCloseComplete = _props.onCloseComplete;


      return _react2.default.createElement(
        _overlay.Overlay,
        {
          isShown: isShown,
          onExited: onCloseComplete,
          onEntered: onOpenComplete
        },
        function (_ref) {
          var state = _ref.state,
              close = _ref.close;
          return _react2.default.createElement(
            _layers.Pane,
            _extends({
              width: width
            }, paneProps, {
              css: animationStyles,
              'data-state': state
            }),
            _react2.default.createElement(_SheetClose2.default, { 'data-state': state, isClosing: false, onClick: close }),
            _react2.default.createElement(
              _layers.Pane,
              _extends({
                elevation: 4,
                backgroundColor: 'white',
                overflowY: 'auto',
                'data-state': state,
                width: width
              }, paneProps, containerProps),
              typeof children === 'function' ? children({ close: close }) : children
            )
          );
        }
      );
    }
  }]);

  return SideSheet;
}(_react2.default.Component);

SideSheet.propTypes = {
  /**
   * Children can be a string, node or a function accepting `({ close })`.
   */
  children: _propTypes2.default.oneOfType([_propTypes2.default.node, _propTypes2.default.func]).isRequired,

  /**
   * When true, the Side Sheet is shown.
   */
  isShown: _propTypes2.default.bool,

  /**
   * Function that will be called when the exit transition is complete.
   */
  onCloseComplete: _propTypes2.default.func,

  /**
   * Function that will be called when the enter transition is complete.
   */
  onOpenComplete: _propTypes2.default.func,

  /**
   * Width of the SideSheet.
   */
  width: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]).isRequired,

  /**
   * Properties to pass through the SideSheet container Pane.
   */
  containerProps: _propTypes2.default.object
};
SideSheet.defaultProps = {
  width: 620,
  onCloseComplete: function onCloseComplete() {},
  onOpenComplete: function onOpenComplete() {}
};
exports.default = SideSheet;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zaWRlLXNoZWV0L3NyYy9TaWRlU2hlZXQuanMiXSwibmFtZXMiOlsicGFuZVByb3BzIiwiaGVpZ2h0IiwicG9zaXRpb24iLCJyaWdodCIsImFuaW1hdGlvbkVhc2luZyIsImRlY2VsZXJhdGlvbiIsImFjY2VsZXJhdGlvbiIsIkFOSU1BVElPTl9EVVJBVElPTiIsInNsaWRlSW5BbmltYXRpb24iLCJrZXlmcmFtZXMiLCJmcm9tIiwidHJhbnNmb3JtIiwidG8iLCJzbGlkZU91dEFuaW1hdGlvbiIsImFuaW1hdGlvblN0eWxlcyIsImFuaW1hdGlvbiIsIlNpZGVTaGVldCIsInByb3BzIiwid2lkdGgiLCJpc1Nob3duIiwiY2hpbGRyZW4iLCJjb250YWluZXJQcm9wcyIsIm9uT3BlbkNvbXBsZXRlIiwib25DbG9zZUNvbXBsZXRlIiwic3RhdGUiLCJjbG9zZSIsIkNvbXBvbmVudCIsInByb3BUeXBlcyIsIm9uZU9mVHlwZSIsIm5vZGUiLCJmdW5jIiwiaXNSZXF1aXJlZCIsImJvb2wiLCJzdHJpbmciLCJudW1iZXIiLCJvYmplY3QiLCJkZWZhdWx0UHJvcHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBLElBQU1BLFlBQVk7QUFDaEJDLFVBQVEsT0FEUTtBQUVoQkMsWUFBVSxVQUZNO0FBR2hCQyxTQUFPO0FBSFMsQ0FBbEI7O0FBTUEsSUFBTUMsa0JBQWtCO0FBQ3RCQyxnREFEc0I7QUFFdEJDO0FBRnNCLENBQXhCOztBQUtBLElBQU1DLHFCQUFxQixHQUEzQjs7QUFFQSxJQUFNQyxtQkFBbUIsV0FBSUMsU0FBSixDQUFjLGtCQUFkLEVBQWtDO0FBQ3pEQyxRQUFNO0FBQ0pDO0FBREksR0FEbUQ7QUFJekRDLE1BQUk7QUFDRkQ7QUFERTtBQUpxRCxDQUFsQyxDQUF6Qjs7QUFTQSxJQUFNRSxvQkFBb0IsV0FBSUosU0FBSixDQUFjLG1CQUFkLEVBQW1DO0FBQzNEQyxRQUFNO0FBQ0pDO0FBREksR0FEcUQ7QUFJM0RDLE1BQUk7QUFDRkQ7QUFERTtBQUp1RCxDQUFuQyxDQUExQjs7QUFTQSxJQUFNRyxrQkFBa0I7QUFDdEJILCtCQURzQjtBQUV0Qix1REFBcUQ7QUFDbkRJLGVBQWNQLGdCQUFkLFNBQWtDRCxrQkFBbEMsV0FDRUgsZ0JBQWdCQyxZQURsQjtBQURtRCxHQUYvQjtBQU90Qiw2QkFBMkI7QUFDekJVLGVBQWNGLGlCQUFkLFNBQW1DTixrQkFBbkMsV0FDRUgsZ0JBQWdCRSxZQURsQjtBQUR5QjtBQVBMLENBQXhCOztJQWNNVSxTOzs7Ozs7Ozs7Ozs2QkF1Q0s7QUFBQSxtQkFRSCxLQUFLQyxLQVJGO0FBQUEsVUFFTEMsS0FGSyxVQUVMQSxLQUZLO0FBQUEsVUFHTEMsT0FISyxVQUdMQSxPQUhLO0FBQUEsVUFJTEMsUUFKSyxVQUlMQSxRQUpLO0FBQUEsVUFLTEMsY0FMSyxVQUtMQSxjQUxLO0FBQUEsVUFNTEMsY0FOSyxVQU1MQSxjQU5LO0FBQUEsVUFPTEMsZUFQSyxVQU9MQSxlQVBLOzs7QUFVUCxhQUNFO0FBQUE7QUFBQTtBQUNFLG1CQUFTSixPQURYO0FBRUUsb0JBQVVJLGVBRlo7QUFHRSxxQkFBV0Q7QUFIYjtBQUtHO0FBQUEsY0FBR0UsS0FBSCxRQUFHQSxLQUFIO0FBQUEsY0FBVUMsS0FBVixRQUFVQSxLQUFWO0FBQUEsaUJBQ0M7QUFBQTtBQUFBO0FBQ0UscUJBQU9QO0FBRFQsZUFFTWxCLFNBRk47QUFHRSxtQkFBS2MsZUFIUDtBQUlFLDRCQUFZVTtBQUpkO0FBTUUsa0VBQVksY0FBWUEsS0FBeEIsRUFBK0IsV0FBVyxLQUExQyxFQUFpRCxTQUFTQyxLQUExRCxHQU5GO0FBT0U7QUFBQTtBQUFBO0FBQ0UsMkJBQVcsQ0FEYjtBQUVFLGlDQUFnQixPQUZsQjtBQUdFLDJCQUFVLE1BSFo7QUFJRSw4QkFBWUQsS0FKZDtBQUtFLHVCQUFPTjtBQUxULGlCQU1NbEIsU0FOTixFQU9NcUIsY0FQTjtBQVNHLHFCQUFPRCxRQUFQLEtBQW9CLFVBQXBCLEdBQWlDQSxTQUFTLEVBQUVLLFlBQUYsRUFBVCxDQUFqQyxHQUF1REw7QUFUMUQ7QUFQRixXQUREO0FBQUE7QUFMSCxPQURGO0FBNkJEOzs7O0VBOUVxQixnQkFBTU0sUzs7QUFBeEJWLFMsQ0FDR1csUyxHQUFZO0FBQ2pCOzs7QUFHQVAsWUFBVSxvQkFBVVEsU0FBVixDQUFvQixDQUFDLG9CQUFVQyxJQUFYLEVBQWlCLG9CQUFVQyxJQUEzQixDQUFwQixFQUFzREMsVUFKL0M7O0FBTWpCOzs7QUFHQVosV0FBUyxvQkFBVWEsSUFURjs7QUFXakI7OztBQUdBVCxtQkFBaUIsb0JBQVVPLElBZFY7O0FBZ0JqQjs7O0FBR0FSLGtCQUFnQixvQkFBVVEsSUFuQlQ7O0FBcUJqQjs7O0FBR0FaLFNBQU8sb0JBQVVVLFNBQVYsQ0FBb0IsQ0FBQyxvQkFBVUssTUFBWCxFQUFtQixvQkFBVUMsTUFBN0IsQ0FBcEIsRUFBMERILFVBeEJoRDs7QUEwQmpCOzs7QUFHQVYsa0JBQWdCLG9CQUFVYztBQTdCVCxDO0FBRGZuQixTLENBaUNHb0IsWSxHQUFlO0FBQ3BCbEIsU0FBTyxHQURhO0FBRXBCSyxtQkFBaUIsMkJBQU0sQ0FBRSxDQUZMO0FBR3BCRCxrQkFBZ0IsMEJBQU0sQ0FBRTtBQUhKLEM7a0JBZ0RUTixTIiwiZmlsZSI6IlNpZGVTaGVldC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcydcbmltcG9ydCB7IGNzcyB9IGZyb20gJ3VpLWJveCdcbmltcG9ydCB7IFBhbmUgfSBmcm9tICcuLi8uLi9sYXllcnMnXG5pbXBvcnQgeyBPdmVybGF5IH0gZnJvbSAnLi4vLi4vb3ZlcmxheSdcbmltcG9ydCBTaGVldENsb3NlIGZyb20gJy4vU2hlZXRDbG9zZSdcblxuY29uc3QgcGFuZVByb3BzID0ge1xuICBoZWlnaHQ6ICcxMDB2aCcsXG4gIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICByaWdodDogMFxufVxuXG5jb25zdCBhbmltYXRpb25FYXNpbmcgPSB7XG4gIGRlY2VsZXJhdGlvbjogYGN1YmljLWJlemllcigwLjAsIDAuMCwgMC4yLCAxKWAsXG4gIGFjY2VsZXJhdGlvbjogYGN1YmljLWJlemllcigwLjQsIDAuMCwgMSwgMSlgXG59XG5cbmNvbnN0IEFOSU1BVElPTl9EVVJBVElPTiA9IDI0MFxuXG5jb25zdCBzbGlkZUluQW5pbWF0aW9uID0gY3NzLmtleWZyYW1lcygnc2xpZGVJbkFuaW1hdGlvbicsIHtcbiAgZnJvbToge1xuICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoMTAwJSlgXG4gIH0sXG4gIHRvOiB7XG4gICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgwKWBcbiAgfVxufSlcblxuY29uc3Qgc2xpZGVPdXRBbmltYXRpb24gPSBjc3Mua2V5ZnJhbWVzKCdzbGlkZU91dEFuaW1hdGlvbicsIHtcbiAgZnJvbToge1xuICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoMClgXG4gIH0sXG4gIHRvOiB7XG4gICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgxMDAlKWBcbiAgfVxufSlcblxuY29uc3QgYW5pbWF0aW9uU3R5bGVzID0ge1xuICB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKDEwMCUpYCxcbiAgJyZbZGF0YS1zdGF0ZT1cImVudGVyaW5nXCJdLCAmW2RhdGEtc3RhdGU9XCJlbnRlcmVkXCJdJzoge1xuICAgIGFuaW1hdGlvbjogYCR7c2xpZGVJbkFuaW1hdGlvbn0gJHtBTklNQVRJT05fRFVSQVRJT059bXMgJHtcbiAgICAgIGFuaW1hdGlvbkVhc2luZy5kZWNlbGVyYXRpb25cbiAgICB9IGJvdGhgXG4gIH0sXG4gICcmW2RhdGEtc3RhdGU9XCJleGl0aW5nXCJdJzoge1xuICAgIGFuaW1hdGlvbjogYCR7c2xpZGVPdXRBbmltYXRpb259ICR7QU5JTUFUSU9OX0RVUkFUSU9OfW1zICR7XG4gICAgICBhbmltYXRpb25FYXNpbmcuYWNjZWxlcmF0aW9uXG4gICAgfSBib3RoYFxuICB9XG59XG5cbmNsYXNzIFNpZGVTaGVldCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgLyoqXG4gICAgICogQ2hpbGRyZW4gY2FuIGJlIGEgc3RyaW5nLCBub2RlIG9yIGEgZnVuY3Rpb24gYWNjZXB0aW5nIGAoeyBjbG9zZSB9KWAuXG4gICAgICovXG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5ub2RlLCBQcm9wVHlwZXMuZnVuY10pLmlzUmVxdWlyZWQsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIHRoZSBTaWRlIFNoZWV0IGlzIHNob3duLlxuICAgICAqL1xuICAgIGlzU2hvd246IFByb3BUeXBlcy5ib29sLFxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBleGl0IHRyYW5zaXRpb24gaXMgY29tcGxldGUuXG4gICAgICovXG4gICAgb25DbG9zZUNvbXBsZXRlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgZW50ZXIgdHJhbnNpdGlvbiBpcyBjb21wbGV0ZS5cbiAgICAgKi9cbiAgICBvbk9wZW5Db21wbGV0ZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiB0aGUgU2lkZVNoZWV0LlxuICAgICAqL1xuICAgIHdpZHRoOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMubnVtYmVyXSkuaXNSZXF1aXJlZCxcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgdG8gcGFzcyB0aHJvdWdoIHRoZSBTaWRlU2hlZXQgY29udGFpbmVyIFBhbmUuXG4gICAgICovXG4gICAgY29udGFpbmVyUHJvcHM6IFByb3BUeXBlcy5vYmplY3RcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgd2lkdGg6IDYyMCxcbiAgICBvbkNsb3NlQ29tcGxldGU6ICgpID0+IHt9LFxuICAgIG9uT3BlbkNvbXBsZXRlOiAoKSA9PiB7fVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaXNTaG93bixcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgY29udGFpbmVyUHJvcHMsXG4gICAgICBvbk9wZW5Db21wbGV0ZSxcbiAgICAgIG9uQ2xvc2VDb21wbGV0ZVxuICAgIH0gPSB0aGlzLnByb3BzXG5cbiAgICByZXR1cm4gKFxuICAgICAgPE92ZXJsYXlcbiAgICAgICAgaXNTaG93bj17aXNTaG93bn1cbiAgICAgICAgb25FeGl0ZWQ9e29uQ2xvc2VDb21wbGV0ZX1cbiAgICAgICAgb25FbnRlcmVkPXtvbk9wZW5Db21wbGV0ZX1cbiAgICAgID5cbiAgICAgICAgeyh7IHN0YXRlLCBjbG9zZSB9KSA9PiAoXG4gICAgICAgICAgPFBhbmVcbiAgICAgICAgICAgIHdpZHRoPXt3aWR0aH1cbiAgICAgICAgICAgIHsuLi5wYW5lUHJvcHN9XG4gICAgICAgICAgICBjc3M9e2FuaW1hdGlvblN0eWxlc31cbiAgICAgICAgICAgIGRhdGEtc3RhdGU9e3N0YXRlfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxTaGVldENsb3NlIGRhdGEtc3RhdGU9e3N0YXRlfSBpc0Nsb3Npbmc9e2ZhbHNlfSBvbkNsaWNrPXtjbG9zZX0gLz5cbiAgICAgICAgICAgIDxQYW5lXG4gICAgICAgICAgICAgIGVsZXZhdGlvbj17NH1cbiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yPVwid2hpdGVcIlxuICAgICAgICAgICAgICBvdmVyZmxvd1k9XCJhdXRvXCJcbiAgICAgICAgICAgICAgZGF0YS1zdGF0ZT17c3RhdGV9XG4gICAgICAgICAgICAgIHdpZHRoPXt3aWR0aH1cbiAgICAgICAgICAgICAgey4uLnBhbmVQcm9wc31cbiAgICAgICAgICAgICAgey4uLmNvbnRhaW5lclByb3BzfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICB7dHlwZW9mIGNoaWxkcmVuID09PSAnZnVuY3Rpb24nID8gY2hpbGRyZW4oeyBjbG9zZSB9KSA6IGNoaWxkcmVufVxuICAgICAgICAgICAgPC9QYW5lPlxuICAgICAgICAgIDwvUGFuZT5cbiAgICAgICAgKX1cbiAgICAgIDwvT3ZlcmxheT5cbiAgICApXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2lkZVNoZWV0XG4iXX0=