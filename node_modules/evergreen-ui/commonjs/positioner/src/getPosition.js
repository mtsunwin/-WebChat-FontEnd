'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getFittedPosition;

var _Position = require('./Position');

var _Position2 = _interopRequireDefault(_Position);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Function to create a Rect.
 * @param {Object} dimensions
 * @param {Number} dimensions.width
 * @param {Number} dimensions.height
 * @param {Object} position
 * @param {Number} position.left
 * @param {Number} position.top
 * @return {Object} Rect { width, height, left, top, right, bottom }
 */
var makeRect = function makeRect(_ref, _ref2) {
  var width = _ref.width,
      height = _ref.height;
  var left = _ref2.left,
      top = _ref2.top;

  var ceiledLeft = Math.ceil(left);
  var ceiledTop = Math.ceil(top);
  return {
    width: width,
    height: height,
    left: ceiledLeft,
    top: ceiledTop,
    right: ceiledLeft + width,
    bottom: ceiledTop + height
  };
};

/**
 * Function to flip a position upside down.
 * @param {Position} position
 * @return {Position} flipped position
 */
var flipHorizontal = function flipHorizontal(position) {
  switch (position) {
    case _Position2.default.TOP_LEFT:
      return _Position2.default.BOTTOM_LEFT;
    case _Position2.default.TOP:
    default:
      return _Position2.default.BOTTOM;
    case _Position2.default.TOP_RIGHT:
      return _Position2.default.BOTTOM_RIGHT;
    case _Position2.default.BOTTOM_LEFT:
      return _Position2.default.TOP_LEFT;
    case _Position2.default.BOTTOM:
      return _Position2.default.TOP;
    case _Position2.default.BOTTOM_RIGHT:
      return _Position2.default.TOP_RIGHT;
  }
};

/**
 * Function that returns if position is aligned on top.
 * @param {Position} position
 * @return {Boolean}
 */
var isAlignedOnTop = function isAlignedOnTop(position) {
  switch (position) {
    case _Position2.default.TOP_LEFT:
    case _Position2.default.TOP:
    case _Position2.default.TOP_RIGHT:
      return true;
    default:
      return false;
  }
};

/**
 * Function that returns if a rect fits on bottom.
 * @param {Rect} rect
 * @param {Object} viewport
 * @param {Number} viewportOffset
 * @return {Boolean}
 */
var getFitsOnBottom = function getFitsOnBottom(rect, viewport, viewportOffset) {
  return rect.bottom < viewport.height - viewportOffset;
};

/**
 * Function that returns if a rect fits on top.
 * @param {Rect} rect
 * @param {Number} viewportOffset
 * @return {Boolean}
 */
var getFitsOnTop = function getFitsOnTop(rect, viewportOffset) {
  return rect.top > viewportOffset;
};

/**
 * Function that returns the CSS `tranform-origin` property.
 * @param {Rect} rect
 * @param {Position} position
 * @param {Number} targetCenter - center of the target.
 * @return {String} transform origin
 */
var getTransformOrigin = function getTransformOrigin(_ref3) {
  var rect = _ref3.rect,
      position = _ref3.position,
      targetCenter = _ref3.targetCenter;

  var center = Math.round(targetCenter - rect.left);
  if (isAlignedOnTop(position)) {
    return 'bottom ' + center + 'px';
  }
  return 'top ' + center + 'px';
};

/**
 * Function that takes in numbers and position and gives the final coords.
 * @param {Position} position — the position the positioner should be on.
 * @param {Object} dimensions — the dimensions of the positioner.
 * @param {Object} targetRect — the rect of the target.
 * @param {Number} targetOffset - offset from the target.
 * @param {Object} viewport - the width and height of the viewport.
 * @param {Object} viewportOffset - offset from the viewport.
 * @return {Object} - { x: Number, y: Number }
 */
function getFittedPosition(_ref4) {
  var position = _ref4.position,
      dimensions = _ref4.dimensions,
      targetRect = _ref4.targetRect,
      targetOffset = _ref4.targetOffset,
      viewport = _ref4.viewport,
      _ref4$viewportOffset = _ref4.viewportOffset,
      viewportOffset = _ref4$viewportOffset === undefined ? 8 : _ref4$viewportOffset;

  var targetCenter = targetRect.left + targetRect.width / 2;

  var _getPosition = getPosition({
    position: position,
    dimensions: dimensions,
    targetRect: targetRect,
    targetOffset: targetOffset,
    viewport: viewport,
    viewportOffset: viewportOffset
  }),
      rect = _getPosition.rect,
      finalPosition = _getPosition.position;

  // Push rect to the right if overflowing on the left side of the viewport.


  if (rect.left < viewportOffset) {
    rect.right += Math.ceil(Math.abs(rect.left - viewportOffset));
    rect.left = Math.ceil(viewportOffset);
  }

  // Push rect to the left if overflowing on the right side of the viewport.
  if (rect.right > viewport.width - viewportOffset) {
    var delta = Math.ceil(rect.right - (viewport.width - viewportOffset));
    rect.left -= delta;
    rect.right -= delta;
  }

  var transformOrigin = getTransformOrigin({
    rect: rect,
    position: finalPosition,
    targetCenter: targetCenter
  });

  return {
    rect: rect,
    position: finalPosition,
    transformOrigin: transformOrigin
  };
}

/**
 * Function that takes in numbers and position and gives the final coords.
 * @param {Position} position — the position the positioner should be on.
 * @param {Object} dimensions — the dimensions of the positioner.
 * @param {Object} targetRect — the rect of the target.
 * @param {Number} targetOffset - offset from the target.
 * @param {Object} viewport - the width and height of the viewport.
 * @param {Object} viewportOffset - offset from the viewport.
 * @return {Object} - { rect: Rect, position: Position }
 */
function getPosition(_ref5) {
  var position = _ref5.position,
      dimensions = _ref5.dimensions,
      targetRect = _ref5.targetRect,
      targetOffset = _ref5.targetOffset,
      viewport = _ref5.viewport,
      _ref5$viewportOffset = _ref5.viewportOffset,
      viewportOffset = _ref5$viewportOffset === undefined ? 8 : _ref5$viewportOffset;

  var positionIsAlignedOnTop = isAlignedOnTop(position);
  var topRect = void 0;
  var bottomRect = void 0;

  if (positionIsAlignedOnTop) {
    topRect = getRect({
      position: position,
      dimensions: dimensions,
      targetRect: targetRect,
      targetOffset: targetOffset
    });
    bottomRect = getRect({
      position: flipHorizontal(position),
      dimensions: dimensions,
      targetRect: targetRect,
      targetOffset: targetOffset
    });
  } else {
    topRect = getRect({
      position: flipHorizontal(position),
      dimensions: dimensions,
      targetRect: targetRect,
      targetOffset: targetOffset
    });
    bottomRect = getRect({
      position: position,
      dimensions: dimensions,
      targetRect: targetRect,
      targetOffset: targetOffset
    });
  }

  var topRectFitsOnTop = getFitsOnTop(topRect, viewportOffset);
  var bottomRectFitsOnBottom = getFitsOnBottom(bottomRect, viewport, viewportOffset);

  if (positionIsAlignedOnTop && topRectFitsOnTop) {
    return {
      position: position,
      rect: topRect
    };
  }

  if (!positionIsAlignedOnTop) {
    if (bottomRectFitsOnBottom) {
      return {
        position: position,
        rect: bottomRect
      };
    } else if (topRectFitsOnTop) {
      return {
        position: flipHorizontal(position),
        rect: topRect
      };
    }
  }

  // Default to most spacious if there is no fit.
  var spaceBottom = Math.abs(viewport.height - viewportOffset - bottomRect.bottom);
  var spaceTop = Math.abs(topRect.top - viewportOffset);

  if (spaceBottom < spaceTop) {
    return {
      position: positionIsAlignedOnTop ? flipHorizontal(position) : position,
      rect: bottomRect
    };
  }

  return {
    position: positionIsAlignedOnTop ? position : flipHorizontal(position),
    rect: topRect
  };
}

/**
 * Function that takes in numbers and position and gives the final coords.
 * @param {Object} position - the width and height of the viewport.
 * @param {Number} targetOffset - offset from the target.
 * @param {Object} dimensions — the dimensions of the positioner.
 * @param {Object} targetRect — the rect of the target.
 * @return {Object} - { x: Number, y: Number }
 */
function getRect(_ref6) {
  var position = _ref6.position,
      targetOffset = _ref6.targetOffset,
      dimensions = _ref6.dimensions,
      targetRect = _ref6.targetRect;

  var leftRect = targetRect.left + targetRect.width / 2 - dimensions.width / 2;
  var alignedTopY = targetRect.top - dimensions.height - targetOffset;
  var alignedBottomY = targetRect.bottom + targetOffset;
  var alignedRightX = targetRect.right - dimensions.width;

  switch (position) {
    case _Position2.default.TOP:
      return makeRect(dimensions, {
        left: leftRect,
        top: alignedTopY
      });
    case _Position2.default.TOP_LEFT:
      return makeRect(dimensions, {
        left: targetRect.left,
        top: alignedTopY
      });
    case _Position2.default.TOP_RIGHT:
      return makeRect(dimensions, {
        left: alignedRightX,
        top: alignedTopY
      });
    default:
    case _Position2.default.BOTTOM:
      return makeRect(dimensions, {
        left: leftRect,
        top: alignedBottomY
      });
    case _Position2.default.BOTTOM_LEFT:
      return makeRect(dimensions, {
        left: targetRect.left,
        top: alignedBottomY
      });
    case _Position2.default.BOTTOM_RIGHT:
      return makeRect(dimensions, {
        left: alignedRightX,
        top: alignedBottomY
      });
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wb3NpdGlvbmVyL3NyYy9nZXRQb3NpdGlvbi5qcyJdLCJuYW1lcyI6WyJnZXRGaXR0ZWRQb3NpdGlvbiIsIm1ha2VSZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJsZWZ0IiwidG9wIiwiY2VpbGVkTGVmdCIsIk1hdGgiLCJjZWlsIiwiY2VpbGVkVG9wIiwicmlnaHQiLCJib3R0b20iLCJmbGlwSG9yaXpvbnRhbCIsInBvc2l0aW9uIiwiVE9QX0xFRlQiLCJCT1RUT01fTEVGVCIsIlRPUCIsIkJPVFRPTSIsIlRPUF9SSUdIVCIsIkJPVFRPTV9SSUdIVCIsImlzQWxpZ25lZE9uVG9wIiwiZ2V0Rml0c09uQm90dG9tIiwicmVjdCIsInZpZXdwb3J0Iiwidmlld3BvcnRPZmZzZXQiLCJnZXRGaXRzT25Ub3AiLCJnZXRUcmFuc2Zvcm1PcmlnaW4iLCJ0YXJnZXRDZW50ZXIiLCJjZW50ZXIiLCJyb3VuZCIsImRpbWVuc2lvbnMiLCJ0YXJnZXRSZWN0IiwidGFyZ2V0T2Zmc2V0IiwiZ2V0UG9zaXRpb24iLCJmaW5hbFBvc2l0aW9uIiwiYWJzIiwiZGVsdGEiLCJ0cmFuc2Zvcm1PcmlnaW4iLCJwb3NpdGlvbklzQWxpZ25lZE9uVG9wIiwidG9wUmVjdCIsImJvdHRvbVJlY3QiLCJnZXRSZWN0IiwidG9wUmVjdEZpdHNPblRvcCIsImJvdHRvbVJlY3RGaXRzT25Cb3R0b20iLCJzcGFjZUJvdHRvbSIsInNwYWNlVG9wIiwibGVmdFJlY3QiLCJhbGlnbmVkVG9wWSIsImFsaWduZWRCb3R0b21ZIiwiYWxpZ25lZFJpZ2h0WCJdLCJtYXBwaW5ncyI6Ijs7Ozs7a0JBOEd3QkEsaUI7O0FBOUd4Qjs7Ozs7O0FBRUE7Ozs7Ozs7Ozs7QUFVQSxJQUFNQyxXQUFXLFNBQVhBLFFBQVcsY0FBc0M7QUFBQSxNQUFuQ0MsS0FBbUMsUUFBbkNBLEtBQW1DO0FBQUEsTUFBNUJDLE1BQTRCLFFBQTVCQSxNQUE0QjtBQUFBLE1BQWhCQyxJQUFnQixTQUFoQkEsSUFBZ0I7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QixDQUFQO0FBSUYsU0FBSyxtQkFBUzdCLFNBQWQ7QUFDRSxhQUFPakIsU0FBUzZCLFVBQVQsRUFBcUI7QUFDMUIxQixjQUFNNkMsYUFEb0I7QUFFMUI1QyxhQUFLMEM7QUFGcUIsT0FBckIsQ0FBUDtBQUlGO0FBQ0EsU0FBSyxtQkFBUzlCLE1BQWQ7QUFDRSxhQUFPaEIsU0FBUzZCLFVBQVQsRUFBcUI7QUFDMUIxQixjQUFNMEMsUUFEb0I7QUFFMUJ6QyxhQUFLMkM7QUFGcUIsT0FBckIsQ0FBUDtBQUlGLFNBQUssbUJBQVNqQyxXQUFkO0FBQ0UsYUFBT2QsU0FBUzZCLFVBQVQsRUFBcUI7QUFDMUIxQixjQUFNMkIsV0FBVzNCLElBRFM7QUFFMUJDLGFBQUsyQztBQUZxQixPQUFyQixDQUFQO0FBSUYsU0FBSyxtQkFBUzdCLFlBQWQ7QUFDRSxhQUFPbEIsU0FBUzZCLFVBQVQsRUFBcUI7QUFDMUIxQixjQUFNNkMsYUFEb0I7QUFFMUI1QyxhQUFLMkM7QUFGcUIsT0FBckIsQ0FBUDtBQTVCSjtBQWlDRCIsImZpbGUiOiJnZXRQb3NpdGlvbi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQb3NpdGlvbiBmcm9tICcuL1Bvc2l0aW9uJ1xuXG4vKipcbiAqIEZ1bmN0aW9uIHRvIGNyZWF0ZSBhIFJlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gZGltZW5zaW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IGRpbWVuc2lvbnMud2lkdGhcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaW1lbnNpb25zLmhlaWdodFxuICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24ubGVmdFxuICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uLnRvcFxuICogQHJldHVybiB7T2JqZWN0fSBSZWN0IHsgd2lkdGgsIGhlaWdodCwgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tIH1cbiAqL1xuY29uc3QgbWFrZVJlY3QgPSAoeyB3aWR0aCwgaGVpZ2h0IH0sIHsgbGVmdCwgdG9wIH0pID0+IHtcbiAgY29uc3QgY2VpbGVkTGVmdCA9IE1hdGguY2VpbChsZWZ0KVxuICBjb25zdCBjZWlsZWRUb3AgPSBNYXRoLmNlaWwodG9wKVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBsZWZ0OiBjZWlsZWRMZWZ0LFxuICAgIHRvcDogY2VpbGVkVG9wLFxuICAgIHJpZ2h0OiBjZWlsZWRMZWZ0ICsgd2lkdGgsXG4gICAgYm90dG9tOiBjZWlsZWRUb3AgKyBoZWlnaHRcbiAgfVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHRvIGZsaXAgYSBwb3NpdGlvbiB1cHNpZGUgZG93bi5cbiAqIEBwYXJhbSB7UG9zaXRpb259IHBvc2l0aW9uXG4gKiBAcmV0dXJuIHtQb3NpdGlvbn0gZmxpcHBlZCBwb3NpdGlvblxuICovXG5jb25zdCBmbGlwSG9yaXpvbnRhbCA9IHBvc2l0aW9uID0+IHtcbiAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgIGNhc2UgUG9zaXRpb24uVE9QX0xFRlQ6XG4gICAgICByZXR1cm4gUG9zaXRpb24uQk9UVE9NX0xFRlRcbiAgICBjYXNlIFBvc2l0aW9uLlRPUDpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFBvc2l0aW9uLkJPVFRPTVxuICAgIGNhc2UgUG9zaXRpb24uVE9QX1JJR0hUOlxuICAgICAgcmV0dXJuIFBvc2l0aW9uLkJPVFRPTV9SSUdIVFxuICAgIGNhc2UgUG9zaXRpb24uQk9UVE9NX0xFRlQ6XG4gICAgICByZXR1cm4gUG9zaXRpb24uVE9QX0xFRlRcbiAgICBjYXNlIFBvc2l0aW9uLkJPVFRPTTpcbiAgICAgIHJldHVybiBQb3NpdGlvbi5UT1BcbiAgICBjYXNlIFBvc2l0aW9uLkJPVFRPTV9SSUdIVDpcbiAgICAgIHJldHVybiBQb3NpdGlvbi5UT1BfUklHSFRcbiAgfVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyBpZiBwb3NpdGlvbiBpcyBhbGlnbmVkIG9uIHRvcC5cbiAqIEBwYXJhbSB7UG9zaXRpb259IHBvc2l0aW9uXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5jb25zdCBpc0FsaWduZWRPblRvcCA9IHBvc2l0aW9uID0+IHtcbiAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgIGNhc2UgUG9zaXRpb24uVE9QX0xFRlQ6XG4gICAgY2FzZSBQb3NpdGlvbi5UT1A6XG4gICAgY2FzZSBQb3NpdGlvbi5UT1BfUklHSFQ6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyBpZiBhIHJlY3QgZml0cyBvbiBib3R0b20uXG4gKiBAcGFyYW0ge1JlY3R9IHJlY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSB2aWV3cG9ydFxuICogQHBhcmFtIHtOdW1iZXJ9IHZpZXdwb3J0T2Zmc2V0XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5jb25zdCBnZXRGaXRzT25Cb3R0b20gPSAocmVjdCwgdmlld3BvcnQsIHZpZXdwb3J0T2Zmc2V0KSA9PiB7XG4gIHJldHVybiByZWN0LmJvdHRvbSA8IHZpZXdwb3J0LmhlaWdodCAtIHZpZXdwb3J0T2Zmc2V0XG59XG5cbi8qKlxuICogRnVuY3Rpb24gdGhhdCByZXR1cm5zIGlmIGEgcmVjdCBmaXRzIG9uIHRvcC5cbiAqIEBwYXJhbSB7UmVjdH0gcmVjdFxuICogQHBhcmFtIHtOdW1iZXJ9IHZpZXdwb3J0T2Zmc2V0XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5jb25zdCBnZXRGaXRzT25Ub3AgPSAocmVjdCwgdmlld3BvcnRPZmZzZXQpID0+IHtcbiAgcmV0dXJuIHJlY3QudG9wID4gdmlld3BvcnRPZmZzZXRcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIENTUyBgdHJhbmZvcm0tb3JpZ2luYCBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7UmVjdH0gcmVjdFxuICogQHBhcmFtIHtQb3NpdGlvbn0gcG9zaXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB0YXJnZXRDZW50ZXIgLSBjZW50ZXIgb2YgdGhlIHRhcmdldC5cbiAqIEByZXR1cm4ge1N0cmluZ30gdHJhbnNmb3JtIG9yaWdpblxuICovXG5jb25zdCBnZXRUcmFuc2Zvcm1PcmlnaW4gPSAoeyByZWN0LCBwb3NpdGlvbiwgdGFyZ2V0Q2VudGVyIH0pID0+IHtcbiAgY29uc3QgY2VudGVyID0gTWF0aC5yb3VuZCh0YXJnZXRDZW50ZXIgLSByZWN0LmxlZnQpXG4gIGlmIChpc0FsaWduZWRPblRvcChwb3NpdGlvbikpIHtcbiAgICByZXR1cm4gYGJvdHRvbSAke2NlbnRlcn1weGBcbiAgfVxuICByZXR1cm4gYHRvcCAke2NlbnRlcn1weGBcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB0aGF0IHRha2VzIGluIG51bWJlcnMgYW5kIHBvc2l0aW9uIGFuZCBnaXZlcyB0aGUgZmluYWwgY29vcmRzLlxuICogQHBhcmFtIHtQb3NpdGlvbn0gcG9zaXRpb24g4oCUIHRoZSBwb3NpdGlvbiB0aGUgcG9zaXRpb25lciBzaG91bGQgYmUgb24uXG4gKiBAcGFyYW0ge09iamVjdH0gZGltZW5zaW9ucyDigJQgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIHBvc2l0aW9uZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0UmVjdCDigJQgdGhlIHJlY3Qgb2YgdGhlIHRhcmdldC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB0YXJnZXRPZmZzZXQgLSBvZmZzZXQgZnJvbSB0aGUgdGFyZ2V0LlxuICogQHBhcmFtIHtPYmplY3R9IHZpZXdwb3J0IC0gdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHZpZXdwb3J0LlxuICogQHBhcmFtIHtPYmplY3R9IHZpZXdwb3J0T2Zmc2V0IC0gb2Zmc2V0IGZyb20gdGhlIHZpZXdwb3J0LlxuICogQHJldHVybiB7T2JqZWN0fSAtIHsgeDogTnVtYmVyLCB5OiBOdW1iZXIgfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRGaXR0ZWRQb3NpdGlvbih7XG4gIHBvc2l0aW9uLFxuICBkaW1lbnNpb25zLFxuICB0YXJnZXRSZWN0LFxuICB0YXJnZXRPZmZzZXQsXG4gIHZpZXdwb3J0LFxuICB2aWV3cG9ydE9mZnNldCA9IDhcbn0pIHtcbiAgY29uc3QgdGFyZ2V0Q2VudGVyID0gdGFyZ2V0UmVjdC5sZWZ0ICsgdGFyZ2V0UmVjdC53aWR0aCAvIDJcblxuICBjb25zdCB7IHJlY3QsIHBvc2l0aW9uOiBmaW5hbFBvc2l0aW9uIH0gPSBnZXRQb3NpdGlvbih7XG4gICAgcG9zaXRpb24sXG4gICAgZGltZW5zaW9ucyxcbiAgICB0YXJnZXRSZWN0LFxuICAgIHRhcmdldE9mZnNldCxcbiAgICB2aWV3cG9ydCxcbiAgICB2aWV3cG9ydE9mZnNldFxuICB9KVxuXG4gIC8vIFB1c2ggcmVjdCB0byB0aGUgcmlnaHQgaWYgb3ZlcmZsb3dpbmcgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgdmlld3BvcnQuXG4gIGlmIChyZWN0LmxlZnQgPCB2aWV3cG9ydE9mZnNldCkge1xuICAgIHJlY3QucmlnaHQgKz0gTWF0aC5jZWlsKE1hdGguYWJzKHJlY3QubGVmdCAtIHZpZXdwb3J0T2Zmc2V0KSlcbiAgICByZWN0LmxlZnQgPSBNYXRoLmNlaWwodmlld3BvcnRPZmZzZXQpXG4gIH1cblxuICAvLyBQdXNoIHJlY3QgdG8gdGhlIGxlZnQgaWYgb3ZlcmZsb3dpbmcgb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHZpZXdwb3J0LlxuICBpZiAocmVjdC5yaWdodCA+IHZpZXdwb3J0LndpZHRoIC0gdmlld3BvcnRPZmZzZXQpIHtcbiAgICBjb25zdCBkZWx0YSA9IE1hdGguY2VpbChyZWN0LnJpZ2h0IC0gKHZpZXdwb3J0LndpZHRoIC0gdmlld3BvcnRPZmZzZXQpKVxuICAgIHJlY3QubGVmdCAtPSBkZWx0YVxuICAgIHJlY3QucmlnaHQgLT0gZGVsdGFcbiAgfVxuXG4gIGNvbnN0IHRyYW5zZm9ybU9yaWdpbiA9IGdldFRyYW5zZm9ybU9yaWdpbih7XG4gICAgcmVjdCxcbiAgICBwb3NpdGlvbjogZmluYWxQb3NpdGlvbixcbiAgICB0YXJnZXRDZW50ZXJcbiAgfSlcblxuICByZXR1cm4ge1xuICAgIHJlY3QsXG4gICAgcG9zaXRpb246IGZpbmFsUG9zaXRpb24sXG4gICAgdHJhbnNmb3JtT3JpZ2luXG4gIH1cbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB0aGF0IHRha2VzIGluIG51bWJlcnMgYW5kIHBvc2l0aW9uIGFuZCBnaXZlcyB0aGUgZmluYWwgY29vcmRzLlxuICogQHBhcmFtIHtQb3NpdGlvbn0gcG9zaXRpb24g4oCUIHRoZSBwb3NpdGlvbiB0aGUgcG9zaXRpb25lciBzaG91bGQgYmUgb24uXG4gKiBAcGFyYW0ge09iamVjdH0gZGltZW5zaW9ucyDigJQgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIHBvc2l0aW9uZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0UmVjdCDigJQgdGhlIHJlY3Qgb2YgdGhlIHRhcmdldC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB0YXJnZXRPZmZzZXQgLSBvZmZzZXQgZnJvbSB0aGUgdGFyZ2V0LlxuICogQHBhcmFtIHtPYmplY3R9IHZpZXdwb3J0IC0gdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHZpZXdwb3J0LlxuICogQHBhcmFtIHtPYmplY3R9IHZpZXdwb3J0T2Zmc2V0IC0gb2Zmc2V0IGZyb20gdGhlIHZpZXdwb3J0LlxuICogQHJldHVybiB7T2JqZWN0fSAtIHsgcmVjdDogUmVjdCwgcG9zaXRpb246IFBvc2l0aW9uIH1cbiAqL1xuZnVuY3Rpb24gZ2V0UG9zaXRpb24oe1xuICBwb3NpdGlvbixcbiAgZGltZW5zaW9ucyxcbiAgdGFyZ2V0UmVjdCxcbiAgdGFyZ2V0T2Zmc2V0LFxuICB2aWV3cG9ydCxcbiAgdmlld3BvcnRPZmZzZXQgPSA4XG59KSB7XG4gIGNvbnN0IHBvc2l0aW9uSXNBbGlnbmVkT25Ub3AgPSBpc0FsaWduZWRPblRvcChwb3NpdGlvbilcbiAgbGV0IHRvcFJlY3RcbiAgbGV0IGJvdHRvbVJlY3RcblxuICBpZiAocG9zaXRpb25Jc0FsaWduZWRPblRvcCkge1xuICAgIHRvcFJlY3QgPSBnZXRSZWN0KHtcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgZGltZW5zaW9ucyxcbiAgICAgIHRhcmdldFJlY3QsXG4gICAgICB0YXJnZXRPZmZzZXRcbiAgICB9KVxuICAgIGJvdHRvbVJlY3QgPSBnZXRSZWN0KHtcbiAgICAgIHBvc2l0aW9uOiBmbGlwSG9yaXpvbnRhbChwb3NpdGlvbiksXG4gICAgICBkaW1lbnNpb25zLFxuICAgICAgdGFyZ2V0UmVjdCxcbiAgICAgIHRhcmdldE9mZnNldFxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgdG9wUmVjdCA9IGdldFJlY3Qoe1xuICAgICAgcG9zaXRpb246IGZsaXBIb3Jpem9udGFsKHBvc2l0aW9uKSxcbiAgICAgIGRpbWVuc2lvbnMsXG4gICAgICB0YXJnZXRSZWN0LFxuICAgICAgdGFyZ2V0T2Zmc2V0XG4gICAgfSlcbiAgICBib3R0b21SZWN0ID0gZ2V0UmVjdCh7XG4gICAgICBwb3NpdGlvbixcbiAgICAgIGRpbWVuc2lvbnMsXG4gICAgICB0YXJnZXRSZWN0LFxuICAgICAgdGFyZ2V0T2Zmc2V0XG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IHRvcFJlY3RGaXRzT25Ub3AgPSBnZXRGaXRzT25Ub3AodG9wUmVjdCwgdmlld3BvcnRPZmZzZXQpXG4gIGNvbnN0IGJvdHRvbVJlY3RGaXRzT25Cb3R0b20gPSBnZXRGaXRzT25Cb3R0b20oXG4gICAgYm90dG9tUmVjdCxcbiAgICB2aWV3cG9ydCxcbiAgICB2aWV3cG9ydE9mZnNldFxuICApXG5cbiAgaWYgKHBvc2l0aW9uSXNBbGlnbmVkT25Ub3AgJiYgdG9wUmVjdEZpdHNPblRvcCkge1xuICAgIHJldHVybiB7XG4gICAgICBwb3NpdGlvbixcbiAgICAgIHJlY3Q6IHRvcFJlY3RcbiAgICB9XG4gIH1cblxuICBpZiAoIXBvc2l0aW9uSXNBbGlnbmVkT25Ub3ApIHtcbiAgICBpZiAoYm90dG9tUmVjdEZpdHNPbkJvdHRvbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcG9zaXRpb24sXG4gICAgICAgIHJlY3Q6IGJvdHRvbVJlY3RcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRvcFJlY3RGaXRzT25Ub3ApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvc2l0aW9uOiBmbGlwSG9yaXpvbnRhbChwb3NpdGlvbiksXG4gICAgICAgIHJlY3Q6IHRvcFJlY3RcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBEZWZhdWx0IHRvIG1vc3Qgc3BhY2lvdXMgaWYgdGhlcmUgaXMgbm8gZml0LlxuICBjb25zdCBzcGFjZUJvdHRvbSA9IE1hdGguYWJzKFxuICAgIHZpZXdwb3J0LmhlaWdodCAtIHZpZXdwb3J0T2Zmc2V0IC0gYm90dG9tUmVjdC5ib3R0b21cbiAgKVxuICBjb25zdCBzcGFjZVRvcCA9IE1hdGguYWJzKHRvcFJlY3QudG9wIC0gdmlld3BvcnRPZmZzZXQpXG5cbiAgaWYgKHNwYWNlQm90dG9tIDwgc3BhY2VUb3ApIHtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zaXRpb246IHBvc2l0aW9uSXNBbGlnbmVkT25Ub3AgPyBmbGlwSG9yaXpvbnRhbChwb3NpdGlvbikgOiBwb3NpdGlvbixcbiAgICAgIHJlY3Q6IGJvdHRvbVJlY3RcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvbklzQWxpZ25lZE9uVG9wID8gcG9zaXRpb24gOiBmbGlwSG9yaXpvbnRhbChwb3NpdGlvbiksXG4gICAgcmVjdDogdG9wUmVjdFxuICB9XG59XG5cbi8qKlxuICogRnVuY3Rpb24gdGhhdCB0YWtlcyBpbiBudW1iZXJzIGFuZCBwb3NpdGlvbiBhbmQgZ2l2ZXMgdGhlIGZpbmFsIGNvb3Jkcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbiAtIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSB2aWV3cG9ydC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB0YXJnZXRPZmZzZXQgLSBvZmZzZXQgZnJvbSB0aGUgdGFyZ2V0LlxuICogQHBhcmFtIHtPYmplY3R9IGRpbWVuc2lvbnMg4oCUIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBwb3NpdGlvbmVyLlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFJlY3Qg4oCUIHRoZSByZWN0IG9mIHRoZSB0YXJnZXQuXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0geyB4OiBOdW1iZXIsIHk6IE51bWJlciB9XG4gKi9cbmZ1bmN0aW9uIGdldFJlY3QoeyBwb3NpdGlvbiwgdGFyZ2V0T2Zmc2V0LCBkaW1lbnNpb25zLCB0YXJnZXRSZWN0IH0pIHtcbiAgY29uc3QgbGVmdFJlY3QgPSB0YXJnZXRSZWN0LmxlZnQgKyB0YXJnZXRSZWN0LndpZHRoIC8gMiAtIGRpbWVuc2lvbnMud2lkdGggLyAyXG4gIGNvbnN0IGFsaWduZWRUb3BZID0gdGFyZ2V0UmVjdC50b3AgLSBkaW1lbnNpb25zLmhlaWdodCAtIHRhcmdldE9mZnNldFxuICBjb25zdCBhbGlnbmVkQm90dG9tWSA9IHRhcmdldFJlY3QuYm90dG9tICsgdGFyZ2V0T2Zmc2V0XG4gIGNvbnN0IGFsaWduZWRSaWdodFggPSB0YXJnZXRSZWN0LnJpZ2h0IC0gZGltZW5zaW9ucy53aWR0aFxuXG4gIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICBjYXNlIFBvc2l0aW9uLlRPUDpcbiAgICAgIHJldHVybiBtYWtlUmVjdChkaW1lbnNpb25zLCB7XG4gICAgICAgIGxlZnQ6IGxlZnRSZWN0LFxuICAgICAgICB0b3A6IGFsaWduZWRUb3BZXG4gICAgICB9KVxuICAgIGNhc2UgUG9zaXRpb24uVE9QX0xFRlQ6XG4gICAgICByZXR1cm4gbWFrZVJlY3QoZGltZW5zaW9ucywge1xuICAgICAgICBsZWZ0OiB0YXJnZXRSZWN0LmxlZnQsXG4gICAgICAgIHRvcDogYWxpZ25lZFRvcFlcbiAgICAgIH0pXG4gICAgY2FzZSBQb3NpdGlvbi5UT1BfUklHSFQ6XG4gICAgICByZXR1cm4gbWFrZVJlY3QoZGltZW5zaW9ucywge1xuICAgICAgICBsZWZ0OiBhbGlnbmVkUmlnaHRYLFxuICAgICAgICB0b3A6IGFsaWduZWRUb3BZXG4gICAgICB9KVxuICAgIGRlZmF1bHQ6XG4gICAgY2FzZSBQb3NpdGlvbi5CT1RUT006XG4gICAgICByZXR1cm4gbWFrZVJlY3QoZGltZW5zaW9ucywge1xuICAgICAgICBsZWZ0OiBsZWZ0UmVjdCxcbiAgICAgICAgdG9wOiBhbGlnbmVkQm90dG9tWVxuICAgICAgfSlcbiAgICBjYXNlIFBvc2l0aW9uLkJPVFRPTV9MRUZUOlxuICAgICAgcmV0dXJuIG1ha2VSZWN0KGRpbWVuc2lvbnMsIHtcbiAgICAgICAgbGVmdDogdGFyZ2V0UmVjdC5sZWZ0LFxuICAgICAgICB0b3A6IGFsaWduZWRCb3R0b21ZXG4gICAgICB9KVxuICAgIGNhc2UgUG9zaXRpb24uQk9UVE9NX1JJR0hUOlxuICAgICAgcmV0dXJuIG1ha2VSZWN0KGRpbWVuc2lvbnMsIHtcbiAgICAgICAgbGVmdDogYWxpZ25lZFJpZ2h0WCxcbiAgICAgICAgdG9wOiBhbGlnbmVkQm90dG9tWVxuICAgICAgfSlcbiAgfVxufVxuIl19