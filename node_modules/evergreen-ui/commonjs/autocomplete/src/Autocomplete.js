'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _fuzzaldrinPlus = require('fuzzaldrin-plus');

var _fuzzaldrinPlus2 = _interopRequireDefault(_fuzzaldrinPlus);

var _downshift = require('downshift');

var _downshift2 = _interopRequireDefault(_downshift);

var _reactTinyVirtualList = require('react-tiny-virtual-list');

var _reactTinyVirtualList2 = _interopRequireDefault(_reactTinyVirtualList);

var _popover = require('../../popover');

var _positioner = require('../../positioner');

var _typography = require('../../typography');

var _layers = require('../../layers');

var _AutocompleteItem = require('./AutocompleteItem');

var _AutocompleteItem2 = _interopRequireDefault(_AutocompleteItem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var fuzzyFilter = function fuzzyFilter(items, input) {
  return _fuzzaldrinPlus2.default.filter(items, input);
};

var autocompleteItemRenderer = function autocompleteItemRenderer(props) {
  return _react2.default.createElement(_AutocompleteItem2.default, props);
};

// https://github.com/paypal/downshift/issues/164

var Autocomplete = function (_PureComponent) {
  _inherits(Autocomplete, _PureComponent);

  function Autocomplete() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, Autocomplete);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Autocomplete.__proto__ || Object.getPrototypeOf(Autocomplete)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      targetWidth: 0
    }, _this.renderResults = function (_ref2) {
      var width = _ref2.width,
          inputValue = _ref2.inputValue,
          highlightedIndex = _ref2.highlightedIndex,
          selectItemAtIndex = _ref2.selectItemAtIndex,
          selectedItem = _ref2.selectedItem,
          getItemProps = _ref2.getItemProps;
      var _this$props = _this.props,
          title = _this$props.title,
          itemSize = _this$props.itemSize,
          itemsFilter = _this$props.itemsFilter,
          originalItems = _this$props.items,
          itemToString = _this$props.itemToString,
          _renderItem = _this$props.renderItem,
          popoverMaxHeight = _this$props.popoverMaxHeight,
          isFilterDisabled = _this$props.isFilterDisabled;


      var items = isFilterDisabled || inputValue.trim() === '' ? originalItems : itemsFilter(originalItems, inputValue);

      if (items.length === 0) return null;

      return _react2.default.createElement(
        _layers.Pane,
        { width: width },
        title && _react2.default.createElement(
          _layers.Pane,
          { padding: 8, borderBottom: 'extraMuted' },
          _react2.default.createElement(
            _typography.Text,
            { size: 200, color: 'muted', isUppercase: true },
            title
          )
        ),
        items.length > 0 && _react2.default.createElement(_reactTinyVirtualList2.default, {
          width: '100%',
          height: Math.min(items.length * itemSize, popoverMaxHeight),
          itemSize: itemSize,
          itemCount: items.length,
          scrollToIndex: highlightedIndex || 0,
          overscanCount: 3,
          scrollToAlignment: 'auto',
          renderItem: function renderItem(_ref3) {
            var index = _ref3.index,
                style = _ref3.style;

            var item = items[index];
            var itemString = itemToString(item);
            return _renderItem(getItemProps({
              item: item,
              key: itemString,
              index: index,
              style: style,
              children: itemString,
              onMouseUp: function onMouseUp() {
                selectItemAtIndex(index);
              },
              isSelected: itemToString(selectedItem) === itemString,
              isHighlighted: highlightedIndex === index
            }));
          }
        })
      );
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Autocomplete, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.setState({
        targetWidth: this.targetRef.getBoundingClientRect().width
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          children = _props.children,
          itemSize = _props.itemSize,
          position = _props.position,
          renderItem = _props.renderItem,
          itemsFilter = _props.itemsFilter,
          popoverMaxHeight = _props.popoverMaxHeight,
          popoverMinWidth = _props.popoverMinWidth,
          defaultSelectedItem = _props.defaultSelectedItem,
          props = _objectWithoutProperties(_props, ['children', 'itemSize', 'position', 'renderItem', 'itemsFilter', 'popoverMaxHeight', 'popoverMinWidth', 'defaultSelectedItem']);

      return _react2.default.createElement(
        _downshift2.default,
        _extends({ defaultSelectedItem: defaultSelectedItem }, props),
        function (_ref4) {
          var isShown = _ref4.isOpen,
              inputValue = _ref4.inputValue,
              getItemProps = _ref4.getItemProps,
              selectedItem = _ref4.selectedItem,
              highlightedIndex = _ref4.highlightedIndex,
              selectItemAtIndex = _ref4.selectItemAtIndex,
              restDownshiftProps = _objectWithoutProperties(_ref4, ['isOpen', 'inputValue', 'getItemProps', 'selectedItem', 'highlightedIndex', 'selectItemAtIndex']);

          return _react2.default.createElement(
            'div',
            null,
            _react2.default.createElement(
              _popover.Popover,
              {
                bringFocusInside: false,
                isShown: isShown,
                minWidth: popoverMinWidth,
                position: position || (_this2.state.targetWidth < popoverMinWidth ? _positioner.Position.BOTTOM_LEFT : _positioner.Position.BOTTOM),
                content: function content() {
                  return _this2.renderResults({
                    width: Math.max(_this2.state.targetWidth, popoverMinWidth),
                    inputValue: inputValue,
                    getItemProps: getItemProps,
                    selectedItem: selectedItem,
                    highlightedIndex: highlightedIndex,
                    selectItemAtIndex: selectItemAtIndex
                  });
                },
                minHeight: 0,
                animationDuration: 0
              },
              function (_ref5) {
                var isShownPopover = _ref5.isShown,
                    toggle = _ref5.toggle,
                    _getRef = _ref5.getRef;
                return children(_extends({
                  isShown: isShownPopover,
                  toggle: toggle,
                  getRef: function getRef(ref) {
                    // Use the ref internally to determine the width
                    _this2.targetRef = ref;
                    _getRef(ref);
                  },
                  inputValue: inputValue,
                  selectedItem: selectedItem,
                  highlightedIndex: highlightedIndex,
                  selectItemAtIndex: selectItemAtIndex
                }, restDownshiftProps));
              }
            )
          );
        }
      );
    }
  }]);

  return Autocomplete;
}(_react.PureComponent);

Autocomplete.propTypes = _extends({
  /**
   * This prop can be either a string or a Node.
   * It will provide a title for the items
   */
  title: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.node]),

  /**
   * An array of items to be used as options for the select
   */
  items: _propTypes2.default.array.isRequired,

  /**
   * The selected Item to be shown on the autocomplete
   */
  selectedItem: _propTypes2.default.any,

  /**
   * The selected item to be selected & shown by default on the autocomplete
   */
  defaultSelectedItem: _propTypes2.default.any,

  /**
   * In case the array of items is not an array of strings,
   * this function is used on each item to return the string that will be shown on the filter
   */
  itemToString: _propTypes2.default.func.isRequired,

  /**
   * Function that will render the 'filter' component.
   */
  children: _propTypes2.default.func.isRequired,

  /**
   * The height of each item in the list
   * Because the list is virtualized this is required beforehand.
   */
  itemSize: _propTypes2.default.number,

  /**
   * Function that returns a component to render the item
   */
  renderItem: _propTypes2.default.func,

  /**
   * The position of the Popover the Autocomplete is rendered in.
   */
  position: _propTypes2.default.oneOf(Object.keys(_positioner.Position)),

  /**
   * A function that is used to filter the items.
   * It should return a subset of the initial items.
   * By default the "fuzzaldrin-plus" package is used.
   */
  itemsFilter: _propTypes2.default.func,

  /**
   * Prop that enables and disables filtering
   * True: Enables Filtering
   * False: Disables Filtering
   */
  isFilterDisabled: _propTypes2.default.bool,

  /**
   * Defines the minimum height the results container will be
   */
  popoverMinWidth: _propTypes2.default.number,

  /**
   * Defines the maximum height the results container will be
   */
  popoverMaxHeight: _propTypes2.default.number

}, _downshift2.default.propTypes);
Autocomplete.defaultProps = {
  itemToString: function itemToString(i) {
    return i ? String(i) : '';
  },
  itemSize: 32,
  itemsFilter: fuzzyFilter,
  isFilterDisabled: false,
  popoverMinWidth: 240,
  popoverMaxHeight: 240,
  renderItem: autocompleteItemRenderer
};
exports.default = Autocomplete;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9hdXRvY29tcGxldGUvc3JjL0F1dG9jb21wbGV0ZS5qcyJdLCJuYW1lcyI6WyJmdXp6eUZpbHRlciIsIml0ZW1zIiwiaW5wdXQiLCJmaWx0ZXIiLCJhdXRvY29tcGxldGVJdGVtUmVuZGVyZXIiLCJwcm9wcyIsIkF1dG9jb21wbGV0ZSIsInN0YXRlIiwidGFyZ2V0V2lkdGgiLCJyZW5kZXJSZXN1bHRzIiwid2lkdGgiLCJpbnB1dFZhbHVlIiwiaGlnaGxpZ2h0ZWRJbmRleCIsInNlbGVjdEl0ZW1BdEluZGV4Iiwic2VsZWN0ZWRJdGVtIiwiZ2V0SXRlbVByb3BzIiwidGl0bGUiLCJpdGVtU2l6ZSIsIml0ZW1zRmlsdGVyIiwib3JpZ2luYWxJdGVtcyIsIml0ZW1Ub1N0cmluZyIsInJlbmRlckl0ZW0iLCJwb3BvdmVyTWF4SGVpZ2h0IiwiaXNGaWx0ZXJEaXNhYmxlZCIsInRyaW0iLCJsZW5ndGgiLCJNYXRoIiwibWluIiwiaW5kZXgiLCJzdHlsZSIsIml0ZW0iLCJpdGVtU3RyaW5nIiwia2V5IiwiY2hpbGRyZW4iLCJvbk1vdXNlVXAiLCJpc1NlbGVjdGVkIiwiaXNIaWdobGlnaHRlZCIsInNldFN0YXRlIiwidGFyZ2V0UmVmIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwicG9zaXRpb24iLCJwb3BvdmVyTWluV2lkdGgiLCJkZWZhdWx0U2VsZWN0ZWRJdGVtIiwiaXNTaG93biIsImlzT3BlbiIsInJlc3REb3duc2hpZnRQcm9wcyIsIkJPVFRPTV9MRUZUIiwiQk9UVE9NIiwibWF4IiwiaXNTaG93blBvcG92ZXIiLCJ0b2dnbGUiLCJnZXRSZWYiLCJyZWYiLCJwcm9wVHlwZXMiLCJvbmVPZlR5cGUiLCJzdHJpbmciLCJub2RlIiwiYXJyYXkiLCJpc1JlcXVpcmVkIiwiYW55IiwiZnVuYyIsIm51bWJlciIsIm9uZU9mIiwiT2JqZWN0Iiwia2V5cyIsImJvb2wiLCJkZWZhdWx0UHJvcHMiLCJpIiwiU3RyaW5nIl0sIm1hcHBpbmdzIjoi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a0Isb0JBQVUwQyxJOztBQUU1Qjs7O0FBR0F4QixtQkFBaUIsb0JBQVVvQixNOztBQUUzQjs7O0FBR0F2QyxvQkFBa0Isb0JBQVV1Qzs7R0FFekIsb0JBQVVSLFM7QUExRUkvQyxZLENBaUZaNEQsWSxHQUFlO0FBQ3BCOUMsZ0JBQWM7QUFBQSxXQUFNK0MsSUFBSUMsT0FBT0QsQ0FBUCxDQUFKLEdBQWdCLEVBQXRCO0FBQUEsR0FETTtBQUVwQmxELFlBQVUsRUFGVTtBQUdwQkMsZUFBYWxCLFdBSE87QUFJcEJ1QixvQkFBa0IsS0FKRTtBQUtwQmtCLG1CQUFpQixHQUxHO0FBTXBCbkIsb0JBQWtCLEdBTkU7QUFPcEJELGNBQVlqQjtBQVBRLEM7a0JBakZIRSxZIiwiZmlsZSI6IkF1dG9jb21wbGV0ZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBQdXJlQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnXG5pbXBvcnQgZnV6emFsZHJpbiBmcm9tICdmdXp6YWxkcmluLXBsdXMnXG5pbXBvcnQgRG93bnNoaWZ0IGZyb20gJ2Rvd25zaGlmdCdcbmltcG9ydCBWaXJ0dWFsTGlzdCBmcm9tICdyZWFjdC10aW55LXZpcnR1YWwtbGlzdCdcbmltcG9ydCB7IFBvcG92ZXIgfSBmcm9tICcuLi8uLi9wb3BvdmVyJ1xuaW1wb3J0IHsgUG9zaXRpb24gfSBmcm9tICcuLi8uLi9wb3NpdGlvbmVyJ1xuaW1wb3J0IHsgVGV4dCB9IGZyb20gJy4uLy4uL3R5cG9ncmFwaHknXG5pbXBvcnQgeyBQYW5lIH0gZnJvbSAnLi4vLi4vbGF5ZXJzJ1xuaW1wb3J0IEF1dG9jb21wbGV0ZUl0ZW0gZnJvbSAnLi9BdXRvY29tcGxldGVJdGVtJ1xuXG5jb25zdCBmdXp6eUZpbHRlciA9IChpdGVtcywgaW5wdXQpID0+IGZ1enphbGRyaW4uZmlsdGVyKGl0ZW1zLCBpbnB1dClcblxuY29uc3QgYXV0b2NvbXBsZXRlSXRlbVJlbmRlcmVyID0gcHJvcHMgPT4gPEF1dG9jb21wbGV0ZUl0ZW0gey4uLnByb3BzfSAvPlxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vcGF5cGFsL2Rvd25zaGlmdC9pc3N1ZXMvMTY0XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdXRvY29tcGxldGUgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAvKipcbiAgICAgKiBUaGlzIHByb3AgY2FuIGJlIGVpdGhlciBhIHN0cmluZyBvciBhIE5vZGUuXG4gICAgICogSXQgd2lsbCBwcm92aWRlIGEgdGl0bGUgZm9yIHRoZSBpdGVtc1xuICAgICAqL1xuICAgIHRpdGxlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMubm9kZV0pLFxuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgaXRlbXMgdG8gYmUgdXNlZCBhcyBvcHRpb25zIGZvciB0aGUgc2VsZWN0XG4gICAgICovXG4gICAgaXRlbXM6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbGVjdGVkIEl0ZW0gdG8gYmUgc2hvd24gb24gdGhlIGF1dG9jb21wbGV0ZVxuICAgICAqL1xuICAgIHNlbGVjdGVkSXRlbTogUHJvcFR5cGVzLmFueSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzZWxlY3RlZCBpdGVtIHRvIGJlIHNlbGVjdGVkICYgc2hvd24gYnkgZGVmYXVsdCBvbiB0aGUgYXV0b2NvbXBsZXRlXG4gICAgICovXG4gICAgZGVmYXVsdFNlbGVjdGVkSXRlbTogUHJvcFR5cGVzLmFueSxcblxuICAgIC8qKlxuICAgICAqIEluIGNhc2UgdGhlIGFycmF5IG9mIGl0ZW1zIGlzIG5vdCBhbiBhcnJheSBvZiBzdHJpbmdzLFxuICAgICAqIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCBvbiBlYWNoIGl0ZW0gdG8gcmV0dXJuIHRoZSBzdHJpbmcgdGhhdCB3aWxsIGJlIHNob3duIG9uIHRoZSBmaWx0ZXJcbiAgICAgKi9cbiAgICBpdGVtVG9TdHJpbmc6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0aGF0IHdpbGwgcmVuZGVyIHRoZSAnZmlsdGVyJyBjb21wb25lbnQuXG4gICAgICovXG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIGVhY2ggaXRlbSBpbiB0aGUgbGlzdFxuICAgICAqIEJlY2F1c2UgdGhlIGxpc3QgaXMgdmlydHVhbGl6ZWQgdGhpcyBpcyByZXF1aXJlZCBiZWZvcmVoYW5kLlxuICAgICAqL1xuICAgIGl0ZW1TaXplOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgY29tcG9uZW50IHRvIHJlbmRlciB0aGUgaXRlbVxuICAgICAqL1xuICAgIHJlbmRlckl0ZW06IFByb3BUeXBlcy5mdW5jLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHBvc2l0aW9uIG9mIHRoZSBQb3BvdmVyIHRoZSBBdXRvY29tcGxldGUgaXMgcmVuZGVyZWQgaW4uXG4gICAgICovXG4gICAgcG9zaXRpb246IFByb3BUeXBlcy5vbmVPZihPYmplY3Qua2V5cyhQb3NpdGlvbikpLFxuXG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IGlzIHVzZWQgdG8gZmlsdGVyIHRoZSBpdGVtcy5cbiAgICAgKiBJdCBzaG91bGQgcmV0dXJuIGEgc3Vic2V0IG9mIHRoZSBpbml0aWFsIGl0ZW1zLlxuICAgICAqIEJ5IGRlZmF1bHQgdGhlIFwiZnV6emFsZHJpbi1wbHVzXCIgcGFja2FnZSBpcyB1c2VkLlxuICAgICAqL1xuICAgIGl0ZW1zRmlsdGVyOiBQcm9wVHlwZXMuZnVuYyxcblxuICAgIC8qKlxuICAgICAqIFByb3AgdGhhdCBlbmFibGVzIGFuZCBkaXNhYmxlcyBmaWx0ZXJpbmdcbiAgICAgKiBUcnVlOiBFbmFibGVzIEZpbHRlcmluZ1xuICAgICAqIEZhbHNlOiBEaXNhYmxlcyBGaWx0ZXJpbmdcbiAgICAgKi9cbiAgICBpc0ZpbHRlckRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGhlIG1pbmltdW0gaGVpZ2h0IHRoZSByZXN1bHRzIGNvbnRhaW5lciB3aWxsIGJlXG4gICAgICovXG4gICAgcG9wb3Zlck1pbldpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB0aGUgbWF4aW11bSBoZWlnaHQgdGhlIHJlc3VsdHMgY29udGFpbmVyIHdpbGwgYmVcbiAgICAgKi9cbiAgICBwb3BvdmVyTWF4SGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gICAgLi4uRG93bnNoaWZ0LnByb3BUeXBlc1xuICB9XG5cbiAgc3RhdGUgPSB7XG4gICAgdGFyZ2V0V2lkdGg6IDBcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgaXRlbVRvU3RyaW5nOiBpID0+IChpID8gU3RyaW5nKGkpIDogJycpLFxuICAgIGl0ZW1TaXplOiAzMixcbiAgICBpdGVtc0ZpbHRlcjogZnV6enlGaWx0ZXIsXG4gICAgaXNGaWx0ZXJEaXNhYmxlZDogZmFsc2UsXG4gICAgcG9wb3Zlck1pbldpZHRoOiAyNDAsXG4gICAgcG9wb3Zlck1heEhlaWdodDogMjQwLFxuICAgIHJlbmRlckl0ZW06IGF1dG9jb21wbGV0ZUl0ZW1SZW5kZXJlclxuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICB0YXJnZXRXaWR0aDogdGhpcy50YXJnZXRSZWYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGhcbiAgICB9KVxuICB9XG5cbiAgcmVuZGVyUmVzdWx0cyA9ICh7XG4gICAgd2lkdGgsXG4gICAgaW5wdXRWYWx1ZSxcbiAgICBoaWdobGlnaHRlZEluZGV4LFxuICAgIHNlbGVjdEl0ZW1BdEluZGV4LFxuICAgIHNlbGVjdGVkSXRlbSxcbiAgICBnZXRJdGVtUHJvcHNcbiAgfSkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHRpdGxlLFxuICAgICAgaXRlbVNpemUsXG4gICAgICBpdGVtc0ZpbHRlcixcbiAgICAgIGl0ZW1zOiBvcmlnaW5hbEl0ZW1zLFxuICAgICAgaXRlbVRvU3RyaW5nLFxuICAgICAgcmVuZGVySXRlbSxcbiAgICAgIHBvcG92ZXJNYXhIZWlnaHQsXG4gICAgICBpc0ZpbHRlckRpc2FibGVkXG4gICAgfSA9IHRoaXMucHJvcHNcblxuICAgIGNvbnN0IGl0ZW1zID1cbiAgICAgIGlzRmlsdGVyRGlzYWJsZWQgfHwgaW5wdXRWYWx1ZS50cmltKCkgPT09ICcnXG4gICAgICAgID8gb3JpZ2luYWxJdGVtc1xuICAgICAgICA6IGl0ZW1zRmlsdGVyKG9yaWdpbmFsSXRlbXMsIGlucHV0VmFsdWUpXG5cbiAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbFxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxQYW5lIHdpZHRoPXt3aWR0aH0+XG4gICAgICAgIHt0aXRsZSAmJiAoXG4gICAgICAgICAgPFBhbmUgcGFkZGluZz17OH0gYm9yZGVyQm90dG9tPVwiZXh0cmFNdXRlZFwiPlxuICAgICAgICAgICAgPFRleHQgc2l6ZT17MjAwfSBjb2xvcj1cIm11dGVkXCIgaXNVcHBlcmNhc2U+XG4gICAgICAgICAgICAgIHt0aXRsZX1cbiAgICAgICAgICAgIDwvVGV4dD5cbiAgICAgICAgICA8L1BhbmU+XG4gICAgICAgICl9XG4gICAgICAgIHtpdGVtcy5sZW5ndGggPiAwICYmIChcbiAgICAgICAgICA8VmlydHVhbExpc3RcbiAgICAgICAgICAgIHdpZHRoPVwiMTAwJVwiXG4gICAgICAgICAgICBoZWlnaHQ9e01hdGgubWluKGl0ZW1zLmxlbmd0aCAqIGl0ZW1TaXplLCBwb3BvdmVyTWF4SGVpZ2h0KX1cbiAgICAgICAgICAgIGl0ZW1TaXplPXtpdGVtU2l6ZX1cbiAgICAgICAgICAgIGl0ZW1Db3VudD17aXRlbXMubGVuZ3RofVxuICAgICAgICAgICAgc2Nyb2xsVG9JbmRleD17aGlnaGxpZ2h0ZWRJbmRleCB8fCAwfVxuICAgICAgICAgICAgb3ZlcnNjYW5Db3VudD17M31cbiAgICAgICAgICAgIHNjcm9sbFRvQWxpZ25tZW50PVwiYXV0b1wiXG4gICAgICAgICAgICByZW5kZXJJdGVtPXsoeyBpbmRleCwgc3R5bGUgfSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaW5kZXhdXG4gICAgICAgICAgICAgIGNvbnN0IGl0ZW1TdHJpbmcgPSBpdGVtVG9TdHJpbmcoaXRlbSlcbiAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlckl0ZW0oXG4gICAgICAgICAgICAgICAgZ2V0SXRlbVByb3BzKHtcbiAgICAgICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgICAgICBrZXk6IGl0ZW1TdHJpbmcsXG4gICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgIHN0eWxlLFxuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IGl0ZW1TdHJpbmcsXG4gICAgICAgICAgICAgICAgICBvbk1vdXNlVXA6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0SXRlbUF0SW5kZXgoaW5kZXgpXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgaXNTZWxlY3RlZDogaXRlbVRvU3RyaW5nKHNlbGVjdGVkSXRlbSkgPT09IGl0ZW1TdHJpbmcsXG4gICAgICAgICAgICAgICAgICBpc0hpZ2hsaWdodGVkOiBoaWdobGlnaHRlZEluZGV4ID09PSBpbmRleFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgLz5cbiAgICAgICAgKX1cbiAgICAgIDwvUGFuZT5cbiAgICApXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY2hpbGRyZW4sXG4gICAgICBpdGVtU2l6ZSxcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgcmVuZGVySXRlbSxcbiAgICAgIGl0ZW1zRmlsdGVyLFxuICAgICAgcG9wb3Zlck1heEhlaWdodCxcbiAgICAgIHBvcG92ZXJNaW5XaWR0aCxcbiAgICAgIGRlZmF1bHRTZWxlY3RlZEl0ZW0sXG4gICAgICAuLi5wcm9wc1xuICAgIH0gPSB0aGlzLnByb3BzXG5cbiAgICByZXR1cm4gKFxuICAgICAgPERvd25zaGlmdCBkZWZhdWx0U2VsZWN0ZWRJdGVtPXtkZWZhdWx0U2VsZWN0ZWRJdGVtfSB7Li4ucHJvcHN9PlxuICAgICAgICB7KHtcbiAgICAgICAgICBpc09wZW46IGlzU2hvd24sXG4gICAgICAgICAgaW5wdXRWYWx1ZSxcbiAgICAgICAgICBnZXRJdGVtUHJvcHMsXG4gICAgICAgICAgc2VsZWN0ZWRJdGVtLFxuICAgICAgICAgIGhpZ2hsaWdodGVkSW5kZXgsXG4gICAgICAgICAgc2VsZWN0SXRlbUF0SW5kZXgsXG4gICAgICAgICAgLi4ucmVzdERvd25zaGlmdFByb3BzXG4gICAgICAgIH0pID0+IChcbiAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgPFBvcG92ZXJcbiAgICAgICAgICAgICAgYnJpbmdGb2N1c0luc2lkZT17ZmFsc2V9XG4gICAgICAgICAgICAgIGlzU2hvd249e2lzU2hvd259XG4gICAgICAgICAgICAgIG1pbldpZHRoPXtwb3BvdmVyTWluV2lkdGh9XG4gICAgICAgICAgICAgIHBvc2l0aW9uPXtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiB8fFxuICAgICAgICAgICAgICAgICh0aGlzLnN0YXRlLnRhcmdldFdpZHRoIDwgcG9wb3Zlck1pbldpZHRoXG4gICAgICAgICAgICAgICAgICA/IFBvc2l0aW9uLkJPVFRPTV9MRUZUXG4gICAgICAgICAgICAgICAgICA6IFBvc2l0aW9uLkJPVFRPTSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250ZW50PXsoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyUmVzdWx0cyh7XG4gICAgICAgICAgICAgICAgICB3aWR0aDogTWF0aC5tYXgodGhpcy5zdGF0ZS50YXJnZXRXaWR0aCwgcG9wb3Zlck1pbldpZHRoKSxcbiAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUsXG4gICAgICAgICAgICAgICAgICBnZXRJdGVtUHJvcHMsXG4gICAgICAgICAgICAgICAgICBzZWxlY3RlZEl0ZW0sXG4gICAgICAgICAgICAgICAgICBoaWdobGlnaHRlZEluZGV4LFxuICAgICAgICAgICAgICAgICAgc2VsZWN0SXRlbUF0SW5kZXhcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICBtaW5IZWlnaHQ9ezB9XG4gICAgICAgICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uPXswfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICB7KHsgaXNTaG93bjogaXNTaG93blBvcG92ZXIsIHRvZ2dsZSwgZ2V0UmVmIH0pID0+XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4oe1xuICAgICAgICAgICAgICAgICAgaXNTaG93bjogaXNTaG93blBvcG92ZXIsXG4gICAgICAgICAgICAgICAgICB0b2dnbGUsXG4gICAgICAgICAgICAgICAgICBnZXRSZWY6IHJlZiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgcmVmIGludGVybmFsbHkgdG8gZGV0ZXJtaW5lIHRoZSB3aWR0aFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldFJlZiA9IHJlZlxuICAgICAgICAgICAgICAgICAgICBnZXRSZWYocmVmKVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUsXG4gICAgICAgICAgICAgICAgICBzZWxlY3RlZEl0ZW0sXG4gICAgICAgICAgICAgICAgICBoaWdobGlnaHRlZEluZGV4LFxuICAgICAgICAgICAgICAgICAgc2VsZWN0SXRlbUF0SW5kZXgsXG4gICAgICAgICAgICAgICAgICAuLi5yZXN0RG93bnNoaWZ0UHJvcHNcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA8L1BvcG92ZXI+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG4gICAgICA8L0Rvd25zaGlmdD5cbiAgICApXG4gIH1cbn1cbiJdfQ==