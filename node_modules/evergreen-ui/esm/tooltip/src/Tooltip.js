var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import debounce from 'lodash.debounce';
import { Position, Positioner } from '../../positioner';
import TooltipStateless from './TooltipStateless';

var idCounter = 0;

var Tooltip = function (_PureComponent) {
  _inherits(Tooltip, _PureComponent);

  function Tooltip(props, context) {
    _classCallCheck(this, Tooltip);

    var _this = _possibleConstructorReturn(this, (Tooltip.__proto__ || Object.getPrototypeOf(Tooltip)).call(this, props, context));

    _this.show = function () {
      if (_this.state.isShown) return;
      _this.setState({
        isShown: true
      });
    };

    _this.hide = function () {
      if (!_this.state.isShown) return;
      _this.setState({
        isShown: false
      });
    };

    _this.renderTarget = function (_ref) {
      var getRef = _ref.getRef;
      var children = _this.props.children;


      return React.cloneElement(children, {
        onMouseEnter: _this.show,
        onMouseLeave: _this.hide,
        'aria-describedby': _this.state.id,
        innerRef: function innerRef(ref) {
          getRef(ref);
        }
      });
    };

    _this.handleMouseEnterTarget = function () {
      _this.setState({
        isShownByTarget: true
      });
    };

    _this.handleMouseLeaveTarget = function () {
      _this.setState({
        isShownByTarget: false
      });
    };

    _this.state = {
      id: 'evergreen-tooltip-' + ++idCounter,
      isShown: props.isShown,
      isShownByTarget: false
    };

    _this.handleMouseLeaveTarget = debounce(_this.handleMouseLeaveTarget, _this.props.hideDelay);

    _this.hide = debounce(_this.hide, _this.props.hideDelay);
    return _this;
  }

  _createClass(Tooltip, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          isShown = _props.isShown,
          zIndex = _props.zIndex,
          content = _props.content,
          position = _props.position,
          statelessProps = _props.statelessProps;
      var _state = this.state,
          stateIsShown = _state.isShown,
          isShownByTarget = _state.isShownByTarget;


      var shown = isShown || stateIsShown || isShownByTarget;

      return React.createElement(
        Positioner,
        {
          target: function target(_ref2) {
            var getRef = _ref2.getRef;

            return _this2.renderTarget({ getRef: getRef });
          },
          zIndex: zIndex,
          isShown: shown,
          position: position,
          animationDuration: 160
        },
        function (_ref3) {
          var css = _ref3.css,
              style = _ref3.style,
              state = _ref3.state,
              getRef = _ref3.getRef;
          return React.createElement(
            TooltipStateless,
            _extends({
              id: _this2.state.id,
              innerRef: function innerRef(ref) {
                return getRef(ref);
              },
              'data-state': state,
              css: css,
              style: style,
              onMouseEnter: _this2.handleMouseEnterTarget,
              onMouseLeave: _this2.handleMouseLeaveTarget
            }, statelessProps),
            content
          );
        }
      );
    }
  }]);

  return Tooltip;
}(PureComponent);

Tooltip.propTypes = {
  /**
   * The position the Popover is on.
   */
  position: PropTypes.oneOf(Object.keys(Position)),

  /**
   * The content of the Popover.
   */
  content: PropTypes.node.isRequired,

  /**
   * Time in ms before hiding the Tooltip.
   */
  hideDelay: PropTypes.number.isRequired,

  /**
   * When True, manually show the Tooltip.
   */
  isShown: PropTypes.bool,

  /**
   * The target button of the Tooltip.
   */
  children: PropTypes.node.isRequried,

  /**
   * Properties passed through to the Tooltip.
   */
  statelessProps: PropTypes.object,

  /**
   * The z-index of the Tooltip.
   */
  zIndex: PropTypes.number.isRequired
};
Tooltip.defaultProps = {
  position: Position.BOTTOM,
  zIndex: 40,
  hideDelay: 120
};
export default Tooltip;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy90b29sdGlwL3NyYy9Ub29sdGlwLmpzIl0sIm5hbWVzIjpbIlJlYWN0IiwiUHVyZUNvbXBvbmVudCIsIlByb3BUeXBlcyIsImRlYm91bmNlIiwiUG9zaXRpb24iLCJQb3NpdGlvbmVyIiwiVG9vbHRpcFN0YXRlbGVzcyIsImlkQ291bnRlciIsIlRvb2x0aXAiLCJwcm9wcyIsImNvbnRleHQiLCJzaG93Iiwic3RhdGUiLCJpc1Nob3duIiwic2V0U3RhdGUiLCJoaWRlIiwicmVuZGVyVGFyZ2V0IiwiZ2V0UmVmIiwiY2hpbGRyZW4iLCJjbG9uZUVsZW1lbnQiLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlTGVhdmUiLCJpZCIsImlubmVyUmVmIiwicmVmIiwiaGFuZGxlTW91c2VFbnRlclRhcmdldCIsImlzU2hvd25CeVRhcmdldCIsImhhbmRsZU1vdXNlTGVhdmVUYXJnZXQiLCJoaWRlRGVsYXkiLCJ6SW5kZXgiLCJjb250ZW50IiwicG9zaXRpb24iLCJzdGF0ZWxlc3NQcm9wcyIsInN0YXRlSXNTaG93biIsInNob3duIiwiY3NzIiwic3R5bGUiLCJwcm9wVHlwZXMiLCJvbmVPZiIsIk9iamVjdCIsImtleXMiLCJub2RlIiwiaXNSZXF1aXJlZCIsIm51bWJlciIsImJvb2wiLCJpc1JlcXVyaWVkIiwib2JqZWN0IiwiZGVmYXVsdFByb3BzIiwiQk9UVE9NIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsT0FBT0EsS0FBUCxJQUFnQkMsYUFBaEIsUUFBcUMsT0FBckM7QUFDQSxPQUFPQyxTQUFQLE1BQXNCLFlBQXRCO0FBQ0EsT0FBT0MsUUFBUCxNQUFxQixpQkFBckI7QUFDQSxTQUFTQyxRQUFULEVBQW1CQyxVQUFuQixRQUFxQyxrQkFBckM7QUFDQSxPQUFPQyxnQkFBUCxNQUE2QixvQkFBN0I7O0FBRUEsSUFBSUMsWUFBWSxDQUFoQjs7SUFFcUJDLE87OztBQTRDbkIsbUJBQVlDLEtBQVosRUFBbUJDLE9BQW5CLEVBQTRCO0FBQUE7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QUFZWixLQUhkO0FBSUUsbUJBQUt1QixHQUpQO0FBS0UscUJBQU9DLEtBTFQ7QUFNRSw0QkFBYyxPQUFLWCxzQkFOckI7QUFPRSw0QkFBYyxPQUFLRTtBQVByQixlQVFNSyxjQVJOO0FBVUdGO0FBVkgsV0FERDtBQUFBO0FBVEgsT0FERjtBQTBCRDs7OztFQXBJa0M3QixhOztBQUFoQk8sTyxDQUNaNkIsUyxHQUFZO0FBQ2pCOzs7QUFHQU4sWUFBVTdCLFVBQVVvQyxLQUFWLENBQWdCQyxPQUFPQyxJQUFQLENBQVlwQyxRQUFaLENBQWhCLENBSk87O0FBTWpCOzs7QUFHQTBCLFdBQVM1QixVQUFVdUMsSUFBVixDQUFlQyxVQVRQOztBQVdqQjs7O0FBR0FkLGFBQVcxQixVQUFVeUMsTUFBVixDQUFpQkQsVUFkWDs7QUFnQmpCOzs7QUFHQTdCLFdBQVNYLFVBQVUwQyxJQW5CRjs7QUFxQmpCOzs7QUFHQTFCLFlBQVVoQixVQUFVdUMsSUFBVixDQUFlSSxVQXhCUjs7QUEwQmpCOzs7QUFHQWIsa0JBQWdCOUIsVUFBVTRDLE1BN0JUOztBQStCakI7OztBQUdBakIsVUFBUTNCLFVBQVV5QyxNQUFWLENBQWlCRDtBQWxDUixDO0FBREFsQyxPLENBc0NadUMsWSxHQUFlO0FBQ3BCaEIsWUFBVTNCLFNBQVM0QyxNQURDO0FBRXBCbkIsVUFBUSxFQUZZO0FBR3BCRCxhQUFXO0FBSFMsQztlQXRDSHBCLE8iLCJmaWxlIjoiVG9vbHRpcC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBQdXJlQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnXG5pbXBvcnQgZGVib3VuY2UgZnJvbSAnbG9kYXNoLmRlYm91bmNlJ1xuaW1wb3J0IHsgUG9zaXRpb24sIFBvc2l0aW9uZXIgfSBmcm9tICcuLi8uLi9wb3NpdGlvbmVyJ1xuaW1wb3J0IFRvb2x0aXBTdGF0ZWxlc3MgZnJvbSAnLi9Ub29sdGlwU3RhdGVsZXNzJ1xuXG5sZXQgaWRDb3VudGVyID0gMFxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb29sdGlwIGV4dGVuZHMgUHVyZUNvbXBvbmVudCB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgLyoqXG4gICAgICogVGhlIHBvc2l0aW9uIHRoZSBQb3BvdmVyIGlzIG9uLlxuICAgICAqL1xuICAgIHBvc2l0aW9uOiBQcm9wVHlwZXMub25lT2YoT2JqZWN0LmtleXMoUG9zaXRpb24pKSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb250ZW50IG9mIHRoZSBQb3BvdmVyLlxuICAgICAqL1xuICAgIGNvbnRlbnQ6IFByb3BUeXBlcy5ub2RlLmlzUmVxdWlyZWQsXG5cbiAgICAvKipcbiAgICAgKiBUaW1lIGluIG1zIGJlZm9yZSBoaWRpbmcgdGhlIFRvb2x0aXAuXG4gICAgICovXG4gICAgaGlkZURlbGF5OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIFRydWUsIG1hbnVhbGx5IHNob3cgdGhlIFRvb2x0aXAuXG4gICAgICovXG4gICAgaXNTaG93bjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGFyZ2V0IGJ1dHRvbiBvZiB0aGUgVG9vbHRpcC5cbiAgICAgKi9cbiAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUuaXNSZXF1cmllZCxcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgcGFzc2VkIHRocm91Z2ggdG8gdGhlIFRvb2x0aXAuXG4gICAgICovXG4gICAgc3RhdGVsZXNzUHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgei1pbmRleCBvZiB0aGUgVG9vbHRpcC5cbiAgICAgKi9cbiAgICB6SW5kZXg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBwb3NpdGlvbjogUG9zaXRpb24uQk9UVE9NLFxuICAgIHpJbmRleDogNDAsXG4gICAgaGlkZURlbGF5OiAxMjBcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KSB7XG4gICAgc3VwZXIocHJvcHMsIGNvbnRleHQpXG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgaWQ6IGBldmVyZ3JlZW4tdG9vbHRpcC0keysraWRDb3VudGVyfWAsXG4gICAgICBpc1Nob3duOiBwcm9wcy5pc1Nob3duLFxuICAgICAgaXNTaG93bkJ5VGFyZ2V0OiBmYWxzZVxuICAgIH1cblxuICAgIHRoaXMuaGFuZGxlTW91c2VMZWF2ZVRhcmdldCA9IGRlYm91bmNlKFxuICAgICAgdGhpcy5oYW5kbGVNb3VzZUxlYXZlVGFyZ2V0LFxuICAgICAgdGhpcy5wcm9wcy5oaWRlRGVsYXlcbiAgICApXG5cbiAgICB0aGlzLmhpZGUgPSBkZWJvdW5jZSh0aGlzLmhpZGUsIHRoaXMucHJvcHMuaGlkZURlbGF5KVxuICB9XG5cbiAgc2hvdyA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5zdGF0ZS5pc1Nob3duKSByZXR1cm5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGlzU2hvd246IHRydWVcbiAgICB9KVxuICB9XG5cbiAgaGlkZSA9ICgpID0+IHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuaXNTaG93bikgcmV0dXJuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBpc1Nob3duOiBmYWxzZVxuICAgIH0pXG4gIH1cblxuICByZW5kZXJUYXJnZXQgPSAoeyBnZXRSZWYgfSkgPT4ge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHRoaXMucHJvcHNcblxuICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGRyZW4sIHtcbiAgICAgIG9uTW91c2VFbnRlcjogdGhpcy5zaG93LFxuICAgICAgb25Nb3VzZUxlYXZlOiB0aGlzLmhpZGUsXG4gICAgICAnYXJpYS1kZXNjcmliZWRieSc6IHRoaXMuc3RhdGUuaWQsXG4gICAgICBpbm5lclJlZjogcmVmID0+IHtcbiAgICAgICAgZ2V0UmVmKHJlZilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgaGFuZGxlTW91c2VFbnRlclRhcmdldCA9ICgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGlzU2hvd25CeVRhcmdldDogdHJ1ZVxuICAgIH0pXG4gIH1cblxuICBoYW5kbGVNb3VzZUxlYXZlVGFyZ2V0ID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgaXNTaG93bkJ5VGFyZ2V0OiBmYWxzZVxuICAgIH0pXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBpc1Nob3duLCB6SW5kZXgsIGNvbnRlbnQsIHBvc2l0aW9uLCBzdGF0ZWxlc3NQcm9wcyB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IHsgaXNTaG93bjogc3RhdGVJc1Nob3duLCBpc1Nob3duQnlUYXJnZXQgfSA9IHRoaXMuc3RhdGVcblxuICAgIGNvbnN0IHNob3duID0gaXNTaG93biB8fCBzdGF0ZUlzU2hvd24gfHwgaXNTaG93bkJ5VGFyZ2V0XG5cbiAgICByZXR1cm4gKFxuICAgICAgPFBvc2l0aW9uZXJcbiAgICAgICAgdGFyZ2V0PXsoeyBnZXRSZWYgfSkgPT4ge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlclRhcmdldCh7IGdldFJlZiB9KVxuICAgICAgICB9fVxuICAgICAgICB6SW5kZXg9e3pJbmRleH1cbiAgICAgICAgaXNTaG93bj17c2hvd259XG4gICAgICAgIHBvc2l0aW9uPXtwb3NpdGlvbn1cbiAgICAgICAgYW5pbWF0aW9uRHVyYXRpb249ezE2MH1cbiAgICAgID5cbiAgICAgICAgeyh7IGNzcywgc3R5bGUsIHN0YXRlLCBnZXRSZWYgfSkgPT4gKFxuICAgICAgICAgIDxUb29sdGlwU3RhdGVsZXNzXG4gICAgICAgICAgICBpZD17dGhpcy5zdGF0ZS5pZH1cbiAgICAgICAgICAgIGlubmVyUmVmPXtyZWYgPT4gZ2V0UmVmKHJlZil9XG4gICAgICAgICAgICBkYXRhLXN0YXRlPXtzdGF0ZX1cbiAgICAgICAgICAgIGNzcz17Y3NzfVxuICAgICAgICAgICAgc3R5bGU9e3N0eWxlfVxuICAgICAgICAgICAgb25Nb3VzZUVudGVyPXt0aGlzLmhhbmRsZU1vdXNlRW50ZXJUYXJnZXR9XG4gICAgICAgICAgICBvbk1vdXNlTGVhdmU9e3RoaXMuaGFuZGxlTW91c2VMZWF2ZVRhcmdldH1cbiAgICAgICAgICAgIHsuLi5zdGF0ZWxlc3NQcm9wc31cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7Y29udGVudH1cbiAgICAgICAgICA8L1Rvb2x0aXBTdGF0ZWxlc3M+XG4gICAgICAgICl9XG4gICAgICA8L1Bvc2l0aW9uZXI+XG4gICAgKVxuICB9XG59XG4iXX0=