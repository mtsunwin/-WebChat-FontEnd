var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import fuzzaldrin from 'fuzzaldrin-plus';
import VirtualList from 'react-tiny-virtual-list';
import { Pane } from '../../layers';
import { TableHead, SearchTableHeaderCell } from '../../table';
import OptionShapePropType from './OptionShapePropType';
import Option from './Option';

/**
 * Fuzzaldrin-plus is the default filter, but you can use your own
 * as long as they follow the following signature:
 * @param options <Array[String]> - ['label', 'label2', ...]
 * @param input <String>
 */
var fuzzyFilter = function fuzzyFilter(options, input) {
  return fuzzaldrin.filter(options, input);
};

/**
 * This is the default item renderer of options
 * you can pass custom renderers as long as they work the same as the Option
 */
var itemRenderer = function itemRenderer(props) {
  return React.createElement(Option, props);
};

var OptionsList = function (_PureComponent) {
  _inherits(OptionsList, _PureComponent);

  function OptionsList(props, context) {
    _classCallCheck(this, OptionsList);

    var _this = _possibleConstructorReturn(this, (OptionsList.__proto__ || Object.getPrototypeOf(OptionsList)).call(this, props, context));

    _this.isSelected = function (item) {
      var selected = _this.state.selected;


      return Boolean(selected.find(function (selectedItem) {
        return selectedItem === item.value;
      }));
    };

    _this.search = function (options) {
      var optionsFilter = _this.props.optionsFilter;
      var searchValue = _this.state.searchValue;


      return searchValue.trim() === '' ? options // Return if no search query
      : optionsFilter(options.map(function (item) {
        return item.labelInList || item.label;
      }), searchValue).map(function (name) {
        return options.find(function (item) {
          return item.labelInList === name || item.label === name;
        });
      });
    };

    _this.handleKeyUp = function (e) {
      if (e.keyCode === 38) {
        _this.handleArrowUp();
      }

      if (e.keyCode === 40) {
        _this.handleArrowDown();
      }

      if (e.keyCode === 13) {
        _this.handleEnter();
      }
    };

    _this.handleChange = function (searchValue) {
      _this.setState({
        searchValue: searchValue
      });
    };

    _this.handleSelect = function (item) {
      _this.props.onSelect(item);
    };

    _this.handleDeselect = function (item) {
      _this.props.onDeselect(item);
    };

    _this.assignSearchRef = function (ref) {
      _this.searchRef = ref;
    };

    _this.state = {
      searchValue: props.defaultSearchValue,
      selected: props.selected
    };
    return _this;
  }

  _createClass(OptionsList, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      var hasFilter = this.props.hasFilter;

      if (!hasFilter) return;
      /**
       * Hacky solution for broken autoFocus
       * https://github.com/segmentio/evergreen/issues/90
       */
      window.setTimeout(function () {
        _this2.searchRef.querySelector('input').focus();
      }, 1);
      window.addEventListener('keyup', this.handleKeyUp);
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.selected !== this.state.selected) {
        this.setState({
          selected: nextProps.selected
        });
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      window.removeEventListener('keyup', this.handleKeyUp);
    }
  }, {
    key: 'getCurrentIndex',
    value: function getCurrentIndex() {
      var selected = this.props.selected;

      var options = this.getFilteredOptions();

      return options.findIndex(function (option) {
        return option.value === selected[selected.length - 1];
      });
    }
  }, {
    key: 'getFilteredOptions',
    value: function getFilteredOptions() {
      var options = this.props.options;


      return this.search(options);
    }
  }, {
    key: 'handleArrowUp',
    value: function handleArrowUp() {
      var onSelect = this.props.onSelect;

      var options = this.getFilteredOptions();

      var nextIndex = this.getCurrentIndex() - 1;

      if (nextIndex < 0) {
        nextIndex = options.length - 1;
      }

      onSelect(options[nextIndex]);
    }
  }, {
    key: 'handleArrowDown',
    value: function handleArrowDown() {
      var onSelect = this.props.onSelect;

      var options = this.getFilteredOptions();

      var nextIndex = this.getCurrentIndex() + 1;

      if (nextIndex === options.length) {
        nextIndex = 0;
      }

      onSelect(options[nextIndex]);
    }
  }, {
    key: 'handleEnter',
    value: function handleEnter() {
      var isSelected = this.getCurrentIndex() !== -1;

      if (isSelected) {
        this.props.close();
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      var _props = this.props,
          close = _props.close,
          width = _props.width,
          height = _props.height,
          onSelect = _props.onSelect,
          onDeselect = _props.onDeselect,
          selected = _props.selected,
          hasFilter = _props.hasFilter,
          optionSize = _props.optionSize,
          _renderItem = _props.renderItem,
          placeholder = _props.placeholder,
          optionsFilter = _props.optionsFilter,
          defaultSearchValue = _props.defaultSearchValue,
          props = _objectWithoutProperties(_props, ['close', 'width', 'height', 'onSelect', 'onDeselect', 'selected', 'hasFilter', 'optionSize', 'renderItem', 'placeholder', 'optionsFilter', 'defaultSearchValue']);

      var options = this.getFilteredOptions();
      var listHeight = height - (hasFilter ? 32 : 0);

      return React.createElement(
        Pane,
        _extends({
          height: height,
          width: width,
          display: 'flex',
          flexDirection: 'column'
        }, props),
        hasFilter && React.createElement(
          TableHead,
          null,
          React.createElement(SearchTableHeaderCell, {
            onChange: this.handleChange,
            innerRef: this.assignSearchRef,
            borderRight: null,
            height: 32
          })
        ),
        React.createElement(
          Pane,
          { flex: 1 },
          React.createElement(VirtualList, {
            height: listHeight,
            width: '100%',
            itemSize: optionSize,
            itemCount: options.length,
            overscanCount: 3,
            scrollToAlignment: 'auto',
            renderItem: function renderItem(_ref) {
              var index = _ref.index,
                  style = _ref.style;

              var item = options[index];
              return _renderItem({
                key: item.value,
                label: item.label,
                style: style,
                height: optionSize,
                onSelect: function onSelect() {
                  return _this3.handleSelect(item);
                },
                onDeselect: function onDeselect() {
                  return _this3.handleDeselect(item);
                },
                isSelected: _this3.isSelected(item)
              });
            }
          })
        )
      );
    }
  }]);

  return OptionsList;
}(PureComponent);

OptionsList.propTypes = {
  options: PropTypes.arrayOf(OptionShapePropType),
  close: PropTypes.func,
  height: PropTypes.number,
  width: PropTypes.number,

  /**
   * This holds the values of the options
   */
  selected: PropTypes.arrayOf(PropTypes.string),
  onSelect: PropTypes.func,
  onDeselect: PropTypes.func,
  hasFilter: PropTypes.bool,
  optionSize: PropTypes.number,
  renderItem: PropTypes.func,
  placeholder: PropTypes.string,
  optionsFilter: PropTypes.func,
  defaultSearchValue: PropTypes.string
};
OptionsList.defaultProps = {
  options: [],
  /**
   * Including border bottom
   * For some reason passing height to TableRow doesn't work
   * TODO: fix hacky solution
   */
  optionSize: 33,
  onSelect: function onSelect() {},
  onDeselect: function onDeselect() {},
  selected: [],
  renderItem: itemRenderer,
  optionsFilter: fuzzyFilter,
  placeholder: 'Filter...',
  defaultSearchValue: ''
};
export default OptionsList;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zZWxlY3QtbWVudS9zcmMvT3B0aW9uc0xpc3QuanMiXSwibmFtZXMiOlsiUmVhY3QiLCJQdXJlQ29tcG9uZW50IiwiUHJvcFR5cGVzIiwiZnV6emFsZHJpbiIsIlZpcnR1YWxMaXN0IiwiUGFuZSIsIlRhYmxlSGVhZCIsIlNlYXJjaFRhYmxlSGVhZGVyQ2VsbCIsIk9wdGlvblNoYXBlUHJvcFR5cGUiLCJPcHRpb24iLCJmdXp6eUZpbHRlciIsIm9wdGlvbnMiLCJpbnB1dCIsImZpbHRlciIsIml0ZW1SZW5kZXJlciIsInByb3BzIiwiT3B0aW9uc0xpc3QiLCJjb250ZXh0IiwiaXNTZWxlY3RlZCIsInNlbGVjdGVkIiwic3RhdGUiLCJCb29sZWFuIiwiZmluZCIsInNlbGVjdGVkSXRlbSIsIml0ZW0iLCJ2YWx1ZSIsInNlYXJjaCIsIm9wdGlvbnNGaWx0ZXIiLCJzZWFyY2hWYWx1ZSIsInRyaW0iLCJtYXAiLCJsYWJlbEluTGlzdCIsImxhYmVsIiwibmFtZSIsImhhbmRsZUtleVVwIiwiZSIsImtleUNvZGUiLCJoYW5kbGVBcnJvd1VwIiwiaGFuZGxlQXJyb3dEb3duIiwiaGFuZGxlRW50ZXIiLCJoYW5kbGVDaGFuZ2UiLCJzZXRTdGF0ZSIsImhhbmRsZVNlbGVjdCIsIm9uU2VsZWN0IiwiaGFuZGxlRGVzZWxlY3QiLCJvbkRlc2VsZWN0IiwiYXNzaWduU2VhcmNoUmVmIiwic2VhcmNoUmVmIiwicmVmIiwiZGVmYXVsdFNlYXJjaFZhbHVlIiwiaGFzRmlsdGVyIiwid2luZG93Iiwic2V0VGltZW91dCIsInF1ZXJ5U2VsZWN0b3IiLCJmb2N1cyIsImFkZEV2ZW50TGlzdGVuZXIiLCJuZXh0UHJvcHMiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZ2V0RmlsdGVyZWRPcHRpb25zIiwiZmluZEluZGV4Iiwib3B0aW9uIiwibGVuZ3RoIiwibmV4dEluZGV4IiwiZ2V0Q3VycmVudEluZGV4IiwiY2xvc2UiLCJ3aWR0aCIsImhlaWdodCIsIm9wdGlvblNpemUiLCJyZW5kZXJJdGVtIiwicGxhY2Vob2xkZXIiLCJsaXN0SGVpZ2h0IiwiaW5kZXgiLCJzdHlsZSIsImtleSIsInByb3BUeXBlcyIsImFycmF5T2YiLCJmdW5jIiwibnVtYmVyIiwic3RyaW5nIiwiYm9vbCIsImRlZmF1bHRQcm9wcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsT0FBT0EsS0FBUCxJQUFnQkMsYUFBaEIsUUFBcUMsT0FBckM7QUFDQSxPQUFPQyxTQUFQLE1BQXNCLFlBQXRCO0FBQ0EsT0FBT0MsVUFBUCxNQUF1QixpQkFBdkI7QUFDQSxPQUFPQyxXQUFQLE1BQXdCLHlCQUF4QjtBQUNBLFNBQVNDLElBQVQsUUFBcUIsY0FBckI7QUFDQSxTQUFTQyxTQUFULEVBQW9CQyxxQkFBcEIsUUFBaUQsYUFBakQ7QUFDQSxPQUFPQyxtQkFBUCxNQUFnQyx1QkFBaEM7QUFDQSxPQUFPQyxNQUFQLE1BQW1CLFVBQW5COztBQUVBOzs7Ozs7QUFNQSxJQUFNQyxjQUFjLFNBQWRBLFdBQWMsQ0FBQ0MsT0FBRCxFQUFVQyxLQUFWO0FBQUEsU0FBb0JULFdBQVdVLE1BQVgsQ0FBa0JGLE9BQWxCLEVBQTJCQyxLQUEzQixDQUFwQjtBQUFBLENBQXBCOztBQUVBOzs7O0FBSUEsSUFBTUUsZUFBZSxTQUFmQSxZQUFlO0FBQUEsU0FBUyxvQkFBQyxNQUFELEVBQVlDLEtBQVosQ0FBVDtBQUFBLENBQXJCOztJQUVxQkMsVzs7O0FBc0NuQix1QkFBWUQsS0FBWixFQUFtQkUsT0FBbkIsRUFBNEI7QUFBQTs7QUFBQSwwSEFDcEJGLEtBRG9CLEVBQ2JFLE9BRGE7O0FBQUEsVUFrQzVCQyxVQWxDNEIsR0FrQ2YsZ0JBQVE7QUFBQSxVQUNYQyxRQURXLEdBQ0UsTUFBS0MsS0FEUCxDQUNYRCxRQURXOzs7QUFHbkIsYUFBT0UsUUFBUUYsU0FBU0csSUFBVCxDQUFjO0FBQUEsZUFBZ0JDLGlCQUFpQkMsS0FBS0MsS0FBdEM7QUFBQSxPQUFkLENBQVIsQ0FBUDtBQUNELEtBdEMyQjs7QUFBQSxV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b25lbnQgfSBmcm9tICdyZWFjdCdcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcydcbmltcG9ydCBmdXp6YWxkcmluIGZyb20gJ2Z1enphbGRyaW4tcGx1cydcbmltcG9ydCBWaXJ0dWFsTGlzdCBmcm9tICdyZWFjdC10aW55LXZpcnR1YWwtbGlzdCdcbmltcG9ydCB7IFBhbmUgfSBmcm9tICcuLi8uLi9sYXllcnMnXG5pbXBvcnQgeyBUYWJsZUhlYWQsIFNlYXJjaFRhYmxlSGVhZGVyQ2VsbCB9IGZyb20gJy4uLy4uL3RhYmxlJ1xuaW1wb3J0IE9wdGlvblNoYXBlUHJvcFR5cGUgZnJvbSAnLi9PcHRpb25TaGFwZVByb3BUeXBlJ1xuaW1wb3J0IE9wdGlvbiBmcm9tICcuL09wdGlvbidcblxuLyoqXG4gKiBGdXp6YWxkcmluLXBsdXMgaXMgdGhlIGRlZmF1bHQgZmlsdGVyLCBidXQgeW91IGNhbiB1c2UgeW91ciBvd25cbiAqIGFzIGxvbmcgYXMgdGhleSBmb2xsb3cgdGhlIGZvbGxvd2luZyBzaWduYXR1cmU6XG4gKiBAcGFyYW0gb3B0aW9ucyA8QXJyYXlbU3RyaW5nXT4gLSBbJ2xhYmVsJywgJ2xhYmVsMicsIC4uLl1cbiAqIEBwYXJhbSBpbnB1dCA8U3RyaW5nPlxuICovXG5jb25zdCBmdXp6eUZpbHRlciA9IChvcHRpb25zLCBpbnB1dCkgPT4gZnV6emFsZHJpbi5maWx0ZXIob3B0aW9ucywgaW5wdXQpXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgZGVmYXVsdCBpdGVtIHJlbmRlcmVyIG9mIG9wdGlvbnNcbiAqIHlvdSBjYW4gcGFzcyBjdXN0b20gcmVuZGVyZXJzIGFzIGxvbmcgYXMgdGhleSB3b3JrIHRoZSBzYW1lIGFzIHRoZSBPcHRpb25cbiAqL1xuY29uc3QgaXRlbVJlbmRlcmVyID0gcHJvcHMgPT4gPE9wdGlvbiB7Li4ucHJvcHN9IC8+XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9wdGlvbnNMaXN0IGV4dGVuZHMgUHVyZUNvbXBvbmVudCB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgb3B0aW9uczogUHJvcFR5cGVzLmFycmF5T2YoT3B0aW9uU2hhcGVQcm9wVHlwZSksXG4gICAgY2xvc2U6IFByb3BUeXBlcy5mdW5jLFxuICAgIGhlaWdodDogUHJvcFR5cGVzLm51bWJlcixcbiAgICB3aWR0aDogUHJvcFR5cGVzLm51bWJlcixcblxuICAgIC8qKlxuICAgICAqIFRoaXMgaG9sZHMgdGhlIHZhbHVlcyBvZiB0aGUgb3B0aW9uc1xuICAgICAqL1xuICAgIHNlbGVjdGVkOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc3RyaW5nKSxcbiAgICBvblNlbGVjdDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25EZXNlbGVjdDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgaGFzRmlsdGVyOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBvcHRpb25TaXplOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHJlbmRlckl0ZW06IFByb3BUeXBlcy5mdW5jLFxuICAgIHBsYWNlaG9sZGVyOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9wdGlvbnNGaWx0ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIGRlZmF1bHRTZWFyY2hWYWx1ZTogUHJvcFR5cGVzLnN0cmluZ1xuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBvcHRpb25zOiBbXSxcbiAgICAvKipcbiAgICAgKiBJbmNsdWRpbmcgYm9yZGVyIGJvdHRvbVxuICAgICAqIEZvciBzb21lIHJlYXNvbiBwYXNzaW5nIGhlaWdodCB0byBUYWJsZVJvdyBkb2Vzbid0IHdvcmtcbiAgICAgKiBUT0RPOiBmaXggaGFja3kgc29sdXRpb25cbiAgICAgKi9cbiAgICBvcHRpb25TaXplOiAzMyxcbiAgICBvblNlbGVjdDogKCkgPT4ge30sXG4gICAgb25EZXNlbGVjdDogKCkgPT4ge30sXG4gICAgc2VsZWN0ZWQ6IFtdLFxuICAgIHJlbmRlckl0ZW06IGl0ZW1SZW5kZXJlcixcbiAgICBvcHRpb25zRmlsdGVyOiBmdXp6eUZpbHRlcixcbiAgICBwbGFjZWhvbGRlcjogJ0ZpbHRlci4uLicsXG4gICAgZGVmYXVsdFNlYXJjaFZhbHVlOiAnJ1xuICB9XG5cbiAgY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpIHtcbiAgICBzdXBlcihwcm9wcywgY29udGV4dClcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBzZWFyY2hWYWx1ZTogcHJvcHMuZGVmYXVsdFNlYXJjaFZhbHVlLFxuICAgICAgc2VsZWN0ZWQ6IHByb3BzLnNlbGVjdGVkXG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgY29uc3QgeyBoYXNGaWx0ZXIgfSA9IHRoaXMucHJvcHNcbiAgICBpZiAoIWhhc0ZpbHRlcikgcmV0dXJuXG4gICAgLyoqXG4gICAgICogSGFja3kgc29sdXRpb24gZm9yIGJyb2tlbiBhdXRvRm9jdXNcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vc2VnbWVudGlvL2V2ZXJncmVlbi9pc3N1ZXMvOTBcbiAgICAgKi9cbiAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnNlYXJjaFJlZi5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpLmZvY3VzKClcbiAgICB9LCAxKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuaGFuZGxlS2V5VXApXG4gIH1cblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIGlmIChuZXh0UHJvcHMuc2VsZWN0ZWQgIT09IHRoaXMuc3RhdGUuc2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBzZWxlY3RlZDogbmV4dFByb3BzLnNlbGVjdGVkXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuaGFuZGxlS2V5VXApXG4gIH1cblxuICBpc1NlbGVjdGVkID0gaXRlbSA9PiB7XG4gICAgY29uc3QgeyBzZWxlY3RlZCB9ID0gdGhpcy5zdGF0ZVxuXG4gICAgcmV0dXJuIEJvb2xlYW4oc2VsZWN0ZWQuZmluZChzZWxlY3RlZEl0ZW0gPT4gc2VsZWN0ZWRJdGVtID09PSBpdGVtLnZhbHVlKSlcbiAgfVxuXG4gIHNlYXJjaCA9IG9wdGlvbnMgPT4ge1xuICAgIGNvbnN0IHsgb3B0aW9uc0ZpbHRlciB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IHsgc2VhcmNoVmFsdWUgfSA9IHRoaXMuc3RhdGVcblxuICAgIHJldHVybiBzZWFyY2hWYWx1ZS50cmltKCkgPT09ICcnXG4gICAgICA/IG9wdGlvbnMgLy8gUmV0dXJuIGlmIG5vIHNlYXJjaCBxdWVyeVxuICAgICAgOiBvcHRpb25zRmlsdGVyKFxuICAgICAgICAgIG9wdGlvbnMubWFwKGl0ZW0gPT4gaXRlbS5sYWJlbEluTGlzdCB8fCBpdGVtLmxhYmVsKSxcbiAgICAgICAgICBzZWFyY2hWYWx1ZVxuICAgICAgICApLm1hcChuYW1lID0+XG4gICAgICAgICAgb3B0aW9ucy5maW5kKGl0ZW0gPT4gaXRlbS5sYWJlbEluTGlzdCA9PT0gbmFtZSB8fCBpdGVtLmxhYmVsID09PSBuYW1lKVxuICAgICAgICApXG4gIH1cblxuICBnZXRDdXJyZW50SW5kZXgoKSB7XG4gICAgY29uc3QgeyBzZWxlY3RlZCB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmdldEZpbHRlcmVkT3B0aW9ucygpXG5cbiAgICByZXR1cm4gb3B0aW9ucy5maW5kSW5kZXgoXG4gICAgICBvcHRpb24gPT4gb3B0aW9uLnZhbHVlID09PSBzZWxlY3RlZFtzZWxlY3RlZC5sZW5ndGggLSAxXVxuICAgIClcbiAgfVxuXG4gIGdldEZpbHRlcmVkT3B0aW9ucygpIHtcbiAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXMucHJvcHNcblxuICAgIHJldHVybiB0aGlzLnNlYXJjaChvcHRpb25zKVxuICB9XG5cbiAgaGFuZGxlS2V5VXAgPSBlID0+IHtcbiAgICBpZiAoZS5rZXlDb2RlID09PSAzOCkge1xuICAgICAgdGhpcy5oYW5kbGVBcnJvd1VwKClcbiAgICB9XG5cbiAgICBpZiAoZS5rZXlDb2RlID09PSA0MCkge1xuICAgICAgdGhpcy5oYW5kbGVBcnJvd0Rvd24oKVxuICAgIH1cblxuICAgIGlmIChlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICB0aGlzLmhhbmRsZUVudGVyKClcbiAgICB9XG4gIH1cblxuICBoYW5kbGVBcnJvd1VwKCkge1xuICAgIGNvbnN0IHsgb25TZWxlY3QgfSA9IHRoaXMucHJvcHNcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5nZXRGaWx0ZXJlZE9wdGlvbnMoKVxuXG4gICAgbGV0IG5leHRJbmRleCA9IHRoaXMuZ2V0Q3VycmVudEluZGV4KCkgLSAxXG5cbiAgICBpZiAobmV4dEluZGV4IDwgMCkge1xuICAgICAgbmV4dEluZGV4ID0gb3B0aW9ucy5sZW5ndGggLSAxXG4gICAgfVxuXG4gICAgb25TZWxlY3Qob3B0aW9uc1tuZXh0SW5kZXhdKVxuICB9XG5cbiAgaGFuZGxlQXJyb3dEb3duKCkge1xuICAgIGNvbnN0IHsgb25TZWxlY3QgfSA9IHRoaXMucHJvcHNcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5nZXRGaWx0ZXJlZE9wdGlvbnMoKVxuXG4gICAgbGV0IG5leHRJbmRleCA9IHRoaXMuZ2V0Q3VycmVudEluZGV4KCkgKyAxXG5cbiAgICBpZiAobmV4dEluZGV4ID09PSBvcHRpb25zLmxlbmd0aCkge1xuICAgICAgbmV4dEluZGV4ID0gMFxuICAgIH1cblxuICAgIG9uU2VsZWN0KG9wdGlvbnNbbmV4dEluZGV4XSlcbiAgfVxuXG4gIGhhbmRsZUVudGVyKCkge1xuICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSB0aGlzLmdldEN1cnJlbnRJbmRleCgpICE9PSAtMVxuXG4gICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMucHJvcHMuY2xvc2UoKVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUNoYW5nZSA9IHNlYXJjaFZhbHVlID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHNlYXJjaFZhbHVlXG4gICAgfSlcbiAgfVxuXG4gIGhhbmRsZVNlbGVjdCA9IGl0ZW0gPT4ge1xuICAgIHRoaXMucHJvcHMub25TZWxlY3QoaXRlbSlcbiAgfVxuICBoYW5kbGVEZXNlbGVjdCA9IGl0ZW0gPT4ge1xuICAgIHRoaXMucHJvcHMub25EZXNlbGVjdChpdGVtKVxuICB9XG5cbiAgYXNzaWduU2VhcmNoUmVmID0gcmVmID0+IHtcbiAgICB0aGlzLnNlYXJjaFJlZiA9IHJlZlxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNsb3NlLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBvblNlbGVjdCxcbiAgICAgIG9uRGVzZWxlY3QsXG4gICAgICBzZWxlY3RlZCxcbiAgICAgIGhhc0ZpbHRlcixcbiAgICAgIG9wdGlvblNpemUsXG4gICAgICByZW5kZXJJdGVtLFxuICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICBvcHRpb25zRmlsdGVyLFxuICAgICAgZGVmYXVsdFNlYXJjaFZhbHVlLFxuICAgICAgLi4ucHJvcHNcbiAgICB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmdldEZpbHRlcmVkT3B0aW9ucygpXG4gICAgY29uc3QgbGlzdEhlaWdodCA9IGhlaWdodCAtIChoYXNGaWx0ZXIgPyAzMiA6IDApXG5cbiAgICByZXR1cm4gKFxuICAgICAgPFBhbmVcbiAgICAgICAgaGVpZ2h0PXtoZWlnaHR9XG4gICAgICAgIHdpZHRoPXt3aWR0aH1cbiAgICAgICAgZGlzcGxheT1cImZsZXhcIlxuICAgICAgICBmbGV4RGlyZWN0aW9uPVwiY29sdW1uXCJcbiAgICAgICAgey4uLnByb3BzfVxuICAgICAgPlxuICAgICAgICB7aGFzRmlsdGVyICYmIChcbiAgICAgICAgICA8VGFibGVIZWFkPlxuICAgICAgICAgICAgPFNlYXJjaFRhYmxlSGVhZGVyQ2VsbFxuICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5oYW5kbGVDaGFuZ2V9XG4gICAgICAgICAgICAgIGlubmVyUmVmPXt0aGlzLmFzc2lnblNlYXJjaFJlZn1cbiAgICAgICAgICAgICAgYm9yZGVyUmlnaHQ9e251bGx9XG4gICAgICAgICAgICAgIGhlaWdodD17MzJ9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvVGFibGVIZWFkPlxuICAgICAgICApfVxuICAgICAgICA8UGFuZSBmbGV4PXsxfT5cbiAgICAgICAgICA8VmlydHVhbExpc3RcbiAgICAgICAgICAgIGhlaWdodD17bGlzdEhlaWdodH1cbiAgICAgICAgICAgIHdpZHRoPVwiMTAwJVwiXG4gICAgICAgICAgICBpdGVtU2l6ZT17b3B0aW9uU2l6ZX1cbiAgICAgICAgICAgIGl0ZW1Db3VudD17b3B0aW9ucy5sZW5ndGh9XG4gICAgICAgICAgICBvdmVyc2NhbkNvdW50PXszfVxuICAgICAgICAgICAgc2Nyb2xsVG9BbGlnbm1lbnQ9XCJhdXRvXCJcbiAgICAgICAgICAgIHJlbmRlckl0ZW09eyh7IGluZGV4LCBzdHlsZSB9KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBvcHRpb25zW2luZGV4XVxuICAgICAgICAgICAgICByZXR1cm4gcmVuZGVySXRlbSh7XG4gICAgICAgICAgICAgICAga2V5OiBpdGVtLnZhbHVlLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBpdGVtLmxhYmVsLFxuICAgICAgICAgICAgICAgIHN0eWxlLFxuICAgICAgICAgICAgICAgIGhlaWdodDogb3B0aW9uU2l6ZSxcbiAgICAgICAgICAgICAgICBvblNlbGVjdDogKCkgPT4gdGhpcy5oYW5kbGVTZWxlY3QoaXRlbSksXG4gICAgICAgICAgICAgICAgb25EZXNlbGVjdDogKCkgPT4gdGhpcy5oYW5kbGVEZXNlbGVjdChpdGVtKSxcbiAgICAgICAgICAgICAgICBpc1NlbGVjdGVkOiB0aGlzLmlzU2VsZWN0ZWQoaXRlbSlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9QYW5lPlxuICAgICAgPC9QYW5lPlxuICAgIClcbiAgfVxufVxuIl19