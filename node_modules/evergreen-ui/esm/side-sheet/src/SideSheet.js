var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React from 'react';
import PropTypes from 'prop-types';
import { css } from 'ui-box';
import { Pane } from '../../layers';
import { Overlay } from '../../overlay';
import SheetClose from './SheetClose';

var paneProps = {
  height: '100vh',
  position: 'absolute',
  right: 0
};

var animationEasing = {
  deceleration: 'cubic-bezier(0.0, 0.0, 0.2, 1)',
  acceleration: 'cubic-bezier(0.4, 0.0, 1, 1)'
};

var ANIMATION_DURATION = 240;

var slideInAnimation = css.keyframes('slideInAnimation', {
  from: {
    transform: 'translateX(100%)'
  },
  to: {
    transform: 'translateX(0)'
  }
});

var slideOutAnimation = css.keyframes('slideOutAnimation', {
  from: {
    transform: 'translateX(0)'
  },
  to: {
    transform: 'translateX(100%)'
  }
});

var animationStyles = {
  transform: 'translateX(100%)',
  '&[data-state="entering"], &[data-state="entered"]': {
    animation: slideInAnimation + ' ' + ANIMATION_DURATION + 'ms ' + animationEasing.deceleration + ' both'
  },
  '&[data-state="exiting"]': {
    animation: slideOutAnimation + ' ' + ANIMATION_DURATION + 'ms ' + animationEasing.acceleration + ' both'
  }
};

var SideSheet = function (_React$Component) {
  _inherits(SideSheet, _React$Component);

  function SideSheet() {
    _classCallCheck(this, SideSheet);

    return _possibleConstructorReturn(this, (SideSheet.__proto__ || Object.getPrototypeOf(SideSheet)).apply(this, arguments));
  }

  _createClass(SideSheet, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          width = _props.width,
          isShown = _props.isShown,
          children = _props.children,
          containerProps = _props.containerProps,
          onOpenComplete = _props.onOpenComplete,
          onCloseComplete = _props.onCloseComplete;


      return React.createElement(
        Overlay,
        {
          isShown: isShown,
          onExited: onCloseComplete,
          onEntered: onOpenComplete
        },
        function (_ref) {
          var state = _ref.state,
              close = _ref.close;
          return React.createElement(
            Pane,
            _extends({
              width: width
            }, paneProps, {
              css: animationStyles,
              'data-state': state
            }),
            React.createElement(SheetClose, { 'data-state': state, isClosing: false, onClick: close }),
            React.createElement(
              Pane,
              _extends({
                elevation: 4,
                backgroundColor: 'white',
                overflowY: 'auto',
                'data-state': state,
                width: width
              }, paneProps, containerProps),
              typeof children === 'function' ? children({ close: close }) : children
            )
          );
        }
      );
    }
  }]);

  return SideSheet;
}(React.Component);

SideSheet.propTypes = {
  /**
   * Children can be a string, node or a function accepting `({ close })`.
   */
  children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired,

  /**
   * When true, the Side Sheet is shown.
   */
  isShown: PropTypes.bool,

  /**
   * Function that will be called when the exit transition is complete.
   */
  onCloseComplete: PropTypes.func,

  /**
   * Function that will be called when the enter transition is complete.
   */
  onOpenComplete: PropTypes.func,

  /**
   * Width of the SideSheet.
   */
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,

  /**
   * Properties to pass through the SideSheet container Pane.
   */
  containerProps: PropTypes.object
};
SideSheet.defaultProps = {
  width: 620,
  onCloseComplete: function onCloseComplete() {},
  onOpenComplete: function onOpenComplete() {}
};


export default SideSheet;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zaWRlLXNoZWV0L3NyYy9TaWRlU2hlZXQuanMiXSwibmFtZXMiOlsiUmVhY3QiLCJQcm9wVHlwZXMiLCJjc3MiLCJQYW5lIiwiT3ZlcmxheSIsIlNoZWV0Q2xvc2UiLCJwYW5lUHJvcHMiLCJoZWlnaHQiLCJwb3NpdGlvbiIsInJpZ2h0IiwiYW5pbWF0aW9uRWFzaW5nIiwiZGVjZWxlcmF0aW9uIiwiYWNjZWxlcmF0aW9uIiwiQU5JTUFUSU9OX0RVUkFUSU9OIiwic2xpZGVJbkFuaW1hdGlvbiIsImtleWZyYW1lcyIsImZyb20iLCJ0cmFuc2Zvcm0iLCJ0byIsInNsaWRlT3V0QW5pbWF0aW9uIiwiYW5pbWF0aW9uU3R5bGVzIiwiYW5pbWF0aW9uIiwiU2lkZVNoZWV0IiwicHJvcHMiLCJ3aWR0aCIsImlzU2hvd24iLCJjaGlsZHJlbiIsImNvbnRhaW5lclByb3BzIiwib25PcGVuQ29tcGxldGUiLCJvbkNsb3NlQ29tcGxldGUiLCJzdGF0ZSIsImNsb3NlIiwiQ29tcG9uZW50IiwicHJvcFR5cGVzIiwib25lT2ZUeXBlIiwibm9kZSIsImZ1bmMiLCJpc1JlcXVpcmVkIiwiYm9vbCIsInN0cmluZyIsIm51bWJlciIsIm9iamVjdCIsImRlZmF1bHRQcm9wcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLE9BQU9BLEtBQVAsTUFBa0IsT0FBbEI7QUFDQSxPQUFPQyxTQUFQLE1BQXNCLFlBQXRCO0FBQ0EsU0FBU0MsR0FBVCxRQUFvQixRQUFwQjtBQUNBLFNBQVNDLElBQVQsUUFBcUIsY0FBckI7QUFDQSxTQUFTQyxPQUFULFFBQXdCLGVBQXhCO0FBQ0EsT0FBT0MsVUFBUCxNQUF1QixjQUF2Qjs7QUFFQSxJQUFNQyxZQUFZO0FBQ2hCQyxVQUFRLE9BRFE7QUFFaEJDLFlBQVUsVUFGTTtBQUdoQkMsU0FBTztBQUhTLENBQWxCOztBQU1BLElBQU1DLGtCQUFrQjtBQUN0QkMsZ0RBRHNCO0FBRXRCQztBQUZzQixDQUF4Qjs7QUFLQSxJQUFNQyxxQkFBcUIsR0FBM0I7O0FBRUEsSUFBTUMsbUJBQW1CWixJQUFJYSxTQUFKLENBQWMsa0JBQWQsRUFBa0M7QUFDekRDLFFBQU07QUFDSkM7QUFESSxHQURtRDtBQUl6REMsTUFBSTtBQUNGRDtBQURFO0FBSnFELENBQWxDLENBQXpCOztBQVNBLElBQU1FLG9CQUFvQmpCLElBQUlhLFNBQUosQ0FBYyxtQkFBZCxFQUFtQztBQUMzREMsUUFBTTtBQUNKQztBQURJLEdBRHFEO0FBSTNEQyxNQUFJO0FBQ0ZEO0FBREU7QUFKdUQsQ0FBbkMsQ0FBMUI7O0FBU0EsSUFBTUcsa0JBQWtCO0FBQ3RCSCwrQkFEc0I7QUFFdEIsdURBQXFEO0FBQ25ESSxlQUFjUCxnQkFBZCxTQUFrQ0Qsa0JBQWxDLFdBQ0VILGdCQUFnQkMsWUFEbEI7QUFEbUQsR0FGL0I7QUFPdEIsNkJBQTJCO0FBQ3pCVSxlQUFjRixpQkFBZCxTQUFtQ04sa0JBQW5DLFdBQ0VILGdCQUFnQkUsWUFEbEI7QUFEeUI7QUFQTCxDQUF4Qjs7SUFjTVUsUzs7Ozs7Ozs7Ozs7NkJBdUNLO0FBQUEsbUJBUUgsS0FBS0MsS0FSRjtBQUFBLFVBRUxDLEtBRkssVUFFTEEsS0FGSztBQUFBLFVBR0xDLE9BSEssVUFHTEEsT0FISztBQUFBLFVBSUxDLFFBSkssVUFJTEEsUUFKSztBQUFBLFVBS0xDLGNBTEssVUFLTEEsY0FMSztBQUFBLFVBTUxDLGNBTkssVUFNTEEsY0FOSztBQUFBLFVBT0xDLGVBUEssVUFPTEEsZUFQSzs7O0FBVVAsYUFDRTtBQUFDLGVBQUQ7QUFBQTtBQUNFLG1CQUFTSixPQURYO0FBRUUsb0JBQVVJLGVBRlo7QUFHRSxxQkFBV0Q7QUFIYjtBQUtHO0FBQUEsY0FBR0UsS0FBSCxRQUFHQSxLQUFIO0FBQUEsY0FBVUMsS0FBVixRQUFVQSxLQUFWO0FBQUEsaUJBQ0M7QUFBQyxnQkFBRDtBQUFBO0FBQ0UscUJBQU9QO0FBRFQsZUFFTWxCLFNBRk47QUFHRSxtQkFBS2MsZUFIUDtBQUlFLDRCQUFZVTtBQUpkO0FBTUUsZ0NBQUMsVUFBRCxJQUFZLGNBQVlBLEtBQXhCLEVBQStCLFdBQVcsS0FBMUMsRUFBaUQsU0FBU0MsS0FBMUQsR0FORjtBQU9FO0FBQUMsa0JBQUQ7QUFBQTtBQUNFLDJCQUFXLENBRGI7QUFFRSxpQ0FBZ0IsT0FGbEI7QUFHRSwyQkFBVSxNQUhaO0FBSUUsOEJBQVlELEtBSmQ7QUFLRSx1QkFBT047QUFMVCxpQkFNTWxCLFNBTk4sRUFPTXFCLGNBUE47QUFTRyxxQkFBT0QsUUFBUCxLQUFvQixVQUFwQixHQUFpQ0EsU0FBUyxFQUFFSyxZQUFGLEVBQVQsQ0FBakMsR0FBdURMO0FBVDFEO0FBUEYsV0FERDtBQUFBO0FBTEgsT0FERjtBQTZCRDs7OztFQTlFcUIxQixNQUFNZ0MsUzs7QUFBeEJWLFMsQ0FDR1csUyxHQUFZO0FBQ2pCOzs7QUFHQVAsWUFBVXpCLFVBQVVpQyxTQUFWLENBQW9CLENBQUNqQyxVQUFVa0MsSUFBWCxFQUFpQmxDLFVBQVVtQyxJQUEzQixDQUFwQixFQUFzREMsVUFKL0M7O0FBTWpCOzs7QUFHQVosV0FBU3hCLFVBQVVxQyxJQVRGOztBQVdqQjs7O0FBR0FULG1CQUFpQjVCLFVBQVVtQyxJQWRWOztBQWdCakI7OztBQUdBUixrQkFBZ0IzQixVQUFVbUMsSUFuQlQ7O0FBcUJqQjs7O0FBR0FaLFNBQU92QixVQUFVaUMsU0FBVixDQUFvQixDQUFDakMsVUFBVXNDLE1BQVgsRUFBbUJ0QyxVQUFVdUMsTUFBN0IsQ0FBcEIsRUFBMERILFVBeEJoRDs7QUEwQmpCOzs7QUFHQVYsa0JBQWdCMUIsVUFBVXdDO0FBN0JULEM7QUFEZm5CLFMsQ0FpQ0dvQixZLEdBQWU7QUFDcEJsQixTQUFPLEdBRGE7QUFFcEJLLG1CQUFpQiwyQkFBTSxDQUFFLENBRkw7QUFHcEJELGtCQUFnQiwwQkFBTSxDQUFFO0FBSEosQzs7O0FBZ0R4QixlQUFlTixTQUFmIiwiZmlsZSI6IlNpZGVTaGVldC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcydcbmltcG9ydCB7IGNzcyB9IGZyb20gJ3VpLWJveCdcbmltcG9ydCB7IFBhbmUgfSBmcm9tICcuLi8uLi9sYXllcnMnXG5pbXBvcnQgeyBPdmVybGF5IH0gZnJvbSAnLi4vLi4vb3ZlcmxheSdcbmltcG9ydCBTaGVldENsb3NlIGZyb20gJy4vU2hlZXRDbG9zZSdcblxuY29uc3QgcGFuZVByb3BzID0ge1xuICBoZWlnaHQ6ICcxMDB2aCcsXG4gIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICByaWdodDogMFxufVxuXG5jb25zdCBhbmltYXRpb25FYXNpbmcgPSB7XG4gIGRlY2VsZXJhdGlvbjogYGN1YmljLWJlemllcigwLjAsIDAuMCwgMC4yLCAxKWAsXG4gIGFjY2VsZXJhdGlvbjogYGN1YmljLWJlemllcigwLjQsIDAuMCwgMSwgMSlgXG59XG5cbmNvbnN0IEFOSU1BVElPTl9EVVJBVElPTiA9IDI0MFxuXG5jb25zdCBzbGlkZUluQW5pbWF0aW9uID0gY3NzLmtleWZyYW1lcygnc2xpZGVJbkFuaW1hdGlvbicsIHtcbiAgZnJvbToge1xuICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoMTAwJSlgXG4gIH0sXG4gIHRvOiB7XG4gICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgwKWBcbiAgfVxufSlcblxuY29uc3Qgc2xpZGVPdXRBbmltYXRpb24gPSBjc3Mua2V5ZnJhbWVzKCdzbGlkZU91dEFuaW1hdGlvbicsIHtcbiAgZnJvbToge1xuICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoMClgXG4gIH0sXG4gIHRvOiB7XG4gICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgxMDAlKWBcbiAgfVxufSlcblxuY29uc3QgYW5pbWF0aW9uU3R5bGVzID0ge1xuICB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKDEwMCUpYCxcbiAgJyZbZGF0YS1zdGF0ZT1cImVudGVyaW5nXCJdLCAmW2RhdGEtc3RhdGU9XCJlbnRlcmVkXCJdJzoge1xuICAgIGFuaW1hdGlvbjogYCR7c2xpZGVJbkFuaW1hdGlvbn0gJHtBTklNQVRJT05fRFVSQVRJT059bXMgJHtcbiAgICAgIGFuaW1hdGlvbkVhc2luZy5kZWNlbGVyYXRpb25cbiAgICB9IGJvdGhgXG4gIH0sXG4gICcmW2RhdGEtc3RhdGU9XCJleGl0aW5nXCJdJzoge1xuICAgIGFuaW1hdGlvbjogYCR7c2xpZGVPdXRBbmltYXRpb259ICR7QU5JTUFUSU9OX0RVUkFUSU9OfW1zICR7XG4gICAgICBhbmltYXRpb25FYXNpbmcuYWNjZWxlcmF0aW9uXG4gICAgfSBib3RoYFxuICB9XG59XG5cbmNsYXNzIFNpZGVTaGVldCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgLyoqXG4gICAgICogQ2hpbGRyZW4gY2FuIGJlIGEgc3RyaW5nLCBub2RlIG9yIGEgZnVuY3Rpb24gYWNjZXB0aW5nIGAoeyBjbG9zZSB9KWAuXG4gICAgICovXG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5ub2RlLCBQcm9wVHlwZXMuZnVuY10pLmlzUmVxdWlyZWQsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIHRoZSBTaWRlIFNoZWV0IGlzIHNob3duLlxuICAgICAqL1xuICAgIGlzU2hvd246IFByb3BUeXBlcy5ib29sLFxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBleGl0IHRyYW5zaXRpb24gaXMgY29tcGxldGUuXG4gICAgICovXG4gICAgb25DbG9zZUNvbXBsZXRlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgZW50ZXIgdHJhbnNpdGlvbiBpcyBjb21wbGV0ZS5cbiAgICAgKi9cbiAgICBvbk9wZW5Db21wbGV0ZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiB0aGUgU2lkZVNoZWV0LlxuICAgICAqL1xuICAgIHdpZHRoOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMubnVtYmVyXSkuaXNSZXF1aXJlZCxcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgdG8gcGFzcyB0aHJvdWdoIHRoZSBTaWRlU2hlZXQgY29udGFpbmVyIFBhbmUuXG4gICAgICovXG4gICAgY29udGFpbmVyUHJvcHM6IFByb3BUeXBlcy5vYmplY3RcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgd2lkdGg6IDYyMCxcbiAgICBvbkNsb3NlQ29tcGxldGU6ICgpID0+IHt9LFxuICAgIG9uT3BlbkNvbXBsZXRlOiAoKSA9PiB7fVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaXNTaG93bixcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgY29udGFpbmVyUHJvcHMsXG4gICAgICBvbk9wZW5Db21wbGV0ZSxcbiAgICAgIG9uQ2xvc2VDb21wbGV0ZVxuICAgIH0gPSB0aGlzLnByb3BzXG5cbiAgICByZXR1cm4gKFxuICAgICAgPE92ZXJsYXlcbiAgICAgICAgaXNTaG93bj17aXNTaG93bn1cbiAgICAgICAgb25FeGl0ZWQ9e29uQ2xvc2VDb21wbGV0ZX1cbiAgICAgICAgb25FbnRlcmVkPXtvbk9wZW5Db21wbGV0ZX1cbiAgICAgID5cbiAgICAgICAgeyh7IHN0YXRlLCBjbG9zZSB9KSA9PiAoXG4gICAgICAgICAgPFBhbmVcbiAgICAgICAgICAgIHdpZHRoPXt3aWR0aH1cbiAgICAgICAgICAgIHsuLi5wYW5lUHJvcHN9XG4gICAgICAgICAgICBjc3M9e2FuaW1hdGlvblN0eWxlc31cbiAgICAgICAgICAgIGRhdGEtc3RhdGU9e3N0YXRlfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxTaGVldENsb3NlIGRhdGEtc3RhdGU9e3N0YXRlfSBpc0Nsb3Npbmc9e2ZhbHNlfSBvbkNsaWNrPXtjbG9zZX0gLz5cbiAgICAgICAgICAgIDxQYW5lXG4gICAgICAgICAgICAgIGVsZXZhdGlvbj17NH1cbiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yPVwid2hpdGVcIlxuICAgICAgICAgICAgICBvdmVyZmxvd1k9XCJhdXRvXCJcbiAgICAgICAgICAgICAgZGF0YS1zdGF0ZT17c3RhdGV9XG4gICAgICAgICAgICAgIHdpZHRoPXt3aWR0aH1cbiAgICAgICAgICAgICAgey4uLnBhbmVQcm9wc31cbiAgICAgICAgICAgICAgey4uLmNvbnRhaW5lclByb3BzfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICB7dHlwZW9mIGNoaWxkcmVuID09PSAnZnVuY3Rpb24nID8gY2hpbGRyZW4oeyBjbG9zZSB9KSA6IGNoaWxkcmVufVxuICAgICAgICAgICAgPC9QYW5lPlxuICAgICAgICAgIDwvUGFuZT5cbiAgICAgICAgKX1cbiAgICAgIDwvT3ZlcmxheT5cbiAgICApXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2lkZVNoZWV0XG4iXX0=