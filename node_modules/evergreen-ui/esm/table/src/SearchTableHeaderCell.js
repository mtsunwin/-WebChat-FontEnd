var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import { Text } from '../../typography';
import { SearchIcon } from '../../icons';
import { colors } from '../../colors';
import TableHeaderCell from './TableHeaderCell';

var invisibleInput = {
  border: 'none',
  backgroundColor: 'transparent',
  WebkitAppearance: 'none',
  WebkitFontSmoothing: 'antialiased',

  '&:focus': {
    outline: 'none'
  },

  '&::placeholder': {
    color: colors.neutral['100A']
  }
};

var SearchTableHeaderCell = function (_PureComponent) {
  _inherits(SearchTableHeaderCell, _PureComponent);

  function SearchTableHeaderCell() {
    _classCallCheck(this, SearchTableHeaderCell);

    return _possibleConstructorReturn(this, (SearchTableHeaderCell.__proto__ || Object.getPrototypeOf(SearchTableHeaderCell)).apply(this, arguments));
  }

  _createClass(SearchTableHeaderCell, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          value = _props.value,
          children = _props.children,
          _onChange = _props.onChange,
          autoFocus = _props.autoFocus,
          spellCheck = _props.spellCheck,
          placeholder = _props.placeholder,
          props = _objectWithoutProperties(_props, ['value', 'children', 'onChange', 'autoFocus', 'spellCheck', 'placeholder']);

      return React.createElement(
        TableHeaderCell,
        props,
        React.createElement(SearchIcon, { marginLeft: -8, marginTop: -0.5, iconSize: 12 }),
        React.createElement(Text, {
          is: 'input',
          size: 300,
          flex: '1',
          css: invisibleInput,
          value: value,
          onChange: function onChange(e) {
            return _onChange(e.target.value);
          },
          autoFocus: autoFocus,
          spellCheck: spellCheck,
          fontWeight: 500,
          marginLeft: -2,
          paddingLeft: 0,
          placeholder: placeholder
        })
      );
    }
  }]);

  return SearchTableHeaderCell;
}(PureComponent);

SearchTableHeaderCell.propTypes = _extends({}, TableHeaderCell.propTypes, {

  /**
   * The value of the input.
   */
  value: PropTypes.string,

  /**
   * Handler to be called when the input changes.
   */
  onChange: PropTypes.func,

  /**
   * Sets whether the component should be automatically focused on component render.
   */
  autoFocus: PropTypes.bool,

  /**
   * Sets whether to apply spell checking to the content.
   */
  spellCheck: PropTypes.bool,

  /**
   * Text to display in the input if the input is empty.
   */
  placeholder: PropTypes.string
});
SearchTableHeaderCell.defaultProps = {
  onChange: function onChange() {},
  spellCheck: true,
  placeholder: 'Filter...'
};
export default SearchTableHeaderCell;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy90YWJsZS9zcmMvU2VhcmNoVGFibGVIZWFkZXJDZWxsLmpzIl0sIm5hbWVzIjpbIlJlYWN0IiwiUHVyZUNvbXBvbmVudCIsIlByb3BUeXBlcyIsIlRleHQiLCJTZWFyY2hJY29uIiwiY29sb3JzIiwiVGFibGVIZWFkZXJDZWxsIiwiaW52aXNpYmxlSW5wdXQiLCJib3JkZXIiLCJiYWNrZ3JvdW5kQ29sb3IiLCJXZWJraXRBcHBlYXJhbmNlIiwiV2Via2l0Rm9udFNtb290aGluZyIsIm91dGxpbmUiLCJjb2xvciIsIm5ldXRyYWwiLCJTZWFyY2hUYWJsZUhlYWRlckNlbGwiLCJwcm9wcyIsInZhbHVlIiwiY2hpbGRyZW4iLCJvbkNoYW5nZSIsImF1dG9Gb2N1cyIsInNwZWxsQ2hlY2siLCJwbGFjZWhvbGRlciIsImUiLCJ0YXJnZXQiLCJwcm9wVHlwZXMiLCJzdHJpbmciLCJmdW5jIiwiYm9vbCIsImRlZmF1bHRQcm9wcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsT0FBT0EsS0FBUCxJQUFnQkMsYUFBaEIsUUFBcUMsT0FBckM7QUFDQSxPQUFPQyxTQUFQLE1BQXNCLFlBQXRCO0FBQ0EsU0FBU0MsSUFBVCxRQUFxQixrQkFBckI7QUFDQSxTQUFTQyxVQUFULFFBQTJCLGFBQTNCO0FBQ0EsU0FBU0MsTUFBVCxRQUF1QixjQUF2QjtBQUNBLE9BQU9DLGVBQVAsTUFBNEIsbUJBQTVCOztBQUVBLElBQU1DLGlCQUFpQjtBQUNyQkMsVUFBUSxNQURhO0FBRXJCQyxtQkFBaUIsYUFGSTtBQUdyQkMsb0JBQWtCLE1BSEc7QUFJckJDLHVCQUFxQixhQUpBOztBQU1yQixhQUFXO0FBQ1RDLGFBQVM7QUFEQSxHQU5VOztBQVVyQixvQkFBa0I7QUFDaEJDLFdBQU9SLE9BQU9TLE9BQVAsQ0FBZSxNQUFmO0FBRFM7QUFWRyxDQUF2Qjs7SUFlcUJDLHFCOzs7Ozs7Ozs7Ozs2QkF1Q1Y7QUFBQSxtQkFTSCxLQUFLQyxLQVRGO0FBQUEsVUFFTEMsS0FGSyxVQUVMQSxLQUZLO0FBQUEsVUFHTEMsUUFISyxVQUdMQSxRQUhLO0FBQUEsVUFJTEMsU0FKSyxVQUlMQSxRQUpLO0FBQUEsVUFLTEMsU0FMSyxVQUtMQSxTQUxLO0FBQUEsVUFNTEMsVUFOSyxVQU1MQSxVQU5LO0FBQUEsVUFPTEMsV0FQSyxVQU9MQSxXQVBLO0FBQUEsVUFRRk4sS0FSRTs7QUFXUCxhQUNFO0FBQUMsdUJBQUQ7QUFBcUJBLGFBQXJCO0FBQ0UsNEJBQUMsVUFBRCxJQUFZLFlBQVksQ0FBQyxDQUF6QixFQUE0QixXQUFXLENBQUMsR0FBeEMsRUFBNkMsVUFBVSxFQUF2RCxHQURGO0FBRUUsNEJBQUMsSUFBRDtBQUNFLGNBQUcsT0FETDtBQUVFLGdCQUFNLEdBRlI7QUFHRSxnQkFBSyxHQUhQO0FBSUUsZUFBS1QsY0FKUDtBQUtFLGlCQUFPVSxLQUxUO0FBTUUsb0JBQVU7QUFBQSxtQkFBS0UsVUFBU0ksRUFBRUMsTUFBRixDQUFTUCxLQUFsQixDQUFMO0FBQUEsV0FOWjtBQU9FLHFCQUFXRyxTQVBiO0FBUUUsc0JBQVlDLFVBUmQ7QUFTRSxzQkFBWSxHQVRkO0FBVUUsc0JBQVksQ0FBQyxDQVZmO0FBV0UsdUJBQWEsQ0FYZjtBQVlFLHVCQUFhQztBQVpmO0FBRkYsT0FERjtBQW1CRDs7OztFQXJFZ0RyQixhOztBQUE5QmMscUIsQ0FDWlUsUyxnQkFJRm5CLGdCQUFnQm1CLFM7O0FBRW5COzs7QUFHQVIsU0FBT2YsVUFBVXdCLE07O0FBRWpCOzs7QUFHQVAsWUFBVWpCLFVBQVV5QixJOztBQUVwQjs7O0FBR0FQLGFBQVdsQixVQUFVMEIsSTs7QUFFckI7OztBQUdBUCxjQUFZbkIsVUFBVTBCLEk7O0FBRXRCOzs7QUFHQU4sZUFBYXBCLFVBQVV3Qjs7QUE5Qk5YLHFCLENBaUNaYyxZLEdBQWU7QUFDcEJWLFlBQVUsb0JBQU0sQ0FBRSxDQURFO0FBRXBCRSxjQUFZLElBRlE7QUFHcEJDLGVBQWE7QUFITyxDO2VBakNIUCxxQiIsImZpbGUiOiJTZWFyY2hUYWJsZUhlYWRlckNlbGwuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgUHVyZUNvbXBvbmVudCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJ1xuaW1wb3J0IHsgVGV4dCB9IGZyb20gJy4uLy4uL3R5cG9ncmFwaHknXG5pbXBvcnQgeyBTZWFyY2hJY29uIH0gZnJvbSAnLi4vLi4vaWNvbnMnXG5pbXBvcnQgeyBjb2xvcnMgfSBmcm9tICcuLi8uLi9jb2xvcnMnXG5pbXBvcnQgVGFibGVIZWFkZXJDZWxsIGZyb20gJy4vVGFibGVIZWFkZXJDZWxsJ1xuXG5jb25zdCBpbnZpc2libGVJbnB1dCA9IHtcbiAgYm9yZGVyOiAnbm9uZScsXG4gIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgV2Via2l0QXBwZWFyYW5jZTogJ25vbmUnLFxuICBXZWJraXRGb250U21vb3RoaW5nOiAnYW50aWFsaWFzZWQnLFxuXG4gICcmOmZvY3VzJzoge1xuICAgIG91dGxpbmU6ICdub25lJ1xuICB9LFxuXG4gICcmOjpwbGFjZWhvbGRlcic6IHtcbiAgICBjb2xvcjogY29sb3JzLm5ldXRyYWxbJzEwMEEnXVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlYXJjaFRhYmxlSGVhZGVyQ2VsbCBleHRlbmRzIFB1cmVDb21wb25lbnQge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIC8qKlxuICAgICAqIENvbXBvc2VzIHRoZSBUYWJsZUhlYWRlckNlbGwgY29tcG9uZW50IGFzIHRoZSBiYXNlLlxuICAgICAqL1xuICAgIC4uLlRhYmxlSGVhZGVyQ2VsbC5wcm9wVHlwZXMsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgb2YgdGhlIGlucHV0LlxuICAgICAqL1xuICAgIHZhbHVlOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciB0byBiZSBjYWxsZWQgd2hlbiB0aGUgaW5wdXQgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgdGhlIGNvbXBvbmVudCBzaG91bGQgYmUgYXV0b21hdGljYWxseSBmb2N1c2VkIG9uIGNvbXBvbmVudCByZW5kZXIuXG4gICAgICovXG4gICAgYXV0b0ZvY3VzOiBQcm9wVHlwZXMuYm9vbCxcblxuICAgIC8qKlxuICAgICAqIFNldHMgd2hldGhlciB0byBhcHBseSBzcGVsbCBjaGVja2luZyB0byB0aGUgY29udGVudC5cbiAgICAgKi9cbiAgICBzcGVsbENoZWNrOiBQcm9wVHlwZXMuYm9vbCxcblxuICAgIC8qKlxuICAgICAqIFRleHQgdG8gZGlzcGxheSBpbiB0aGUgaW5wdXQgaWYgdGhlIGlucHV0IGlzIGVtcHR5LlxuICAgICAqL1xuICAgIHBsYWNlaG9sZGVyOiBQcm9wVHlwZXMuc3RyaW5nXG4gIH1cblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIG9uQ2hhbmdlOiAoKSA9PiB7fSxcbiAgICBzcGVsbENoZWNrOiB0cnVlLFxuICAgIHBsYWNlaG9sZGVyOiAnRmlsdGVyLi4uJ1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHZhbHVlLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBvbkNoYW5nZSxcbiAgICAgIGF1dG9Gb2N1cyxcbiAgICAgIHNwZWxsQ2hlY2ssXG4gICAgICBwbGFjZWhvbGRlcixcbiAgICAgIC4uLnByb3BzXG4gICAgfSA9IHRoaXMucHJvcHNcblxuICAgIHJldHVybiAoXG4gICAgICA8VGFibGVIZWFkZXJDZWxsIHsuLi5wcm9wc30+XG4gICAgICAgIDxTZWFyY2hJY29uIG1hcmdpbkxlZnQ9ey04fSBtYXJnaW5Ub3A9ey0wLjV9IGljb25TaXplPXsxMn0gLz5cbiAgICAgICAgPFRleHRcbiAgICAgICAgICBpcz1cImlucHV0XCJcbiAgICAgICAgICBzaXplPXszMDB9XG4gICAgICAgICAgZmxleD1cIjFcIlxuICAgICAgICAgIGNzcz17aW52aXNpYmxlSW5wdXR9XG4gICAgICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgICAgIG9uQ2hhbmdlPXtlID0+IG9uQ2hhbmdlKGUudGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgICBhdXRvRm9jdXM9e2F1dG9Gb2N1c31cbiAgICAgICAgICBzcGVsbENoZWNrPXtzcGVsbENoZWNrfVxuICAgICAgICAgIGZvbnRXZWlnaHQ9ezUwMH1cbiAgICAgICAgICBtYXJnaW5MZWZ0PXstMn1cbiAgICAgICAgICBwYWRkaW5nTGVmdD17MH1cbiAgICAgICAgICBwbGFjZWhvbGRlcj17cGxhY2Vob2xkZXJ9XG4gICAgICAgIC8+XG4gICAgICA8L1RhYmxlSGVhZGVyQ2VsbD5cbiAgICApXG4gIH1cbn1cbiJdfQ==