var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import Box from 'ui-box';
import { Image } from '../../image';
import { Text } from '../../typography';
import { FillAppearances } from '../../shared-styles';
import { colors } from '../../colors';
import globalGetInitials from './utils/getInitials';
import globalHash from './utils/hash';

var keysFillAppearances = Object.keys(FillAppearances.default);

var initialsProps = {
  top: 0,
  position: 'absolute',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  lineHeight: 1
};

var getInitialsFontSize = function getInitialsFontSize(size, heightLimitOneCharacter) {
  if (size <= heightLimitOneCharacter) {
    return Math.ceil(size / 2.2);
  }
  return Math.ceil(size / 2.6);
};

var Avatar = function (_PureComponent) {
  _inherits(Avatar, _PureComponent);

  function Avatar(props, context) {
    _classCallCheck(this, Avatar);

    var _this = _possibleConstructorReturn(this, (Avatar.__proto__ || Object.getPrototypeOf(Avatar)).call(this, props, context));

    _this.handleError = function () {
      _this.setState({
        imageHasFailedLoading: true
      });
    };

    _this.state = {
      imageHasFailedLoading: false
    };
    return _this;
  }

  _createClass(Avatar, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          src = _props.src,
          size = _props.size,
          name = _props.name,
          hash = _props.hash,
          isSolid = _props.isSolid,
          propsHashValue = _props.hashValue,
          getInitials = _props.getInitials,
          useAutoColor = _props.useAutoColor,
          propsAppearance = _props.appearance,
          forceShowInitials = _props.forceShowInitials,
          heightLimitOneCharacter = _props.heightLimitOneCharacter,
          props = _objectWithoutProperties(_props, ['src', 'size', 'name', 'hash', 'isSolid', 'hashValue', 'getInitials', 'useAutoColor', 'appearance', 'forceShowInitials', 'heightLimitOneCharacter']);

      var imageHasFailedLoading = this.state.imageHasFailedLoading;

      var imageUnavailable = !src || imageHasFailedLoading;
      var initialsFontSize = getInitialsFontSize(size, heightLimitOneCharacter) + 'px';

      var initials = getInitials(name);
      if (size <= heightLimitOneCharacter) {
        initials = initials.substring(0, 1);
      }

      var hashValue = hash(propsHashValue || name);
      var appearanceKey = propsAppearance;
      if (appearanceKey === undefined) {
        appearanceKey = keysFillAppearances[hashValue % keysFillAppearances.length];
      }

      var appearance = FillAppearances[isSolid ? 'solid' : 'default'][appearanceKey];

      return React.createElement(
        Box,
        _extends({
          width: size,
          height: size,
          overflow: 'hidden',
          borderRadius: 9999,
          position: 'relative',
          display: 'inline-flex',
          justifyContent: 'center',
          backgroundColor: colors.neutral['300'],
          title: name
        }, appearance, props),
        (imageUnavailable || forceShowInitials) && React.createElement(
          Text,
          {
            css: initialsProps,
            fontSize: initialsFontSize,
            lineHeight: initialsFontSize,
            width: size,
            height: size,
            color: appearance.color
          },
          initials
        ),
        !imageUnavailable && React.createElement(Image, {
          width: 'auto',
          height: '100%',
          src: src,
          onError: this.handleError
        })
      );
    }
  }]);

  return Avatar;
}(PureComponent);

Avatar.propTypes = _extends({}, Image.propTypes, {
  size: PropTypes.number,
  name: PropTypes.string,
  // Hash value defaults to name
  hashValue: PropTypes.string,
  hash: PropTypes.func,
  isSolid: PropTypes.bool,
  appearance: PropTypes.oneOf(keysFillAppearances),
  getInitials: PropTypes.func,
  // In some cases Gravatar returns transparent pngs
  // we still want to see the initials
  forceShowInitials: PropTypes.bool,
  heightLimitOneCharacter: PropTypes.number
});
Avatar.defaultProps = {
  size: 24,
  hash: globalHash,
  isSolid: false,
  getInitials: globalGetInitials,
  forceShowInitials: false,
  heightLimitOneCharacter: 20
};
export default Avatar;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9hdmF0YXIvc3JjL0F2YXRhci5qcyJdLCJuYW1lcyI6WyJSZWFjdCIsIlB1cmVDb21wb25lbnQiLCJQcm9wVHlwZXMiLCJCb3giLCJJbWFnZSIsIlRleHQiLCJGaWxsQXBwZWFyYW5jZXMiLCJjb2xvcnMiLCJnbG9iYWxHZXRJbml0aWFscyIsImdsb2JhbEhhc2giLCJrZXlzRmlsbEFwcGVhcmFuY2VzIiwiT2JqZWN0Iiwia2V5cyIsImRlZmF1bHQiLCJpbml0aWFsc1Byb3BzIiwidG9wIiwicG9zaXRpb24iLCJkaXNwbGF5IiwiYWxpZ25JdGVtcyIsImp1c3RpZnlDb250ZW50IiwibGluZUhlaWdodCIsImdldEluaXRpYWxzRm9udFNpemUiLCJzaXplIiwiaGVpZ2h0TGltaXRPbmVDaGFyYWN0ZXIiLCJNYXRoIiwiY2VpbCIsIkF2YXRhciIsInByb3BzIiwiY29udGV4dCIsImhhbmRsZUVycm9yIiwic2V0U3RhdGUiLCJpbWFnZUhhc0ZhaWxlZExvYWRpbmciLCJzdGF0ZSIsInNyYyIsIm5hbWUiLCJoYXNoIiwiaXNTb2xpZCIsInByb3BzSGFzaFZhbHVlIiwiaGFzaFZhbHVlIiwiZ2V0SW5pdGlhbHMiLCJ1c2VBdXRvQ29sb3IiLCJwcm9wc0FwcGVhcmFuY2UiLCJhcHBlYXJhbmNlIiwiZm9yY2VTaG93SW5pdGlhbHMiLCJpbWFnZVVuYXZhaWxhYmxlIiwiaW5pdGlhbHNGb250U2l6ZSIsImluaXRpYWxzIiwic3Vic3RyaW5nIiwiYXBwZWFyYW5jZUtleSIsInVuZGVmaW5lZCIsImxlbmd0aCIsIm5ldXRyYWwiLCJjb2xvciIsInByb3BUeXBlcyIsIm51bWJlciIsInN0cmluZyIsImZ1bmMiLCJib29sIiwib25lT2YiLCJkZWZhdWx0UHJvcHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLE9BQU9BLEtBQVAsSUFBZ0JDLGFBQWhCLFFBQXFDLE9BQXJDO0FBQ0EsT0FBT0MsU0FBUCxNQUFzQixZQUF0QjtBQUNBLE9BQU9D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QWlCZixPQUFPNEMsT0FBUCxDQUFlLEtBQWYsQ0FSbkI7QUFTRSxpQkFBT2pCO0FBVFQsV0FVTVEsVUFWTixFQVdNZixLQVhOO0FBYUcsU0FBQ2lCLG9CQUFvQkQsaUJBQXJCLEtBQ0M7QUFBQyxjQUFEO0FBQUE7QUFDRSxpQkFBSzdCLGFBRFA7QUFFRSxzQkFBVStCLGdCQUZaO0FBR0Usd0JBQVlBLGdCQUhkO0FBSUUsbUJBQU92QixJQUpUO0FBS0Usb0JBQVFBLElBTFY7QUFNRSxtQkFBT29CLFdBQVdVO0FBTnBCO0FBUUdOO0FBUkgsU0FkSjtBQXlCRyxTQUFDRixnQkFBRCxJQUNDLG9CQUFDLEtBQUQ7QUFDRSxpQkFBTSxNQURSO0FBRUUsa0JBQU8sTUFGVDtBQUdFLGVBQUtYLEdBSFA7QUFJRSxtQkFBUyxLQUFLSjtBQUpoQjtBQTFCSixPQURGO0FBb0NEOzs7O0VBaEhpQzVCLGE7O0FBQWZ5QixNLENBQ1oyQixTLGdCQUNGakQsTUFBTWlELFM7QUFDVC9CLFFBQU1wQixVQUFVb0QsTTtBQUNoQnBCLFFBQU1oQyxVQUFVcUQsTTtBQUNoQjtBQUNBakIsYUFBV3BDLFVBQVVxRCxNO0FBQ3JCcEIsUUFBTWpDLFVBQVVzRCxJO0FBQ2hCcEIsV0FBU2xDLFVBQVV1RCxJO0FBQ25CZixjQUFZeEMsVUFBVXdELEtBQVYsQ0FBZ0JoRCxtQkFBaEIsQztBQUNaNkIsZUFBYXJDLFVBQVVzRCxJO0FBQ3ZCO0FBQ0E7QUFDQWIscUJBQW1CekMsVUFBVXVELEk7QUFDN0JsQywyQkFBeUJyQixVQUFVb0Q7O0FBZGxCNUIsTSxDQWlCWmlDLFksR0FBZTtBQUNwQnJDLFFBQU0sRUFEYztBQUVwQmEsUUFBTTFCLFVBRmM7QUFHcEIyQixXQUFTLEtBSFc7QUFJcEJHLGVBQWEvQixpQkFKTztBQUtwQm1DLHFCQUFtQixLQUxDO0FBTXBCcEIsMkJBQXlCO0FBTkwsQztlQWpCSEcsTSIsImZpbGUiOiJBdmF0YXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgUHVyZUNvbXBvbmVudCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJ1xuaW1wb3J0IEJveCBmcm9tICd1aS1ib3gnXG5pbXBvcnQgeyBJbWFnZSB9IGZyb20gJy4uLy4uL2ltYWdlJ1xuaW1wb3J0IHsgVGV4dCB9IGZyb20gJy4uLy4uL3R5cG9ncmFwaHknXG5pbXBvcnQgeyBGaWxsQXBwZWFyYW5jZXMgfSBmcm9tICcuLi8uLi9zaGFyZWQtc3R5bGVzJ1xuaW1wb3J0IHsgY29sb3JzIH0gZnJvbSAnLi4vLi4vY29sb3JzJ1xuaW1wb3J0IGdsb2JhbEdldEluaXRpYWxzIGZyb20gJy4vdXRpbHMvZ2V0SW5pdGlhbHMnXG5pbXBvcnQgZ2xvYmFsSGFzaCBmcm9tICcuL3V0aWxzL2hhc2gnXG5cbmNvbnN0IGtleXNGaWxsQXBwZWFyYW5jZXMgPSBPYmplY3Qua2V5cyhGaWxsQXBwZWFyYW5jZXMuZGVmYXVsdClcblxuY29uc3QgaW5pdGlhbHNQcm9wcyA9IHtcbiAgdG9wOiAwLFxuICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxuICBsaW5lSGVpZ2h0OiAxXG59XG5cbmNvbnN0IGdldEluaXRpYWxzRm9udFNpemUgPSAoc2l6ZSwgaGVpZ2h0TGltaXRPbmVDaGFyYWN0ZXIpID0+IHtcbiAgaWYgKHNpemUgPD0gaGVpZ2h0TGltaXRPbmVDaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHNpemUgLyAyLjIpXG4gIH1cbiAgcmV0dXJuIE1hdGguY2VpbChzaXplIC8gMi42KVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdmF0YXIgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAuLi5JbWFnZS5wcm9wVHlwZXMsXG4gICAgc2l6ZTogUHJvcFR5cGVzLm51bWJlcixcbiAgICBuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIC8vIEhhc2ggdmFsdWUgZGVmYXVsdHMgdG8gbmFtZVxuICAgIGhhc2hWYWx1ZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBoYXNoOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBpc1NvbGlkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBhcHBlYXJhbmNlOiBQcm9wVHlwZXMub25lT2Yoa2V5c0ZpbGxBcHBlYXJhbmNlcyksXG4gICAgZ2V0SW5pdGlhbHM6IFByb3BUeXBlcy5mdW5jLFxuICAgIC8vIEluIHNvbWUgY2FzZXMgR3JhdmF0YXIgcmV0dXJucyB0cmFuc3BhcmVudCBwbmdzXG4gICAgLy8gd2Ugc3RpbGwgd2FudCB0byBzZWUgdGhlIGluaXRpYWxzXG4gICAgZm9yY2VTaG93SW5pdGlhbHM6IFByb3BUeXBlcy5ib29sLFxuICAgIGhlaWdodExpbWl0T25lQ2hhcmFjdGVyOiBQcm9wVHlwZXMubnVtYmVyXG4gIH1cblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIHNpemU6IDI0LFxuICAgIGhhc2g6IGdsb2JhbEhhc2gsXG4gICAgaXNTb2xpZDogZmFsc2UsXG4gICAgZ2V0SW5pdGlhbHM6IGdsb2JhbEdldEluaXRpYWxzLFxuICAgIGZvcmNlU2hvd0luaXRpYWxzOiBmYWxzZSxcbiAgICBoZWlnaHRMaW1pdE9uZUNoYXJhY3RlcjogMjBcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KSB7XG4gICAgc3VwZXIocHJvcHMsIGNvbnRleHQpXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGltYWdlSGFzRmFpbGVkTG9hZGluZzogZmFsc2VcbiAgICB9XG4gIH1cblxuICBoYW5kbGVFcnJvciA9ICgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGltYWdlSGFzRmFpbGVkTG9hZGluZzogdHJ1ZVxuICAgIH0pXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3JjLFxuICAgICAgc2l6ZSxcbiAgICAgIG5hbWUsXG4gICAgICBoYXNoLFxuICAgICAgaXNTb2xpZCxcbiAgICAgIGhhc2hWYWx1ZTogcHJvcHNIYXNoVmFsdWUsXG4gICAgICBnZXRJbml0aWFscyxcbiAgICAgIHVzZUF1dG9Db2xvcixcbiAgICAgIGFwcGVhcmFuY2U6IHByb3BzQXBwZWFyYW5jZSxcbiAgICAgIGZvcmNlU2hvd0luaXRpYWxzLFxuICAgICAgaGVpZ2h0TGltaXRPbmVDaGFyYWN0ZXIsXG4gICAgICAuLi5wcm9wc1xuICAgIH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3QgeyBpbWFnZUhhc0ZhaWxlZExvYWRpbmcgfSA9IHRoaXMuc3RhdGVcbiAgICBjb25zdCBpbWFnZVVuYXZhaWxhYmxlID0gIXNyYyB8fCBpbWFnZUhhc0ZhaWxlZExvYWRpbmdcbiAgICBjb25zdCBpbml0aWFsc0ZvbnRTaXplID0gYCR7Z2V0SW5pdGlhbHNGb250U2l6ZShcbiAgICAgIHNpemUsXG4gICAgICBoZWlnaHRMaW1pdE9uZUNoYXJhY3RlclxuICAgICl9cHhgXG5cbiAgICBsZXQgaW5pdGlhbHMgPSBnZXRJbml0aWFscyhuYW1lKVxuICAgIGlmIChzaXplIDw9IGhlaWdodExpbWl0T25lQ2hhcmFjdGVyKSB7XG4gICAgICBpbml0aWFscyA9IGluaXRpYWxzLnN1YnN0cmluZygwLCAxKVxuICAgIH1cblxuICAgIGNvbnN0IGhhc2hWYWx1ZSA9IGhhc2gocHJvcHNIYXNoVmFsdWUgfHwgbmFtZSlcbiAgICBsZXQgYXBwZWFyYW5jZUtleSA9IHByb3BzQXBwZWFyYW5jZVxuICAgIGlmIChhcHBlYXJhbmNlS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGFwcGVhcmFuY2VLZXkgPVxuICAgICAgICBrZXlzRmlsbEFwcGVhcmFuY2VzW2hhc2hWYWx1ZSAlIGtleXNGaWxsQXBwZWFyYW5jZXMubGVuZ3RoXVxuICAgIH1cblxuICAgIGNvbnN0IGFwcGVhcmFuY2UgPVxuICAgICAgRmlsbEFwcGVhcmFuY2VzW2lzU29saWQgPyAnc29saWQnIDogJ2RlZmF1bHQnXVthcHBlYXJhbmNlS2V5XVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxCb3hcbiAgICAgICAgd2lkdGg9e3NpemV9XG4gICAgICAgIGhlaWdodD17c2l6ZX1cbiAgICAgICAgb3ZlcmZsb3c9XCJoaWRkZW5cIlxuICAgICAgICBib3JkZXJSYWRpdXM9ezk5OTl9XG4gICAgICAgIHBvc2l0aW9uPVwicmVsYXRpdmVcIlxuICAgICAgICBkaXNwbGF5PVwiaW5saW5lLWZsZXhcIlxuICAgICAgICBqdXN0aWZ5Q29udGVudD1cImNlbnRlclwiXG4gICAgICAgIGJhY2tncm91bmRDb2xvcj17Y29sb3JzLm5ldXRyYWxbJzMwMCddfVxuICAgICAgICB0aXRsZT17bmFtZX1cbiAgICAgICAgey4uLmFwcGVhcmFuY2V9XG4gICAgICAgIHsuLi5wcm9wc31cbiAgICAgID5cbiAgICAgICAgeyhpbWFnZVVuYXZhaWxhYmxlIHx8IGZvcmNlU2hvd0luaXRpYWxzKSAmJiAoXG4gICAgICAgICAgPFRleHRcbiAgICAgICAgICAgIGNzcz17aW5pdGlhbHNQcm9wc31cbiAgICAgICAgICAgIGZvbnRTaXplPXtpbml0aWFsc0ZvbnRTaXplfVxuICAgICAgICAgICAgbGluZUhlaWdodD17aW5pdGlhbHNGb250U2l6ZX1cbiAgICAgICAgICAgIHdpZHRoPXtzaXplfVxuICAgICAgICAgICAgaGVpZ2h0PXtzaXplfVxuICAgICAgICAgICAgY29sb3I9e2FwcGVhcmFuY2UuY29sb3J9XG4gICAgICAgICAgPlxuICAgICAgICAgICAge2luaXRpYWxzfVxuICAgICAgICAgIDwvVGV4dD5cbiAgICAgICAgKX1cbiAgICAgICAgeyFpbWFnZVVuYXZhaWxhYmxlICYmIChcbiAgICAgICAgICA8SW1hZ2VcbiAgICAgICAgICAgIHdpZHRoPVwiYXV0b1wiXG4gICAgICAgICAgICBoZWlnaHQ9XCIxMDAlXCJcbiAgICAgICAgICAgIHNyYz17c3JjfVxuICAgICAgICAgICAgb25FcnJvcj17dGhpcy5oYW5kbGVFcnJvcn1cbiAgICAgICAgICAvPlxuICAgICAgICApfVxuICAgICAgPC9Cb3g+XG4gICAgKVxuICB9XG59XG4iXX0=