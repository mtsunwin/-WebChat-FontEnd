var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import Box from 'ui-box';
import { Button } from '../../buttons';
import { TextInput } from '../../text-input';

export var CLASS_PREFIX = 'evergreen-file-picker';

var FilePicker = function (_PureComponent) {
  _inherits(FilePicker, _PureComponent);

  function FilePicker() {
    _classCallCheck(this, FilePicker);

    var _this = _possibleConstructorReturn(this, (FilePicker.__proto__ || Object.getPrototypeOf(FilePicker)).call(this));

    _this.fileInputRef = function (node) {
      _this.fileInput = node;
    };

    _this.handleFileChange = function (e) {
      var onChange = _this.props.onChange;
      // Firefox returns the same array instance each time for some reason

      var files = [].concat(_toConsumableArray(e.target.files));

      _this.setState({ files: files });

      if (onChange) {
        onChange(files);
      }
    };

    _this.handleButtonClick = function () {
      _this.fileInput.click();
    };

    _this.state = {
      files: []
    };
    return _this;
  }

  _createClass(FilePicker, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          name = _props.name,
          accept = _props.accept,
          required = _props.required,
          multiple = _props.multiple,
          disabled = _props.disabled,
          capture = _props.capture,
          height = _props.height,
          onChange = _props.onChange,
          props = _objectWithoutProperties(_props, ['name', 'accept', 'required', 'multiple', 'disabled', 'capture', 'height', 'onChange']);

      var files = this.state.files;


      var inputValue = void 0;
      if (files.length === 0) {
        inputValue = '';
      } else if (files.length === 1) {
        inputValue = files[0].name;
      } else {
        inputValue = files.length + ' files';
      }

      var buttonText = void 0;
      if (files.length === 0) {
        buttonText = 'Select file';
      } else if (files.length === 1) {
        buttonText = 'Replace file';
      } else {
        buttonText = 'Replace files';
      }

      return React.createElement(
        Box,
        _extends({ display: 'flex', className: CLASS_PREFIX + '-root' }, props),
        React.createElement(Box, {
          innerRef: this.fileInputRef,
          className: CLASS_PREFIX + '-file-input',
          is: 'input',
          type: 'file',
          name: name,
          accept: accept,
          required: required,
          multiple: multiple,
          disabled: disabled,
          capture: capture,
          onChange: this.handleFileChange,
          display: 'none'
        }),
        React.createElement(TextInput, {
          className: CLASS_PREFIX + '-text-input',
          readOnly: true,
          value: inputValue,
          placeholder: 'Select a file to upload\u2026'
          // There's a weird specifity issue when there's two differently sized inputs on the page
          , borderTopRightRadius: '0 !important',
          borderBottomRightRadius: '0 !important',
          height: height,
          flex: 1,
          textOverflow: 'ellipsis'
        }),
        React.createElement(
          Button,
          {
            className: CLASS_PREFIX + '-button',
            onClick: this.handleButtonClick,
            disabled: disabled,
            borderTopLeftRadius: 0,
            borderBottomLeftRadius: 0,
            height: height,
            flexShrink: 0
          },
          buttonText
        )
      );
    }
  }]);

  return FilePicker;
}(PureComponent);

FilePicker.propTypes = {
  name: PropTypes.string,
  accept: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),
  required: PropTypes.bool,
  multiple: PropTypes.bool,
  disabled: PropTypes.bool,
  capture: PropTypes.bool,
  height: PropTypes.number,
  onChange: PropTypes.func
};
export default FilePicker;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9maWxlLXBpY2tlci9zcmMvRmlsZVBpY2tlci5qcyJdLCJuYW1lcyI6WyJSZWFjdCIsIlB1cmVDb21wb25lbnQiLCJQcm9wVHlwZXMiLCJCb3giLCJCdXR0b24iLCJUZXh0SW5wdXQiLCJDTEFTU19QUkVGSVgiLCJGaWxlUGlja2VyIiwiZmlsZUlucHV0UmVmIiwiZmlsZUlucHV0Iiwibm9kZSIsImhhbmRsZUZpbGVDaGFuZ2UiLCJvbkNoYW5nZSIsInByb3BzIiwiZmlsZXMiLCJlIiwidGFyZ2V0Iiwic2V0U3RhdGUiLCJoYW5kbGVCdXR0b25DbGljayIsImNsaWNrIiwic3RhdGUiLCJuYW1lIiwiYWNjZXB0IiwicmVxdWlyZWQiLCJtdWx0aXBsZSIsImRpc2FibGVkIiwiY2FwdHVyZSIsImhlaWdodCIsImlucHV0VmFsdWUiLCJsZW5ndGgiLCJidXR0b25UZXh0IiwicHJvcFR5cGVzIiwic3RyaW5nIiwib25lT2ZUeXBlIiwiYXJyYXlPZiIsImJvb2wiLCJudW1iZXIiLCJmdW5jIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBLE9BQU9BLEtBQVAsSUFBZ0JDLGFBQWhCLFFBQXFDLE9BQXJDO0FBQ0EsT0FBT0MsU0FBUCxNQUFzQixZQUF0QjtBQUNBLE9BQU9DLEdBQVAsTUFBZ0IsUUFBaEI7QUFDQSxTQUFTQyxNQUFULFFBQXVCLGVBQXZCO0FBQ0EsU0FBU0MsU0FBVCxRQUEwQixrQkFBMUI7O0FBRUEsT0FBTyxJQUFNQyxlQUFlLHVCQUFyQjs7SUFFY0MsVTs7O0FBZW5CLHdCQUFjO0FBQUE7O0FBQUE7O0FBQUEsVUFxRmRDLFlBckZjLEdBcUZDLGdCQUFRO0FBQ3JCLFlBQUtDLFNBQUwsR0FBaUJDLElBQWpCO0FBQ0QsS0F2RmE7O0FBQUEsVUF5RmRDLGdCQXpGYyxHQXlGSyxhQUFLO0FBQUEsVUFDZEMsUUFEYyxHQUNELE1BQUtDLEtBREosQ0FDZEQsUUFEYztBQUV0Qjs7QUFDQSxVQUFNRSxxQ0FBWUMsRUFBRUMs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akJULFlBQVVyQixVQUFVaUMsSUFOSDtBQU9qQlgsWUFBVXRCLFVBQVVpQyxJQVBIO0FBUWpCVixZQUFVdkIsVUFBVWlDLElBUkg7QUFTakJULFdBQVN4QixVQUFVaUMsSUFURjtBQVVqQlIsVUFBUXpCLFVBQVVrQyxNQVZEO0FBV2pCeEIsWUFBVVYsVUFBVW1DO0FBWEgsQztlQURBOUIsVSIsImZpbGUiOiJGaWxlUGlja2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IFB1cmVDb21wb25lbnQgfSBmcm9tICdyZWFjdCdcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcydcbmltcG9ydCBCb3ggZnJvbSAndWktYm94J1xuaW1wb3J0IHsgQnV0dG9uIH0gZnJvbSAnLi4vLi4vYnV0dG9ucydcbmltcG9ydCB7IFRleHRJbnB1dCB9IGZyb20gJy4uLy4uL3RleHQtaW5wdXQnXG5cbmV4cG9ydCBjb25zdCBDTEFTU19QUkVGSVggPSAnZXZlcmdyZWVuLWZpbGUtcGlja2VyJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaWxlUGlja2VyIGV4dGVuZHMgUHVyZUNvbXBvbmVudCB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBhY2NlcHQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICAgICAgUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgIFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpXG4gICAgXSksXG4gICAgcmVxdWlyZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgIG11bHRpcGxlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgY2FwdHVyZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuY1xuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGZpbGVzOiBbXVxuICAgIH1cbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgYWNjZXB0LFxuICAgICAgcmVxdWlyZWQsXG4gICAgICBtdWx0aXBsZSxcbiAgICAgIGRpc2FibGVkLFxuICAgICAgY2FwdHVyZSxcbiAgICAgIGhlaWdodCxcbiAgICAgIG9uQ2hhbmdlLCAvLyBSZW1vdmUgb25DaGFuZ2UgZnJvbSBwcm9wc1xuICAgICAgLi4ucHJvcHNcbiAgICB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IHsgZmlsZXMgfSA9IHRoaXMuc3RhdGVcblxuICAgIGxldCBpbnB1dFZhbHVlXG4gICAgaWYgKGZpbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaW5wdXRWYWx1ZSA9ICcnXG4gICAgfSBlbHNlIGlmIChmaWxlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlucHV0VmFsdWUgPSBmaWxlc1swXS5uYW1lXG4gICAgfSBlbHNlIHtcbiAgICAgIGlucHV0VmFsdWUgPSBgJHtmaWxlcy5sZW5ndGh9IGZpbGVzYFxuICAgIH1cblxuICAgIGxldCBidXR0b25UZXh0XG4gICAgaWYgKGZpbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYnV0dG9uVGV4dCA9ICdTZWxlY3QgZmlsZSdcbiAgICB9IGVsc2UgaWYgKGZpbGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgYnV0dG9uVGV4dCA9ICdSZXBsYWNlIGZpbGUnXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1dHRvblRleHQgPSAnUmVwbGFjZSBmaWxlcydcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPEJveCBkaXNwbGF5PVwiZmxleFwiIGNsYXNzTmFtZT17YCR7Q0xBU1NfUFJFRklYfS1yb290YH0gey4uLnByb3BzfT5cbiAgICAgICAgPEJveFxuICAgICAgICAgIGlubmVyUmVmPXt0aGlzLmZpbGVJbnB1dFJlZn1cbiAgICAgICAgICBjbGFzc05hbWU9e2Ake0NMQVNTX1BSRUZJWH0tZmlsZS1pbnB1dGB9XG4gICAgICAgICAgaXM9XCJpbnB1dFwiXG4gICAgICAgICAgdHlwZT1cImZpbGVcIlxuICAgICAgICAgIG5hbWU9e25hbWV9XG4gICAgICAgICAgYWNjZXB0PXthY2NlcHR9XG4gICAgICAgICAgcmVxdWlyZWQ9e3JlcXVpcmVkfVxuICAgICAgICAgIG11bHRpcGxlPXttdWx0aXBsZX1cbiAgICAgICAgICBkaXNhYmxlZD17ZGlzYWJsZWR9XG4gICAgICAgICAgY2FwdHVyZT17Y2FwdHVyZX1cbiAgICAgICAgICBvbkNoYW5nZT17dGhpcy5oYW5kbGVGaWxlQ2hhbmdlfVxuICAgICAgICAgIGRpc3BsYXk9XCJub25lXCJcbiAgICAgICAgLz5cblxuICAgICAgICA8VGV4dElucHV0XG4gICAgICAgICAgY2xhc3NOYW1lPXtgJHtDTEFTU19QUkVGSVh9LXRleHQtaW5wdXRgfVxuICAgICAgICAgIHJlYWRPbmx5XG4gICAgICAgICAgdmFsdWU9e2lucHV0VmFsdWV9XG4gICAgICAgICAgcGxhY2Vob2xkZXI9XCJTZWxlY3QgYSBmaWxlIHRvIHVwbG9hZOKAplwiXG4gICAgICAgICAgLy8gVGhlcmUncyBhIHdlaXJkIHNwZWNpZml0eSBpc3N1ZSB3aGVuIHRoZXJlJ3MgdHdvIGRpZmZlcmVudGx5IHNpemVkIGlucHV0cyBvbiB0aGUgcGFnZVxuICAgICAgICAgIGJvcmRlclRvcFJpZ2h0UmFkaXVzPVwiMCAhaW1wb3J0YW50XCJcbiAgICAgICAgICBib3JkZXJCb3R0b21SaWdodFJhZGl1cz1cIjAgIWltcG9ydGFudFwiXG4gICAgICAgICAgaGVpZ2h0PXtoZWlnaHR9XG4gICAgICAgICAgZmxleD17MX1cbiAgICAgICAgICB0ZXh0T3ZlcmZsb3c9XCJlbGxpcHNpc1wiXG4gICAgICAgIC8+XG5cbiAgICAgICAgPEJ1dHRvblxuICAgICAgICAgIGNsYXNzTmFtZT17YCR7Q0xBU1NfUFJFRklYfS1idXR0b25gfVxuICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuaGFuZGxlQnV0dG9uQ2xpY2t9XG4gICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgICAgICAgIGJvcmRlclRvcExlZnRSYWRpdXM9ezB9XG4gICAgICAgICAgYm9yZGVyQm90dG9tTGVmdFJhZGl1cz17MH1cbiAgICAgICAgICBoZWlnaHQ9e2hlaWdodH1cbiAgICAgICAgICBmbGV4U2hyaW5rPXswfVxuICAgICAgICA+XG4gICAgICAgICAge2J1dHRvblRleHR9XG4gICAgICAgIDwvQnV0dG9uPlxuICAgICAgPC9Cb3g+XG4gICAgKVxuICB9XG5cbiAgZmlsZUlucHV0UmVmID0gbm9kZSA9PiB7XG4gICAgdGhpcy5maWxlSW5wdXQgPSBub2RlXG4gIH1cblxuICBoYW5kbGVGaWxlQ2hhbmdlID0gZSA9PiB7XG4gICAgY29uc3QgeyBvbkNoYW5nZSB9ID0gdGhpcy5wcm9wc1xuICAgIC8vIEZpcmVmb3ggcmV0dXJucyB0aGUgc2FtZSBhcnJheSBpbnN0YW5jZSBlYWNoIHRpbWUgZm9yIHNvbWUgcmVhc29uXG4gICAgY29uc3QgZmlsZXMgPSBbLi4uZS50YXJnZXQuZmlsZXNdXG5cbiAgICB0aGlzLnNldFN0YXRlKHsgZmlsZXMgfSlcblxuICAgIGlmIChvbkNoYW5nZSkge1xuICAgICAgb25DaGFuZ2UoZmlsZXMpXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlQnV0dG9uQ2xpY2sgPSAoKSA9PiB7XG4gICAgdGhpcy5maWxlSW5wdXQuY2xpY2soKVxuICB9XG59XG4iXX0=