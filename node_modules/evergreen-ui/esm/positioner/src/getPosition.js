import Position from './Position';

/**
 * Function to create a Rect.
 * @param {Object} dimensions
 * @param {Number} dimensions.width
 * @param {Number} dimensions.height
 * @param {Object} position
 * @param {Number} position.left
 * @param {Number} position.top
 * @return {Object} Rect { width, height, left, top, right, bottom }
 */
var makeRect = function makeRect(_ref, _ref2) {
  var width = _ref.width,
      height = _ref.height;
  var left = _ref2.left,
      top = _ref2.top;

  var ceiledLeft = Math.ceil(left);
  var ceiledTop = Math.ceil(top);
  return {
    width: width,
    height: height,
    left: ceiledLeft,
    top: ceiledTop,
    right: ceiledLeft + width,
    bottom: ceiledTop + height
  };
};

/**
 * Function to flip a position upside down.
 * @param {Position} position
 * @return {Position} flipped position
 */
var flipHorizontal = function flipHorizontal(position) {
  switch (position) {
    case Position.TOP_LEFT:
      return Position.BOTTOM_LEFT;
    case Position.TOP:
    default:
      return Position.BOTTOM;
    case Position.TOP_RIGHT:
      return Position.BOTTOM_RIGHT;
    case Position.BOTTOM_LEFT:
      return Position.TOP_LEFT;
    case Position.BOTTOM:
      return Position.TOP;
    case Position.BOTTOM_RIGHT:
      return Position.TOP_RIGHT;
  }
};

/**
 * Function that returns if position is aligned on top.
 * @param {Position} position
 * @return {Boolean}
 */
var isAlignedOnTop = function isAlignedOnTop(position) {
  switch (position) {
    case Position.TOP_LEFT:
    case Position.TOP:
    case Position.TOP_RIGHT:
      return true;
    default:
      return false;
  }
};

/**
 * Function that returns if a rect fits on bottom.
 * @param {Rect} rect
 * @param {Object} viewport
 * @param {Number} viewportOffset
 * @return {Boolean}
 */
var getFitsOnBottom = function getFitsOnBottom(rect, viewport, viewportOffset) {
  return rect.bottom < viewport.height - viewportOffset;
};

/**
 * Function that returns if a rect fits on top.
 * @param {Rect} rect
 * @param {Number} viewportOffset
 * @return {Boolean}
 */
var getFitsOnTop = function getFitsOnTop(rect, viewportOffset) {
  return rect.top > viewportOffset;
};

/**
 * Function that returns the CSS `tranform-origin` property.
 * @param {Rect} rect
 * @param {Position} position
 * @param {Number} targetCenter - center of the target.
 * @return {String} transform origin
 */
var getTransformOrigin = function getTransformOrigin(_ref3) {
  var rect = _ref3.rect,
      position = _ref3.position,
      targetCenter = _ref3.targetCenter;

  var center = Math.round(targetCenter - rect.left);
  if (isAlignedOnTop(position)) {
    return 'bottom ' + center + 'px';
  }
  return 'top ' + center + 'px';
};

/**
 * Function that takes in numbers and position and gives the final coords.
 * @param {Position} position — the position the positioner should be on.
 * @param {Object} dimensions — the dimensions of the positioner.
 * @param {Object} targetRect — the rect of the target.
 * @param {Number} targetOffset - offset from the target.
 * @param {Object} viewport - the width and height of the viewport.
 * @param {Object} viewportOffset - offset from the viewport.
 * @return {Object} - { x: Number, y: Number }
 */
export default function getFittedPosition(_ref4) {
  var position = _ref4.position,
      dimensions = _ref4.dimensions,
      targetRect = _ref4.targetRect,
      targetOffset = _ref4.targetOffset,
      viewport = _ref4.viewport,
      _ref4$viewportOffset = _ref4.viewportOffset,
      viewportOffset = _ref4$viewportOffset === undefined ? 8 : _ref4$viewportOffset;

  var targetCenter = targetRect.left + targetRect.width / 2;

  var _getPosition = getPosition({
    position: position,
    dimensions: dimensions,
    targetRect: targetRect,
    targetOffset: targetOffset,
    viewport: viewport,
    viewportOffset: viewportOffset
  }),
      rect = _getPosition.rect,
      finalPosition = _getPosition.position;

  // Push rect to the right if overflowing on the left side of the viewport.


  if (rect.left < viewportOffset) {
    rect.right += Math.ceil(Math.abs(rect.left - viewportOffset));
    rect.left = Math.ceil(viewportOffset);
  }

  // Push rect to the left if overflowing on the right side of the viewport.
  if (rect.right > viewport.width - viewportOffset) {
    var delta = Math.ceil(rect.right - (viewport.width - viewportOffset));
    rect.left -= delta;
    rect.right -= delta;
  }

  var transformOrigin = getTransformOrigin({
    rect: rect,
    position: finalPosition,
    targetCenter: targetCenter
  });

  return {
    rect: rect,
    position: finalPosition,
    transformOrigin: transformOrigin
  };
}

/**
 * Function that takes in numbers and position and gives the final coords.
 * @param {Position} position — the position the positioner should be on.
 * @param {Object} dimensions — the dimensions of the positioner.
 * @param {Object} targetRect — the rect of the target.
 * @param {Number} targetOffset - offset from the target.
 * @param {Object} viewport - the width and height of the viewport.
 * @param {Object} viewportOffset - offset from the viewport.
 * @return {Object} - { rect: Rect, position: Position }
 */
function getPosition(_ref5) {
  var position = _ref5.position,
      dimensions = _ref5.dimensions,
      targetRect = _ref5.targetRect,
      targetOffset = _ref5.targetOffset,
      viewport = _ref5.viewport,
      _ref5$viewportOffset = _ref5.viewportOffset,
      viewportOffset = _ref5$viewportOffset === undefined ? 8 : _ref5$viewportOffset;

  var positionIsAlignedOnTop = isAlignedOnTop(position);
  var topRect = void 0;
  var bottomRect = void 0;

  if (positionIsAlignedOnTop) {
    topRect = getRect({
      position: position,
      dimensions: dimensions,
      targetRect: targetRect,
      targetOffset: targetOffset
    });
    bottomRect = getRect({
      position: flipHorizontal(position),
      dimensions: dimensions,
      targetRect: targetRect,
      targetOffset: targetOffset
    });
  } else {
    topRect = getRect({
      position: flipHorizontal(position),
      dimensions: dimensions,
      targetRect: targetRect,
      targetOffset: targetOffset
    });
    bottomRect = getRect({
      position: position,
      dimensions: dimensions,
      targetRect: targetRect,
      targetOffset: targetOffset
    });
  }

  var topRectFitsOnTop = getFitsOnTop(topRect, viewportOffset);
  var bottomRectFitsOnBottom = getFitsOnBottom(bottomRect, viewport, viewportOffset);

  if (positionIsAlignedOnTop && topRectFitsOnTop) {
    return {
      position: position,
      rect: topRect
    };
  }

  if (!positionIsAlignedOnTop) {
    if (bottomRectFitsOnBottom) {
      return {
        position: position,
        rect: bottomRect
      };
    } else if (topRectFitsOnTop) {
      return {
        position: flipHorizontal(position),
        rect: topRect
      };
    }
  }

  // Default to most spacious if there is no fit.
  var spaceBottom = Math.abs(viewport.height - viewportOffset - bottomRect.bottom);
  var spaceTop = Math.abs(topRect.top - viewportOffset);

  if (spaceBottom < spaceTop) {
    return {
      position: positionIsAlignedOnTop ? flipHorizontal(position) : position,
      rect: bottomRect
    };
  }

  return {
    position: positionIsAlignedOnTop ? position : flipHorizontal(position),
    rect: topRect
  };
}

/**
 * Function that takes in numbers and position and gives the final coords.
 * @param {Object} position - the width and height of the viewport.
 * @param {Number} targetOffset - offset from the target.
 * @param {Object} dimensions — the dimensions of the positioner.
 * @param {Object} targetRect — the rect of the target.
 * @return {Object} - { x: Number, y: Number }
 */
function getRect(_ref6) {
  var position = _ref6.position,
      targetOffset = _ref6.targetOffset,
      dimensions = _ref6.dimensions,
      targetRect = _ref6.targetRect;

  var leftRect = targetRect.left + targetRect.width / 2 - dimensions.width / 2;
  var alignedTopY = targetRect.top - dimensions.height - targetOffset;
  var alignedBottomY = targetRect.bottom + targetOffset;
  var alignedRightX = targetRect.right - dimensions.width;

  switch (position) {
    case Position.TOP:
      return makeRect(dimensions, {
        left: leftRect,
        top: alignedTopY
      });
    case Position.TOP_LEFT:
      return makeRect(dimensions, {
        left: targetRect.left,
        top: alignedTopY
      });
    case Position.TOP_RIGHT:
      return makeRect(dimensions, {
        left: alignedRightX,
        top: alignedTopY
      });
    default:
    case Position.BOTTOM:
      return makeRect(dimensions, {
        left: leftRect,
        top: alignedBottomY
      });
    case Position.BOTTOM_LEFT:
      return makeRect(dimensions, {
        left: targetRect.left,
        top: alignedBottomY
      });
    case Position.BOTTOM_RIGHT:
      return makeRect(dimensions, {
        left: alignedRightX,
        top: alignedBottomY
      });
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wb3NpdGlvbmVyL3NyYy9nZXRQb3NpdGlvbi5qcyJdLCJuYW1lcyI6WyJQb3NpdGlvbiIsIm1ha2VSZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJsZWZ0IiwidG9wIiwiY2VpbGVkTGVmdCIsIk1hdGgiLCJjZWlsIiwiY2VpbGVkVG9wIiwicmlnaHQiLCJib3R0b20iLCJmbGlwSG9yaXpvbnRhbCIsInBvc2l0aW9uIiwiVE9QX0xFRlQiLCJCT1RUT01fTEVGVCIsIlRPUCIsIkJPVFRPTSIsIlRPUF9SSUdIVCIsIkJPVFRPTV9SSUdIVCIsImlzQWxpZ25lZE9uVG9wIiwiZ2V0Rml0c09uQm90dG9tIiwicmVjdCIsInZpZXdwb3J0Iiwidmlld3BvcnRPZmZzZXQiLCJnZXRGaXRzT25Ub3AiLCJnZXRUcmFuc2Zvcm1PcmlnaW4iLCJ0YXJnZXRDZW50ZXIiLCJjZW50ZXIiLCJyb3VuZCIsImdldEZpdHRlZFBvc2l0aW9uIiwiZGltZW5zaW9ucyIsInRhcmdldFJlY3QiLCJ0YXJnZXRPZmZzZXQiLCJnZXRQb3NpdGlvbiIsImZpbmFsUG9zaXRpb24iLCJhYnMiLCJkZWx0YSIsInRyYW5zZm9ybU9yaWdpbiIsInBvc2l0aW9uSXNBbGlnbmVkT25Ub3AiLCJ0b3BSZWN0IiwiYm90dG9tUmVjdCIsImdldFJlY3QiLCJ0b3BSZWN0Rml0c09uVG9wIiwiYm90dG9tUmVjdEZpdHNPbkJvdHRvbSIsInNwYWNlQm90dG9tIiwic3BhY2VUb3AiLCJsZWZ0UmVjdCIsImFsaWduZWRUb3BZIiwiYWxpZ25lZEJvdHRvbVkiLCJhbGlnbmVkUmlnaHRYIl0sIm1hcHBpbmdzIjoiQUFBQSxPQUFPQSxRQUFQLE1BQXFCLFlBQXJCOztBQUVBOzs7Ozs7Ozs7O0FBVUEsSUFBTUMsV0FBVyxTQUFYQSxRQUFXLGNBQXNDO0FBQUEsTUFBbkNDLEtBQW1DLFFBQW5DQSxLQUFtQztBQUFBLE1BQTVCQyxNQUE0QixRQUE1QkEsTUFBNEI7QUFBQSxNQUFoQkMsSUFBZ0IsU0FB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QUFXNUIsSUFEUztBQUUxQkMsYUFBSzJDO0FBRnFCLE9BQXJCLENBQVA7QUFJRixTQUFLaEQsU0FBU2tCLFNBQWQ7QUFDRSxhQUFPakIsU0FBUzhCLFVBQVQsRUFBcUI7QUFDMUIzQixjQUFNOEMsYUFEb0I7QUFFMUI3QyxhQUFLMkM7QUFGcUIsT0FBckIsQ0FBUDtBQUlGO0FBQ0EsU0FBS2hELFNBQVNpQixNQUFkO0FBQ0UsYUFBT2hCLFNBQVM4QixVQUFULEVBQXFCO0FBQzFCM0IsY0FBTTJDLFFBRG9CO0FBRTFCMUMsYUFBSzRDO0FBRnFCLE9BQXJCLENBQVA7QUFJRixTQUFLakQsU0FBU2UsV0FBZDtBQUNFLGFBQU9kLFNBQVM4QixVQUFULEVBQXFCO0FBQzFCM0IsY0FBTTRCLFdBQVc1QixJQURTO0FBRTFCQyxhQUFLNEM7QUFGcUIsT0FBckIsQ0FBUDtBQUlGLFNBQUtqRCxTQUFTbUIsWUFBZDtBQUNFLGFBQU9sQixTQUFTOEIsVUFBVCxFQUFxQjtBQUMxQjNCLGNBQU04QyxhQURvQjtBQUUxQjdDLGFBQUs0QztBQUZxQixPQUFyQixDQUFQO0FBNUJKO0FBaUNEIiwiZmlsZSI6ImdldFBvc2l0aW9uLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFBvc2l0aW9uIGZyb20gJy4vUG9zaXRpb24nXG5cbi8qKlxuICogRnVuY3Rpb24gdG8gY3JlYXRlIGEgUmVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkaW1lbnNpb25zXG4gKiBAcGFyYW0ge051bWJlcn0gZGltZW5zaW9ucy53aWR0aFxuICogQHBhcmFtIHtOdW1iZXJ9IGRpbWVuc2lvbnMuaGVpZ2h0XG4gKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbi5sZWZ0XG4gKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24udG9wXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJlY3QgeyB3aWR0aCwgaGVpZ2h0LCBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b20gfVxuICovXG5jb25zdCBtYWtlUmVjdCA9ICh7IHdpZHRoLCBoZWlnaHQgfSwgeyBsZWZ0LCB0b3AgfSkgPT4ge1xuICBjb25zdCBjZWlsZWRMZWZ0ID0gTWF0aC5jZWlsKGxlZnQpXG4gIGNvbnN0IGNlaWxlZFRvcCA9IE1hdGguY2VpbCh0b3ApXG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGxlZnQ6IGNlaWxlZExlZnQsXG4gICAgdG9wOiBjZWlsZWRUb3AsXG4gICAgcmlnaHQ6IGNlaWxlZExlZnQgKyB3aWR0aCxcbiAgICBib3R0b206IGNlaWxlZFRvcCArIGhlaWdodFxuICB9XG59XG5cbi8qKlxuICogRnVuY3Rpb24gdG8gZmxpcCBhIHBvc2l0aW9uIHVwc2lkZSBkb3duLlxuICogQHBhcmFtIHtQb3NpdGlvbn0gcG9zaXRpb25cbiAqIEByZXR1cm4ge1Bvc2l0aW9ufSBmbGlwcGVkIHBvc2l0aW9uXG4gKi9cbmNvbnN0IGZsaXBIb3Jpem9udGFsID0gcG9zaXRpb24gPT4ge1xuICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgY2FzZSBQb3NpdGlvbi5UT1BfTEVGVDpcbiAgICAgIHJldHVybiBQb3NpdGlvbi5CT1RUT01fTEVGVFxuICAgIGNhc2UgUG9zaXRpb24uVE9QOlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gUG9zaXRpb24uQk9UVE9NXG4gICAgY2FzZSBQb3NpdGlvbi5UT1BfUklHSFQ6XG4gICAgICByZXR1cm4gUG9zaXRpb24uQk9UVE9NX1JJR0hUXG4gICAgY2FzZSBQb3NpdGlvbi5CT1RUT01fTEVGVDpcbiAgICAgIHJldHVybiBQb3NpdGlvbi5UT1BfTEVGVFxuICAgIGNhc2UgUG9zaXRpb24uQk9UVE9NOlxuICAgICAgcmV0dXJuIFBvc2l0aW9uLlRPUFxuICAgIGNhc2UgUG9zaXRpb24uQk9UVE9NX1JJR0hUOlxuICAgICAgcmV0dXJuIFBvc2l0aW9uLlRPUF9SSUdIVFxuICB9XG59XG5cbi8qKlxuICogRnVuY3Rpb24gdGhhdCByZXR1cm5zIGlmIHBvc2l0aW9uIGlzIGFsaWduZWQgb24gdG9wLlxuICogQHBhcmFtIHtQb3NpdGlvbn0gcG9zaXRpb25cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzQWxpZ25lZE9uVG9wID0gcG9zaXRpb24gPT4ge1xuICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgY2FzZSBQb3NpdGlvbi5UT1BfTEVGVDpcbiAgICBjYXNlIFBvc2l0aW9uLlRPUDpcbiAgICBjYXNlIFBvc2l0aW9uLlRPUF9SSUdIVDpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8qKlxuICogRnVuY3Rpb24gdGhhdCByZXR1cm5zIGlmIGEgcmVjdCBmaXRzIG9uIGJvdHRvbS5cbiAqIEBwYXJhbSB7UmVjdH0gcmVjdFxuICogQHBhcmFtIHtPYmplY3R9IHZpZXdwb3J0XG4gKiBAcGFyYW0ge051bWJlcn0gdmlld3BvcnRPZmZzZXRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmNvbnN0IGdldEZpdHNPbkJvdHRvbSA9IChyZWN0LCB2aWV3cG9ydCwgdmlld3BvcnRPZmZzZXQpID0+IHtcbiAgcmV0dXJuIHJlY3QuYm90dG9tIDwgdmlld3BvcnQuaGVpZ2h0IC0gdmlld3BvcnRPZmZzZXRcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB0aGF0IHJldHVybnMgaWYgYSByZWN0IGZpdHMgb24gdG9wLlxuICogQHBhcmFtIHtSZWN0fSByZWN0XG4gKiBAcGFyYW0ge051bWJlcn0gdmlld3BvcnRPZmZzZXRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmNvbnN0IGdldEZpdHNPblRvcCA9IChyZWN0LCB2aWV3cG9ydE9mZnNldCkgPT4ge1xuICByZXR1cm4gcmVjdC50b3AgPiB2aWV3cG9ydE9mZnNldFxufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgQ1NTIGB0cmFuZm9ybS1vcmlnaW5gIHByb3BlcnR5LlxuICogQHBhcmFtIHtSZWN0fSByZWN0XG4gKiBAcGFyYW0ge1Bvc2l0aW9ufSBwb3NpdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHRhcmdldENlbnRlciAtIGNlbnRlciBvZiB0aGUgdGFyZ2V0LlxuICogQHJldHVybiB7U3RyaW5nfSB0cmFuc2Zvcm0gb3JpZ2luXG4gKi9cbmNvbnN0IGdldFRyYW5zZm9ybU9yaWdpbiA9ICh7IHJlY3QsIHBvc2l0aW9uLCB0YXJnZXRDZW50ZXIgfSkgPT4ge1xuICBjb25zdCBjZW50ZXIgPSBNYXRoLnJvdW5kKHRhcmdldENlbnRlciAtIHJlY3QubGVmdClcbiAgaWYgKGlzQWxpZ25lZE9uVG9wKHBvc2l0aW9uKSkge1xuICAgIHJldHVybiBgYm90dG9tICR7Y2VudGVyfXB4YFxuICB9XG4gIHJldHVybiBgdG9wICR7Y2VudGVyfXB4YFxufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHRoYXQgdGFrZXMgaW4gbnVtYmVycyBhbmQgcG9zaXRpb24gYW5kIGdpdmVzIHRoZSBmaW5hbCBjb29yZHMuXG4gKiBAcGFyYW0ge1Bvc2l0aW9ufSBwb3NpdGlvbiDigJQgdGhlIHBvc2l0aW9uIHRoZSBwb3NpdGlvbmVyIHNob3VsZCBiZSBvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkaW1lbnNpb25zIOKAlCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgcG9zaXRpb25lci5cbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRSZWN0IOKAlCB0aGUgcmVjdCBvZiB0aGUgdGFyZ2V0LlxuICogQHBhcmFtIHtOdW1iZXJ9IHRhcmdldE9mZnNldCAtIG9mZnNldCBmcm9tIHRoZSB0YXJnZXQuXG4gKiBAcGFyYW0ge09iamVjdH0gdmlld3BvcnQgLSB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgdmlld3BvcnQuXG4gKiBAcGFyYW0ge09iamVjdH0gdmlld3BvcnRPZmZzZXQgLSBvZmZzZXQgZnJvbSB0aGUgdmlld3BvcnQuXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0geyB4OiBOdW1iZXIsIHk6IE51bWJlciB9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEZpdHRlZFBvc2l0aW9uKHtcbiAgcG9zaXRpb24sXG4gIGRpbWVuc2lvbnMsXG4gIHRhcmdldFJlY3QsXG4gIHRhcmdldE9mZnNldCxcbiAgdmlld3BvcnQsXG4gIHZpZXdwb3J0T2Zmc2V0ID0gOFxufSkge1xuICBjb25zdCB0YXJnZXRDZW50ZXIgPSB0YXJnZXRSZWN0LmxlZnQgKyB0YXJnZXRSZWN0LndpZHRoIC8gMlxuXG4gIGNvbnN0IHsgcmVjdCwgcG9zaXRpb246IGZpbmFsUG9zaXRpb24gfSA9IGdldFBvc2l0aW9uKHtcbiAgICBwb3NpdGlvbixcbiAgICBkaW1lbnNpb25zLFxuICAgIHRhcmdldFJlY3QsXG4gICAgdGFyZ2V0T2Zmc2V0LFxuICAgIHZpZXdwb3J0LFxuICAgIHZpZXdwb3J0T2Zmc2V0XG4gIH0pXG5cbiAgLy8gUHVzaCByZWN0IHRvIHRoZSByaWdodCBpZiBvdmVyZmxvd2luZyBvbiB0aGUgbGVmdCBzaWRlIG9mIHRoZSB2aWV3cG9ydC5cbiAgaWYgKHJlY3QubGVmdCA8IHZpZXdwb3J0T2Zmc2V0KSB7XG4gICAgcmVjdC5yaWdodCArPSBNYXRoLmNlaWwoTWF0aC5hYnMocmVjdC5sZWZ0IC0gdmlld3BvcnRPZmZzZXQpKVxuICAgIHJlY3QubGVmdCA9IE1hdGguY2VpbCh2aWV3cG9ydE9mZnNldClcbiAgfVxuXG4gIC8vIFB1c2ggcmVjdCB0byB0aGUgbGVmdCBpZiBvdmVyZmxvd2luZyBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgdmlld3BvcnQuXG4gIGlmIChyZWN0LnJpZ2h0ID4gdmlld3BvcnQud2lkdGggLSB2aWV3cG9ydE9mZnNldCkge1xuICAgIGNvbnN0IGRlbHRhID0gTWF0aC5jZWlsKHJlY3QucmlnaHQgLSAodmlld3BvcnQud2lkdGggLSB2aWV3cG9ydE9mZnNldCkpXG4gICAgcmVjdC5sZWZ0IC09IGRlbHRhXG4gICAgcmVjdC5yaWdodCAtPSBkZWx0YVxuICB9XG5cbiAgY29uc3QgdHJhbnNmb3JtT3JpZ2luID0gZ2V0VHJhbnNmb3JtT3JpZ2luKHtcbiAgICByZWN0LFxuICAgIHBvc2l0aW9uOiBmaW5hbFBvc2l0aW9uLFxuICAgIHRhcmdldENlbnRlclxuICB9KVxuXG4gIHJldHVybiB7XG4gICAgcmVjdCxcbiAgICBwb3NpdGlvbjogZmluYWxQb3NpdGlvbixcbiAgICB0cmFuc2Zvcm1PcmlnaW5cbiAgfVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHRoYXQgdGFrZXMgaW4gbnVtYmVycyBhbmQgcG9zaXRpb24gYW5kIGdpdmVzIHRoZSBmaW5hbCBjb29yZHMuXG4gKiBAcGFyYW0ge1Bvc2l0aW9ufSBwb3NpdGlvbiDigJQgdGhlIHBvc2l0aW9uIHRoZSBwb3NpdGlvbmVyIHNob3VsZCBiZSBvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkaW1lbnNpb25zIOKAlCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgcG9zaXRpb25lci5cbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRSZWN0IOKAlCB0aGUgcmVjdCBvZiB0aGUgdGFyZ2V0LlxuICogQHBhcmFtIHtOdW1iZXJ9IHRhcmdldE9mZnNldCAtIG9mZnNldCBmcm9tIHRoZSB0YXJnZXQuXG4gKiBAcGFyYW0ge09iamVjdH0gdmlld3BvcnQgLSB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgdmlld3BvcnQuXG4gKiBAcGFyYW0ge09iamVjdH0gdmlld3BvcnRPZmZzZXQgLSBvZmZzZXQgZnJvbSB0aGUgdmlld3BvcnQuXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0geyByZWN0OiBSZWN0LCBwb3NpdGlvbjogUG9zaXRpb24gfVxuICovXG5mdW5jdGlvbiBnZXRQb3NpdGlvbih7XG4gIHBvc2l0aW9uLFxuICBkaW1lbnNpb25zLFxuICB0YXJnZXRSZWN0LFxuICB0YXJnZXRPZmZzZXQsXG4gIHZpZXdwb3J0LFxuICB2aWV3cG9ydE9mZnNldCA9IDhcbn0pIHtcbiAgY29uc3QgcG9zaXRpb25Jc0FsaWduZWRPblRvcCA9IGlzQWxpZ25lZE9uVG9wKHBvc2l0aW9uKVxuICBsZXQgdG9wUmVjdFxuICBsZXQgYm90dG9tUmVjdFxuXG4gIGlmIChwb3NpdGlvbklzQWxpZ25lZE9uVG9wKSB7XG4gICAgdG9wUmVjdCA9IGdldFJlY3Qoe1xuICAgICAgcG9zaXRpb24sXG4gICAgICBkaW1lbnNpb25zLFxuICAgICAgdGFyZ2V0UmVjdCxcbiAgICAgIHRhcmdldE9mZnNldFxuICAgIH0pXG4gICAgYm90dG9tUmVjdCA9IGdldFJlY3Qoe1xuICAgICAgcG9zaXRpb246IGZsaXBIb3Jpem9udGFsKHBvc2l0aW9uKSxcbiAgICAgIGRpbWVuc2lvbnMsXG4gICAgICB0YXJnZXRSZWN0LFxuICAgICAgdGFyZ2V0T2Zmc2V0XG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICB0b3BSZWN0ID0gZ2V0UmVjdCh7XG4gICAgICBwb3NpdGlvbjogZmxpcEhvcml6b250YWwocG9zaXRpb24pLFxuICAgICAgZGltZW5zaW9ucyxcbiAgICAgIHRhcmdldFJlY3QsXG4gICAgICB0YXJnZXRPZmZzZXRcbiAgICB9KVxuICAgIGJvdHRvbVJlY3QgPSBnZXRSZWN0KHtcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgZGltZW5zaW9ucyxcbiAgICAgIHRhcmdldFJlY3QsXG4gICAgICB0YXJnZXRPZmZzZXRcbiAgICB9KVxuICB9XG5cbiAgY29uc3QgdG9wUmVjdEZpdHNPblRvcCA9IGdldEZpdHNPblRvcCh0b3BSZWN0LCB2aWV3cG9ydE9mZnNldClcbiAgY29uc3QgYm90dG9tUmVjdEZpdHNPbkJvdHRvbSA9IGdldEZpdHNPbkJvdHRvbShcbiAgICBib3R0b21SZWN0LFxuICAgIHZpZXdwb3J0LFxuICAgIHZpZXdwb3J0T2Zmc2V0XG4gIClcblxuICBpZiAocG9zaXRpb25Jc0FsaWduZWRPblRvcCAmJiB0b3BSZWN0Rml0c09uVG9wKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgcmVjdDogdG9wUmVjdFxuICAgIH1cbiAgfVxuXG4gIGlmICghcG9zaXRpb25Jc0FsaWduZWRPblRvcCkge1xuICAgIGlmIChib3R0b21SZWN0Rml0c09uQm90dG9tKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgcmVjdDogYm90dG9tUmVjdFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodG9wUmVjdEZpdHNPblRvcCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcG9zaXRpb246IGZsaXBIb3Jpem9udGFsKHBvc2l0aW9uKSxcbiAgICAgICAgcmVjdDogdG9wUmVjdFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIERlZmF1bHQgdG8gbW9zdCBzcGFjaW91cyBpZiB0aGVyZSBpcyBubyBmaXQuXG4gIGNvbnN0IHNwYWNlQm90dG9tID0gTWF0aC5hYnMoXG4gICAgdmlld3BvcnQuaGVpZ2h0IC0gdmlld3BvcnRPZmZzZXQgLSBib3R0b21SZWN0LmJvdHRvbVxuICApXG4gIGNvbnN0IHNwYWNlVG9wID0gTWF0aC5hYnModG9wUmVjdC50b3AgLSB2aWV3cG9ydE9mZnNldClcblxuICBpZiAoc3BhY2VCb3R0b20gPCBzcGFjZVRvcCkge1xuICAgIHJldHVybiB7XG4gICAgICBwb3NpdGlvbjogcG9zaXRpb25Jc0FsaWduZWRPblRvcCA/IGZsaXBIb3Jpem9udGFsKHBvc2l0aW9uKSA6IHBvc2l0aW9uLFxuICAgICAgcmVjdDogYm90dG9tUmVjdFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcG9zaXRpb246IHBvc2l0aW9uSXNBbGlnbmVkT25Ub3AgPyBwb3NpdGlvbiA6IGZsaXBIb3Jpem9udGFsKHBvc2l0aW9uKSxcbiAgICByZWN0OiB0b3BSZWN0XG4gIH1cbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB0aGF0IHRha2VzIGluIG51bWJlcnMgYW5kIHBvc2l0aW9uIGFuZCBnaXZlcyB0aGUgZmluYWwgY29vcmRzLlxuICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uIC0gdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHZpZXdwb3J0LlxuICogQHBhcmFtIHtOdW1iZXJ9IHRhcmdldE9mZnNldCAtIG9mZnNldCBmcm9tIHRoZSB0YXJnZXQuXG4gKiBAcGFyYW0ge09iamVjdH0gZGltZW5zaW9ucyDigJQgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIHBvc2l0aW9uZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0UmVjdCDigJQgdGhlIHJlY3Qgb2YgdGhlIHRhcmdldC5cbiAqIEByZXR1cm4ge09iamVjdH0gLSB7IHg6IE51bWJlciwgeTogTnVtYmVyIH1cbiAqL1xuZnVuY3Rpb24gZ2V0UmVjdCh7IHBvc2l0aW9uLCB0YXJnZXRPZmZzZXQsIGRpbWVuc2lvbnMsIHRhcmdldFJlY3QgfSkge1xuICBjb25zdCBsZWZ0UmVjdCA9IHRhcmdldFJlY3QubGVmdCArIHRhcmdldFJlY3Qud2lkdGggLyAyIC0gZGltZW5zaW9ucy53aWR0aCAvIDJcbiAgY29uc3QgYWxpZ25lZFRvcFkgPSB0YXJnZXRSZWN0LnRvcCAtIGRpbWVuc2lvbnMuaGVpZ2h0IC0gdGFyZ2V0T2Zmc2V0XG4gIGNvbnN0IGFsaWduZWRCb3R0b21ZID0gdGFyZ2V0UmVjdC5ib3R0b20gKyB0YXJnZXRPZmZzZXRcbiAgY29uc3QgYWxpZ25lZFJpZ2h0WCA9IHRhcmdldFJlY3QucmlnaHQgLSBkaW1lbnNpb25zLndpZHRoXG5cbiAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgIGNhc2UgUG9zaXRpb24uVE9QOlxuICAgICAgcmV0dXJuIG1ha2VSZWN0KGRpbWVuc2lvbnMsIHtcbiAgICAgICAgbGVmdDogbGVmdFJlY3QsXG4gICAgICAgIHRvcDogYWxpZ25lZFRvcFlcbiAgICAgIH0pXG4gICAgY2FzZSBQb3NpdGlvbi5UT1BfTEVGVDpcbiAgICAgIHJldHVybiBtYWtlUmVjdChkaW1lbnNpb25zLCB7XG4gICAgICAgIGxlZnQ6IHRhcmdldFJlY3QubGVmdCxcbiAgICAgICAgdG9wOiBhbGlnbmVkVG9wWVxuICAgICAgfSlcbiAgICBjYXNlIFBvc2l0aW9uLlRPUF9SSUdIVDpcbiAgICAgIHJldHVybiBtYWtlUmVjdChkaW1lbnNpb25zLCB7XG4gICAgICAgIGxlZnQ6IGFsaWduZWRSaWdodFgsXG4gICAgICAgIHRvcDogYWxpZ25lZFRvcFlcbiAgICAgIH0pXG4gICAgZGVmYXVsdDpcbiAgICBjYXNlIFBvc2l0aW9uLkJPVFRPTTpcbiAgICAgIHJldHVybiBtYWtlUmVjdChkaW1lbnNpb25zLCB7XG4gICAgICAgIGxlZnQ6IGxlZnRSZWN0LFxuICAgICAgICB0b3A6IGFsaWduZWRCb3R0b21ZXG4gICAgICB9KVxuICAgIGNhc2UgUG9zaXRpb24uQk9UVE9NX0xFRlQ6XG4gICAgICByZXR1cm4gbWFrZVJlY3QoZGltZW5zaW9ucywge1xuICAgICAgICBsZWZ0OiB0YXJnZXRSZWN0LmxlZnQsXG4gICAgICAgIHRvcDogYWxpZ25lZEJvdHRvbVlcbiAgICAgIH0pXG4gICAgY2FzZSBQb3NpdGlvbi5CT1RUT01fUklHSFQ6XG4gICAgICByZXR1cm4gbWFrZVJlY3QoZGltZW5zaW9ucywge1xuICAgICAgICBsZWZ0OiBhbGlnbmVkUmlnaHRYLFxuICAgICAgICB0b3A6IGFsaWduZWRCb3R0b21ZXG4gICAgICB9KVxuICB9XG59XG4iXX0=