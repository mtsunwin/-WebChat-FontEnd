var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import fuzzaldrin from 'fuzzaldrin-plus';
import Downshift from 'downshift';
import VirtualList from 'react-tiny-virtual-list';
import { Popover } from '../../popover';
import { Position } from '../../positioner';
import { Text } from '../../typography';
import { Pane } from '../../layers';
import AutocompleteItem from './AutocompleteItem';

var fuzzyFilter = function fuzzyFilter(items, input) {
  return fuzzaldrin.filter(items, input);
};

var autocompleteItemRenderer = function autocompleteItemRenderer(props) {
  return React.createElement(AutocompleteItem, props);
};

// https://github.com/paypal/downshift/issues/164

var Autocomplete = function (_PureComponent) {
  _inherits(Autocomplete, _PureComponent);

  function Autocomplete() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, Autocomplete);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Autocomplete.__proto__ || Object.getPrototypeOf(Autocomplete)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      targetWidth: 0
    }, _this.renderResults = function (_ref2) {
      var width = _ref2.width,
          inputValue = _ref2.inputValue,
          highlightedIndex = _ref2.highlightedIndex,
          selectItemAtIndex = _ref2.selectItemAtIndex,
          selectedItem = _ref2.selectedItem,
          getItemProps = _ref2.getItemProps;
      var _this$props = _this.props,
          title = _this$props.title,
          itemSize = _this$props.itemSize,
          itemsFilter = _this$props.itemsFilter,
          originalItems = _this$props.items,
          itemToString = _this$props.itemToString,
          _renderItem = _this$props.renderItem,
          popoverMaxHeight = _this$props.popoverMaxHeight,
          isFilterDisabled = _this$props.isFilterDisabled;


      var items = isFilterDisabled || inputValue.trim() === '' ? originalItems : itemsFilter(originalItems, inputValue);

      if (items.length === 0) return null;

      return React.createElement(
        Pane,
        { width: width },
        title && React.createElement(
          Pane,
          { padding: 8, borderBottom: 'extraMuted' },
          React.createElement(
            Text,
            { size: 200, color: 'muted', isUppercase: true },
            title
          )
        ),
        items.length > 0 && React.createElement(VirtualList, {
          width: '100%',
          height: Math.min(items.length * itemSize, popoverMaxHeight),
          itemSize: itemSize,
          itemCount: items.length,
          scrollToIndex: highlightedIndex || 0,
          overscanCount: 3,
          scrollToAlignment: 'auto',
          renderItem: function renderItem(_ref3) {
            var index = _ref3.index,
                style = _ref3.style;

            var item = items[index];
            var itemString = itemToString(item);
            return _renderItem(getItemProps({
              item: item,
              key: itemString,
              index: index,
              style: style,
              children: itemString,
              onMouseUp: function onMouseUp() {
                selectItemAtIndex(index);
              },
              isSelected: itemToString(selectedItem) === itemString,
              isHighlighted: highlightedIndex === index
            }));
          }
        })
      );
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Autocomplete, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.setState({
        targetWidth: this.targetRef.getBoundingClientRect().width
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          children = _props.children,
          itemSize = _props.itemSize,
          position = _props.position,
          renderItem = _props.renderItem,
          itemsFilter = _props.itemsFilter,
          popoverMaxHeight = _props.popoverMaxHeight,
          popoverMinWidth = _props.popoverMinWidth,
          defaultSelectedItem = _props.defaultSelectedItem,
          props = _objectWithoutProperties(_props, ['children', 'itemSize', 'position', 'renderItem', 'itemsFilter', 'popoverMaxHeight', 'popoverMinWidth', 'defaultSelectedItem']);

      return React.createElement(
        Downshift,
        _extends({ defaultSelectedItem: defaultSelectedItem }, props),
        function (_ref4) {
          var isShown = _ref4.isOpen,
              inputValue = _ref4.inputValue,
              getItemProps = _ref4.getItemProps,
              selectedItem = _ref4.selectedItem,
              highlightedIndex = _ref4.highlightedIndex,
              selectItemAtIndex = _ref4.selectItemAtIndex,
              restDownshiftProps = _objectWithoutProperties(_ref4, ['isOpen', 'inputValue', 'getItemProps', 'selectedItem', 'highlightedIndex', 'selectItemAtIndex']);

          return React.createElement(
            'div',
            null,
            React.createElement(
              Popover,
              {
                bringFocusInside: false,
                isShown: isShown,
                minWidth: popoverMinWidth,
                position: position || (_this2.state.targetWidth < popoverMinWidth ? Position.BOTTOM_LEFT : Position.BOTTOM),
                content: function content() {
                  return _this2.renderResults({
                    width: Math.max(_this2.state.targetWidth, popoverMinWidth),
                    inputValue: inputValue,
                    getItemProps: getItemProps,
                    selectedItem: selectedItem,
                    highlightedIndex: highlightedIndex,
                    selectItemAtIndex: selectItemAtIndex
                  });
                },
                minHeight: 0,
                animationDuration: 0
              },
              function (_ref5) {
                var isShownPopover = _ref5.isShown,
                    toggle = _ref5.toggle,
                    _getRef = _ref5.getRef;
                return children(_extends({
                  isShown: isShownPopover,
                  toggle: toggle,
                  getRef: function getRef(ref) {
                    // Use the ref internally to determine the width
                    _this2.targetRef = ref;
                    _getRef(ref);
                  },
                  inputValue: inputValue,
                  selectedItem: selectedItem,
                  highlightedIndex: highlightedIndex,
                  selectItemAtIndex: selectItemAtIndex
                }, restDownshiftProps));
              }
            )
          );
        }
      );
    }
  }]);

  return Autocomplete;
}(PureComponent);

Autocomplete.propTypes = _extends({
  /**
   * This prop can be either a string or a Node.
   * It will provide a title for the items
   */
  title: PropTypes.oneOfType([PropTypes.string, PropTypes.node]),

  /**
   * An array of items to be used as options for the select
   */
  items: PropTypes.array.isRequired,

  /**
   * The selected Item to be shown on the autocomplete
   */
  selectedItem: PropTypes.any,

  /**
   * The selected item to be selected & shown by default on the autocomplete
   */
  defaultSelectedItem: PropTypes.any,

  /**
   * In case the array of items is not an array of strings,
   * this function is used on each item to return the string that will be shown on the filter
   */
  itemToString: PropTypes.func.isRequired,

  /**
   * Function that will render the 'filter' component.
   */
  children: PropTypes.func.isRequired,

  /**
   * The height of each item in the list
   * Because the list is virtualized this is required beforehand.
   */
  itemSize: PropTypes.number,

  /**
   * Function that returns a component to render the item
   */
  renderItem: PropTypes.func,

  /**
   * The position of the Popover the Autocomplete is rendered in.
   */
  position: PropTypes.oneOf(Object.keys(Position)),

  /**
   * A function that is used to filter the items.
   * It should return a subset of the initial items.
   * By default the "fuzzaldrin-plus" package is used.
   */
  itemsFilter: PropTypes.func,

  /**
   * Prop that enables and disables filtering
   * True: Enables Filtering
   * False: Disables Filtering
   */
  isFilterDisabled: PropTypes.bool,

  /**
   * Defines the minimum height the results container will be
   */
  popoverMinWidth: PropTypes.number,

  /**
   * Defines the maximum height the results container will be
   */
  popoverMaxHeight: PropTypes.number

}, Downshift.propTypes);
Autocomplete.defaultProps = {
  itemToString: function itemToString(i) {
    return i ? String(i) : '';
  },
  itemSize: 32,
  itemsFilter: fuzzyFilter,
  isFilterDisabled: false,
  popoverMinWidth: 240,
  popoverMaxHeight: 240,
  renderItem: autocompleteItemRenderer
};
export default Autocomplete;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9hdXRvY29tcGxldGUvc3JjL0F1dG9jb21wbGV0ZS5qcyJdLCJuYW1lcyI6WyJSZWFjdCIsIlB1cmVDb21wb25lbnQiLCJQcm9wVHlwZXMiLCJmdXp6YWxkcmluIiwiRG93bnNoaWZ0IiwiVmlydHVhbExpc3QiLCJQb3BvdmVyIiwiUG9zaXRpb24iLCJUZXh0IiwiUGFuZSIsIkF1dG9jb21wbGV0ZUl0ZW0iLCJmdXp6eUZpbHRlciIsIml0ZW1zIiwiaW5wdXQiLCJmaWx0ZXIiLCJhdXRvY29tcGxldGVJdGVtUmVuZGVyZXIiLCJwcm9wcyIsIkF1dG9jb21wbGV0ZSIsInN0YXRlIiwidGFyZ2V0V2lkdGgiLCJyZW5kZXJSZXN1bHRzIiwid2lkdGgiLCJpbnB1dFZhbHVlIiwiaGlnaGxpZ2h0ZWRJbmRleCIsInNlbGVjdEl0ZW1BdEluZGV4Iiwic2VsZWN0ZWRJdGVtIiwiZ2V0SXRlbVByb3BzIiwidGl0bGUiLCJpdGVtU2l6ZSIsIml0ZW1zRmlsdGVyIiwib3JpZ2luYWxJdGVtcyIsIml0ZW1Ub1N0cmluZyIsInJlbmRlckl0ZW0iLCJwb3BvdmVyTWF4SGVpZ2h0IiwiaXNGaWx0ZXJEaXNhYmxlZCIsInRyaW0iLCJsZW5ndGgiLCJNYXRoIiwibWluIiwiaW5kZXgiLCJzdHlsZSIsIml0ZW0iLCJpdGVtU3RyaW5nIiwia2V5IiwiY2hpbGRyZW4iLCJvbk1vdXNlVXAiLCJpc1NlbGVjdGVkIiwiaXNIaWdobGlnaHRlZCIsInNldFN0YXRlIiwidGFyZ2V0UmVmIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwicG9zaXRpb24iLCJwb3BvdmVyTWluV2lkdGgiLCJkZWZhdWx0U2VsZWN0ZWRJdGVtIiwiaXNTaG93biIsImlzT3BlbiIsInJlc3REb3duc2hpZnRQcm9wcyIsIkJPVFRPTV9MRUZUIiwiQk9UVE9NIiwibWF4IiwiaXNTaG93blBvcG92ZXIiLCJ0b2dnbGUiLCJnZXRSZWYiLCJyZWYiLCJwcm9wVHlwZXMiLCJvbmVPZlR5cGUiLCJzdHJpbmciLCJub2RlIiwiYXJyYXkiLCJpc1JlcXVpcmVkIiwiYW55IiwiZnVuYyIsIm51bWJlciIsIm9uZU9mIiwiT2JqZWN0Iiwia2V5cyIsImJvb2wiLCJkZWZhdWx0UHJvcHMiLCJpIiwiU3RyaW5nIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSxPQUFPQSxLQUFQLElBQWdCQyxhQUFoQixRQUFxQyxPQUFyQztBQUNBLE9BQU9DLFNBQVAsTUFBc0IsWUFBdEI7QUFDQSxPQUFPQyxVQUFQLE1BQXVCLGlCQUF2QjtBQUNBLE9BQU9DLFNBQVAsTUFBc0IsV0FBdEI7QUFDQSxPQUFPQyxXQUFQLE1BQXdCLHlCQUF4QjtBQUNBLFNBQVNDLE9BQVQsUUFBd0IsZUFBeEI7QUFDQSxTQUFTQyxRQUFULFFBQXlCLGtCQUF6QjtBQUNBLFNBQVNDLElBQVQsUUFBcUIsa0JBQXJCO0FBQ0EsU0FBU0MsSUFBVCxRQUFxQixjQUFyQjtBQUNBLE9BQU9DLGdCQUFQLE1BQTZCLG9CQUE3Qjs7QUFFQSxJQUFNQyxjQUFjLFNBQWRBLFdBQWMsQ0FBQ0MsS0FBRCxFQUFRQyxLQUFSO0FBQUEsU0FBa0JWLFdBQVdXLE1BQVgsQ0FBa0JGLEtBQWxCLEVBQXlCQyxLQUF6QixDQUFsQjtBQUFBLENBQXBCOztBQUVBLElBQU1FLDJCQUEyQixTQUEzQkEsd0JBQTJCO0FBQUEsU0FBUyxvQkFBQyxnQkFBRCxFQUFzQkMsS0FBdEIsQ0FBVDtBQUFBLENBQWpDOztBQUVBOztJQUNxQkMsWTs7Ozs7Ozs7Ozs7Ozs7a01BNkVuQkMsSyxHQUFRO0FBQ05DLG1CQUFhO0FBRFAsSyxRQW9CUkMsYSxHQUFnQixpQkFPVjtBQUFBLFVBTkpDLEtBTUksU0FOSkEsS0FNSTtBQUFBLFVBTEpDLFVBS0ksU0FMSkEsVUFLSTtBQUFBLFVBSkpDLGdCQUlJLFNBSkpBLGdCQUlJO0FBQUEsVUFISkMsaUJBR0ksU0FISkEsaUJBR0k7QUFBQSxVQUZKQyxZQUVJLFNBRkpBLFlBRUk7QUFBQSxVQURKQyxZQUNJLFNBREpBLFlBQ0k7QUFBQSx3QkFV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QUMvRCxVQUFVZ0UsTUFBWCxFQUFtQmhFLFVBQVVpRSxJQUE3QixDQUFwQixDOztBQUVQOzs7QUFHQXZELFNBQU9WLFVBQVVrRSxLQUFWLENBQWdCQyxVOztBQUV2Qjs7O0FBR0E1QyxnQkFBY3ZCLFVBQVVvRSxHOztBQUV4Qjs7O0FBR0FqQix1QkFBcUJuRCxVQUFVb0UsRzs7QUFFL0I7Ozs7QUFJQXZDLGdCQUFjN0IsVUFBVXFFLElBQVYsQ0FBZUYsVTs7QUFFN0I7OztBQUdBekIsWUFBVTFDLFVBQVVxRSxJQUFWLENBQWVGLFU7O0FBRXpCOzs7O0FBSUF6QyxZQUFVMUIsVUFBVXNFLE07O0FBRXBCOzs7QUFHQXhDLGNBQVk5QixVQUFVcUUsSTs7QUFFdEI7OztBQUdBcEIsWUFBVWpELFVBQVV1RSxLQUFWLENBQWdCQyxPQUFPQyxJQUFQLENBQVlwRSxRQUFaLENBQWhCLEM7O0FBRVY7Ozs7O0FBS0FzQixlQUFhM0IsVUFBVXFFLEk7O0FBRXZCOzs7OztBQUtBckMsb0JBQWtCaEMsVUFBVTBFLEk7O0FBRTVCOzs7QUFHQXhCLG1CQUFpQmxELFVBQVVzRSxNOztBQUUzQjs7O0FBR0F2QyxvQkFBa0IvQixVQUFVc0U7O0dBRXpCcEUsVUFBVTRELFM7QUExRUkvQyxZLENBaUZaNEQsWSxHQUFlO0FBQ3BCOUMsZ0JBQWM7QUFBQSxXQUFNK0MsSUFBSUMsT0FBT0QsQ0FBUCxDQUFKLEdBQWdCLEVBQXRCO0FBQUEsR0FETTtBQUVwQmxELFlBQVUsRUFGVTtBQUdwQkMsZUFBYWxCLFdBSE87QUFJcEJ1QixvQkFBa0IsS0FKRTtBQUtwQmtCLG1CQUFpQixHQUxHO0FBTXBCbkIsb0JBQWtCLEdBTkU7QUFPcEJELGNBQVlqQjtBQVBRLEM7ZUFqRkhFLFkiLCJmaWxlIjoiQXV0b2NvbXBsZXRlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IFB1cmVDb21wb25lbnQgfSBmcm9tICdyZWFjdCdcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcydcbmltcG9ydCBmdXp6YWxkcmluIGZyb20gJ2Z1enphbGRyaW4tcGx1cydcbmltcG9ydCBEb3duc2hpZnQgZnJvbSAnZG93bnNoaWZ0J1xuaW1wb3J0IFZpcnR1YWxMaXN0IGZyb20gJ3JlYWN0LXRpbnktdmlydHVhbC1saXN0J1xuaW1wb3J0IHsgUG9wb3ZlciB9IGZyb20gJy4uLy4uL3BvcG92ZXInXG5pbXBvcnQgeyBQb3NpdGlvbiB9IGZyb20gJy4uLy4uL3Bvc2l0aW9uZXInXG5pbXBvcnQgeyBUZXh0IH0gZnJvbSAnLi4vLi4vdHlwb2dyYXBoeSdcbmltcG9ydCB7IFBhbmUgfSBmcm9tICcuLi8uLi9sYXllcnMnXG5pbXBvcnQgQXV0b2NvbXBsZXRlSXRlbSBmcm9tICcuL0F1dG9jb21wbGV0ZUl0ZW0nXG5cbmNvbnN0IGZ1enp5RmlsdGVyID0gKGl0ZW1zLCBpbnB1dCkgPT4gZnV6emFsZHJpbi5maWx0ZXIoaXRlbXMsIGlucHV0KVxuXG5jb25zdCBhdXRvY29tcGxldGVJdGVtUmVuZGVyZXIgPSBwcm9wcyA9PiA8QXV0b2NvbXBsZXRlSXRlbSB7Li4ucHJvcHN9IC8+XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXlwYWwvZG93bnNoaWZ0L2lzc3Vlcy8xNjRcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1dG9jb21wbGV0ZSBleHRlbmRzIFB1cmVDb21wb25lbnQge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIC8qKlxuICAgICAqIFRoaXMgcHJvcCBjYW4gYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGEgTm9kZS5cbiAgICAgKiBJdCB3aWxsIHByb3ZpZGUgYSB0aXRsZSBmb3IgdGhlIGl0ZW1zXG4gICAgICovXG4gICAgdGl0bGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5ub2RlXSksXG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBpdGVtcyB0byBiZSB1c2VkIGFzIG9wdGlvbnMgZm9yIHRoZSBzZWxlY3RcbiAgICAgKi9cbiAgICBpdGVtczogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VsZWN0ZWQgSXRlbSB0byBiZSBzaG93biBvbiB0aGUgYXV0b2NvbXBsZXRlXG4gICAgICovXG4gICAgc2VsZWN0ZWRJdGVtOiBQcm9wVHlwZXMuYW55LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbGVjdGVkIGl0ZW0gdG8gYmUgc2VsZWN0ZWQgJiBzaG93biBieSBkZWZhdWx0IG9uIHRoZSBhdXRvY29tcGxldGVcbiAgICAgKi9cbiAgICBkZWZhdWx0U2VsZWN0ZWRJdGVtOiBQcm9wVHlwZXMuYW55LFxuXG4gICAgLyoqXG4gICAgICogSW4gY2FzZSB0aGUgYXJyYXkgb2YgaXRlbXMgaXMgbm90IGFuIGFycmF5IG9mIHN0cmluZ3MsXG4gICAgICogdGhpcyBmdW5jdGlvbiBpcyB1c2VkIG9uIGVhY2ggaXRlbSB0byByZXR1cm4gdGhlIHN0cmluZyB0aGF0IHdpbGwgYmUgc2hvd24gb24gdGhlIGZpbHRlclxuICAgICAqL1xuICAgIGl0ZW1Ub1N0cmluZzogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRoYXQgd2lsbCByZW5kZXIgdGhlICdmaWx0ZXInIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBjaGlsZHJlbjogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBoZWlnaHQgb2YgZWFjaCBpdGVtIGluIHRoZSBsaXN0XG4gICAgICogQmVjYXVzZSB0aGUgbGlzdCBpcyB2aXJ0dWFsaXplZCB0aGlzIGlzIHJlcXVpcmVkIGJlZm9yZWhhbmQuXG4gICAgICovXG4gICAgaXRlbVNpemU6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0aGF0IHJldHVybnMgYSBjb21wb25lbnQgdG8gcmVuZGVyIHRoZSBpdGVtXG4gICAgICovXG4gICAgcmVuZGVySXRlbTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgcG9zaXRpb24gb2YgdGhlIFBvcG92ZXIgdGhlIEF1dG9jb21wbGV0ZSBpcyByZW5kZXJlZCBpbi5cbiAgICAgKi9cbiAgICBwb3NpdGlvbjogUHJvcFR5cGVzLm9uZU9mKE9iamVjdC5rZXlzKFBvc2l0aW9uKSksXG5cbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBmaWx0ZXIgdGhlIGl0ZW1zLlxuICAgICAqIEl0IHNob3VsZCByZXR1cm4gYSBzdWJzZXQgb2YgdGhlIGluaXRpYWwgaXRlbXMuXG4gICAgICogQnkgZGVmYXVsdCB0aGUgXCJmdXp6YWxkcmluLXBsdXNcIiBwYWNrYWdlIGlzIHVzZWQuXG4gICAgICovXG4gICAgaXRlbXNGaWx0ZXI6IFByb3BUeXBlcy5mdW5jLFxuXG4gICAgLyoqXG4gICAgICogUHJvcCB0aGF0IGVuYWJsZXMgYW5kIGRpc2FibGVzIGZpbHRlcmluZ1xuICAgICAqIFRydWU6IEVuYWJsZXMgRmlsdGVyaW5nXG4gICAgICogRmFsc2U6IERpc2FibGVzIEZpbHRlcmluZ1xuICAgICAqL1xuICAgIGlzRmlsdGVyRGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB0aGUgbWluaW11bSBoZWlnaHQgdGhlIHJlc3VsdHMgY29udGFpbmVyIHdpbGwgYmVcbiAgICAgKi9cbiAgICBwb3BvdmVyTWluV2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSBtYXhpbXVtIGhlaWdodCB0aGUgcmVzdWx0cyBjb250YWluZXIgd2lsbCBiZVxuICAgICAqL1xuICAgIHBvcG92ZXJNYXhIZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgICAuLi5Eb3duc2hpZnQucHJvcFR5cGVzXG4gIH1cblxuICBzdGF0ZSA9IHtcbiAgICB0YXJnZXRXaWR0aDogMFxuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBpdGVtVG9TdHJpbmc6IGkgPT4gKGkgPyBTdHJpbmcoaSkgOiAnJyksXG4gICAgaXRlbVNpemU6IDMyLFxuICAgIGl0ZW1zRmlsdGVyOiBmdXp6eUZpbHRlcixcbiAgICBpc0ZpbHRlckRpc2FibGVkOiBmYWxzZSxcbiAgICBwb3BvdmVyTWluV2lkdGg6IDI0MCxcbiAgICBwb3BvdmVyTWF4SGVpZ2h0OiAyNDAsXG4gICAgcmVuZGVySXRlbTogYXV0b2NvbXBsZXRlSXRlbVJlbmRlcmVyXG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHRhcmdldFdpZHRoOiB0aGlzLnRhcmdldFJlZi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aFxuICAgIH0pXG4gIH1cblxuICByZW5kZXJSZXN1bHRzID0gKHtcbiAgICB3aWR0aCxcbiAgICBpbnB1dFZhbHVlLFxuICAgIGhpZ2hsaWdodGVkSW5kZXgsXG4gICAgc2VsZWN0SXRlbUF0SW5kZXgsXG4gICAgc2VsZWN0ZWRJdGVtLFxuICAgIGdldEl0ZW1Qcm9wc1xuICB9KSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgdGl0bGUsXG4gICAgICBpdGVtU2l6ZSxcbiAgICAgIGl0ZW1zRmlsdGVyLFxuICAgICAgaXRlbXM6IG9yaWdpbmFsSXRlbXMsXG4gICAgICBpdGVtVG9TdHJpbmcsXG4gICAgICByZW5kZXJJdGVtLFxuICAgICAgcG9wb3Zlck1heEhlaWdodCxcbiAgICAgIGlzRmlsdGVyRGlzYWJsZWRcbiAgICB9ID0gdGhpcy5wcm9wc1xuXG4gICAgY29uc3QgaXRlbXMgPVxuICAgICAgaXNGaWx0ZXJEaXNhYmxlZCB8fCBpbnB1dFZhbHVlLnRyaW0oKSA9PT0gJydcbiAgICAgICAgPyBvcmlnaW5hbEl0ZW1zXG4gICAgICAgIDogaXRlbXNGaWx0ZXIob3JpZ2luYWxJdGVtcywgaW5wdXRWYWx1ZSlcblxuICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHJldHVybiBudWxsXG5cbiAgICByZXR1cm4gKFxuICAgICAgPFBhbmUgd2lkdGg9e3dpZHRofT5cbiAgICAgICAge3RpdGxlICYmIChcbiAgICAgICAgICA8UGFuZSBwYWRkaW5nPXs4fSBib3JkZXJCb3R0b209XCJleHRyYU11dGVkXCI+XG4gICAgICAgICAgICA8VGV4dCBzaXplPXsyMDB9IGNvbG9yPVwibXV0ZWRcIiBpc1VwcGVyY2FzZT5cbiAgICAgICAgICAgICAge3RpdGxlfVxuICAgICAgICAgICAgPC9UZXh0PlxuICAgICAgICAgIDwvUGFuZT5cbiAgICAgICAgKX1cbiAgICAgICAge2l0ZW1zLmxlbmd0aCA+IDAgJiYgKFxuICAgICAgICAgIDxWaXJ0dWFsTGlzdFxuICAgICAgICAgICAgd2lkdGg9XCIxMDAlXCJcbiAgICAgICAgICAgIGhlaWdodD17TWF0aC5taW4oaXRlbXMubGVuZ3RoICogaXRlbVNpemUsIHBvcG92ZXJNYXhIZWlnaHQpfVxuICAgICAgICAgICAgaXRlbVNpemU9e2l0ZW1TaXplfVxuICAgICAgICAgICAgaXRlbUNvdW50PXtpdGVtcy5sZW5ndGh9XG4gICAgICAgICAgICBzY3JvbGxUb0luZGV4PXtoaWdobGlnaHRlZEluZGV4IHx8IDB9XG4gICAgICAgICAgICBvdmVyc2NhbkNvdW50PXszfVxuICAgICAgICAgICAgc2Nyb2xsVG9BbGlnbm1lbnQ9XCJhdXRvXCJcbiAgICAgICAgICAgIHJlbmRlckl0ZW09eyh7IGluZGV4LCBzdHlsZSB9KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpbmRleF1cbiAgICAgICAgICAgICAgY29uc3QgaXRlbVN0cmluZyA9IGl0ZW1Ub1N0cmluZyhpdGVtKVxuICAgICAgICAgICAgICByZXR1cm4gcmVuZGVySXRlbShcbiAgICAgICAgICAgICAgICBnZXRJdGVtUHJvcHMoe1xuICAgICAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgICAgIGtleTogaXRlbVN0cmluZyxcbiAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgc3R5bGUsXG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogaXRlbVN0cmluZyxcbiAgICAgICAgICAgICAgICAgIG9uTW91c2VVcDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RJdGVtQXRJbmRleChpbmRleClcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBpc1NlbGVjdGVkOiBpdGVtVG9TdHJpbmcoc2VsZWN0ZWRJdGVtKSA9PT0gaXRlbVN0cmluZyxcbiAgICAgICAgICAgICAgICAgIGlzSGlnaGxpZ2h0ZWQ6IGhpZ2hsaWdodGVkSW5kZXggPT09IGluZGV4XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfX1cbiAgICAgICAgICAvPlxuICAgICAgICApfVxuICAgICAgPC9QYW5lPlxuICAgIClcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBjaGlsZHJlbixcbiAgICAgIGl0ZW1TaXplLFxuICAgICAgcG9zaXRpb24sXG4gICAgICByZW5kZXJJdGVtLFxuICAgICAgaXRlbXNGaWx0ZXIsXG4gICAgICBwb3BvdmVyTWF4SGVpZ2h0LFxuICAgICAgcG9wb3Zlck1pbldpZHRoLFxuICAgICAgZGVmYXVsdFNlbGVjdGVkSXRlbSxcbiAgICAgIC4uLnByb3BzXG4gICAgfSA9IHRoaXMucHJvcHNcblxuICAgIHJldHVybiAoXG4gICAgICA8RG93bnNoaWZ0IGRlZmF1bHRTZWxlY3RlZEl0ZW09e2RlZmF1bHRTZWxlY3RlZEl0ZW19IHsuLi5wcm9wc30+XG4gICAgICAgIHsoe1xuICAgICAgICAgIGlzT3BlbjogaXNTaG93bixcbiAgICAgICAgICBpbnB1dFZhbHVlLFxuICAgICAgICAgIGdldEl0ZW1Qcm9wcyxcbiAgICAgICAgICBzZWxlY3RlZEl0ZW0sXG4gICAgICAgICAgaGlnaGxpZ2h0ZWRJbmRleCxcbiAgICAgICAgICBzZWxlY3RJdGVtQXRJbmRleCxcbiAgICAgICAgICAuLi5yZXN0RG93bnNoaWZ0UHJvcHNcbiAgICAgICAgfSkgPT4gKFxuICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICA8UG9wb3ZlclxuICAgICAgICAgICAgICBicmluZ0ZvY3VzSW5zaWRlPXtmYWxzZX1cbiAgICAgICAgICAgICAgaXNTaG93bj17aXNTaG93bn1cbiAgICAgICAgICAgICAgbWluV2lkdGg9e3BvcG92ZXJNaW5XaWR0aH1cbiAgICAgICAgICAgICAgcG9zaXRpb249e1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMuc3RhdGUudGFyZ2V0V2lkdGggPCBwb3BvdmVyTWluV2lkdGhcbiAgICAgICAgICAgICAgICAgID8gUG9zaXRpb24uQk9UVE9NX0xFRlRcbiAgICAgICAgICAgICAgICAgIDogUG9zaXRpb24uQk9UVE9NKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRlbnQ9eygpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJSZXN1bHRzKHtcbiAgICAgICAgICAgICAgICAgIHdpZHRoOiBNYXRoLm1heCh0aGlzLnN0YXRlLnRhcmdldFdpZHRoLCBwb3BvdmVyTWluV2lkdGgpLFxuICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgIGdldEl0ZW1Qcm9wcyxcbiAgICAgICAgICAgICAgICAgIHNlbGVjdGVkSXRlbSxcbiAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodGVkSW5kZXgsXG4gICAgICAgICAgICAgICAgICBzZWxlY3RJdGVtQXRJbmRleFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgIG1pbkhlaWdodD17MH1cbiAgICAgICAgICAgICAgYW5pbWF0aW9uRHVyYXRpb249ezB9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHsoeyBpc1Nob3duOiBpc1Nob3duUG9wb3ZlciwgdG9nZ2xlLCBnZXRSZWYgfSkgPT5cbiAgICAgICAgICAgICAgICBjaGlsZHJlbih7XG4gICAgICAgICAgICAgICAgICBpc1Nob3duOiBpc1Nob3duUG9wb3ZlcixcbiAgICAgICAgICAgICAgICAgIHRvZ2dsZSxcbiAgICAgICAgICAgICAgICAgIGdldFJlZjogcmVmID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSByZWYgaW50ZXJuYWxseSB0byBkZXRlcm1pbmUgdGhlIHdpZHRoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0UmVmID0gcmVmXG4gICAgICAgICAgICAgICAgICAgIGdldFJlZihyZWYpXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgIHNlbGVjdGVkSXRlbSxcbiAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodGVkSW5kZXgsXG4gICAgICAgICAgICAgICAgICBzZWxlY3RJdGVtQXRJbmRleCxcbiAgICAgICAgICAgICAgICAgIC4uLnJlc3REb3duc2hpZnRQcm9wc1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDwvUG9wb3Zlcj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKX1cbiAgICAgIDwvRG93bnNoaWZ0PlxuICAgIClcbiAgfVxufVxuIl19