var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import { spacing, position, layout, dimensions } from 'ui-box';
import { Pane } from '../../layers';
import { Text } from '../../typography';
import Radio from './Radio';

var radioCount = 1; // Used for generating unique input names

var RadioGroup = function (_PureComponent) {
  _inherits(RadioGroup, _PureComponent);

  function RadioGroup(props, context) {
    _classCallCheck(this, RadioGroup);

    var _this = _possibleConstructorReturn(this, (RadioGroup.__proto__ || Object.getPrototypeOf(RadioGroup)).call(this, props, context));

    _this.handleChange = function (value) {
      // Save a render cycle when it's a controlled input
      if (!_this.props.value) {
        _this.setState({ value: value });
      }

      if (_this.props.onChange) {
        _this.props.onChange(value);
      }
    };

    _this.state = {
      value: props.defaultValue || props.options[0].value
    };

    _this.name = 'RadioGroup-' + radioCount;
    radioCount += 1;
    return _this;
  }

  _createClass(RadioGroup, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          size = _props.size,
          label = _props.label,
          defaultValue = _props.defaultValue,
          value = _props.value,
          options = _props.options,
          onChange = _props.onChange,
          isRequired = _props.isRequired,
          props = _objectWithoutProperties(_props, ['size', 'label', 'defaultValue', 'value', 'options', 'onChange', 'isRequired']);

      // Allows it to behave like a controlled input


      var selected = value || this.state.value;

      return React.createElement(
        Pane,
        _extends({ role: 'group', 'aria-label': label }, props),
        label && React.createElement(
          Text,
          {
            size: size === 12 ? 200 : 300,
            color: 'extraMuted',
            fontWeight: 500
          },
          label
        ),
        options.map(function (item) {
          return React.createElement(Radio, {
            key: item.value,
            size: size,
            name: _this2.name,
            value: item.value,
            label: item.label,
            checked: selected === item.value,
            disabled: item.isDisabled,
            onChange: function onChange() {
              return _this2.handleChange(item.value);
            },
            isRequired: isRequired
          });
        })
      );
    }
  }]);

  return RadioGroup;
}(PureComponent);

RadioGroup.propTypes = _extends({}, spacing.propTypes, position.propTypes, layout.propTypes, dimensions.propTypes, {

  /**
   * The options for the radios of the Radio Group.
   */
  options: PropTypes.arrayOf(PropTypes.shape({
    label: PropTypes.node.isRequired,
    value: PropTypes.string.isRequired,
    isDisabled: PropTypes.bool
  })).isRequired,

  /**
   * The selected item value when controlled.
   */
  value: PropTypes.string,

  /**
   * The default value of the Radio Group when uncontrolled.
   */
  defaultValue: PropTypes.string,

  /**
   * Function called when state changes.
   */
  onChange: PropTypes.func.isRequired,

  /**
   * Label to display above the radio button options.
   */
  label: PropTypes.string,

  /**
   * The size of the radio circle. This also informs the text size and spacing.
   */
  size: PropTypes.oneOf([12, 16]).isRequired,

  /**
   * When true, the radio get the required attribute.
   */
  isRequired: PropTypes.bool.isRequired
});
RadioGroup.defaultProps = {
  options: [],
  onChange: function onChange() {},
  size: 12,
  isRequired: false
};
export default RadioGroup;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yYWRpby9zcmMvUmFkaW9Hcm91cC5qcyJdLCJuYW1lcyI6WyJSZWFjdCIsIlB1cmVDb21wb25lbnQiLCJQcm9wVHlwZXMiLCJzcGFjaW5nIiwicG9zaXRpb24iLCJsYXlvdXQiLCJkaW1lbnNpb25zIiwiUGFuZSIsIlRleHQiLCJSYWRpbyIsInJhZGlvQ291bnQiLCJSYWRpb0dyb3VwIiwicHJvcHMiLCJjb250ZXh0IiwiaGFuZGxlQ2hhbmdlIiwidmFsdWUiLCJzZXRTdGF0ZSIsIm9uQ2hhbmdlIiwic3RhdGUiLCJkZWZhdWx0VmFsdWUiLCJvcHRpb25zIiwibmFtZSIsInNpemUiLCJsYWJlbCIsImlzUmVxdWlyZWQiLCJzZWxlY3RlZCIsIm1hcCIsIml0ZW0iLCJpc0Rpc2FibGVkIiwicHJvcFR5cGVzIiwiYXJyYXlPZiIsInNoYXBlIiwibm9kZSIsInN0cmluZyIsImJvb2wiLCJmdW5jIiwib25lT2YiLCJkZWZhdWx0UHJvcHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLE9BQU9BLEtBQVAsSUFBZ0JDLGFBQWhCLFFBQXFDLE9BQXJDO0FBQ0EsT0FBT0MsU0FBUCxNQUFzQixZQUF0QjtBQUNBLFNBQVNDLE9BQVQsRUFBa0JDLFFBQWxCLEVBQTRCQyxNQUE1QixFQUFvQ0MsVUFBcEMsUUFBc0QsUUFBdEQ7QUFDQSxTQUFTQyxJQUFULFFBQXFCLGNBQXJCO0FBQ0EsU0FBU0MsSUFBVCxRQUFxQixrQkFBckI7QUFDQSxPQUFPQyxLQUFQLE1BQWtCLFNBQWxCOztBQUVBLElBQUlDLGFBQWEsQ0FBakIsQyxDQUFtQjs7SUFFRUMsVTs7O0FBMkRuQixzQkFBWUMsS0FBWixFQUFtQkMsT0FBbkIsRUFBNEI7QUFBQTs7QUFBQSx3SEFDcEJELEtBRG9CLEVBQ2JDLE9BRGE7O0FBQUEsVUFXNUJDLFlBWDRCLEdBV2IsaUJBQVM7QUFDdEI7QUFDQSxVQUFJLENBQUMsTUFBS0YsS0FBTCxDQUFXRyxLQUFoQixFQUF1QjtBQUNyQixj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bmVudCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJ1xuaW1wb3J0IHsgc3BhY2luZywgcG9zaXRpb24sIGxheW91dCwgZGltZW5zaW9ucyB9IGZyb20gJ3VpLWJveCdcbmltcG9ydCB7IFBhbmUgfSBmcm9tICcuLi8uLi9sYXllcnMnXG5pbXBvcnQgeyBUZXh0IH0gZnJvbSAnLi4vLi4vdHlwb2dyYXBoeSdcbmltcG9ydCBSYWRpbyBmcm9tICcuL1JhZGlvJ1xuXG5sZXQgcmFkaW9Db3VudCA9IDEgLy8gVXNlZCBmb3IgZ2VuZXJhdGluZyB1bmlxdWUgaW5wdXQgbmFtZXNcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmFkaW9Hcm91cCBleHRlbmRzIFB1cmVDb21wb25lbnQge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIC8qKlxuICAgICAqIENvbXBvc2VzIHNvbWUgQm94IEFQSXMuXG4gICAgICovXG4gICAgLi4uc3BhY2luZy5wcm9wVHlwZXMsXG4gICAgLi4ucG9zaXRpb24ucHJvcFR5cGVzLFxuICAgIC4uLmxheW91dC5wcm9wVHlwZXMsXG4gICAgLi4uZGltZW5zaW9ucy5wcm9wVHlwZXMsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3B0aW9ucyBmb3IgdGhlIHJhZGlvcyBvZiB0aGUgUmFkaW8gR3JvdXAuXG4gICAgICovXG4gICAgb3B0aW9uczogUHJvcFR5cGVzLmFycmF5T2YoXG4gICAgICBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgICBsYWJlbDogUHJvcFR5cGVzLm5vZGUuaXNSZXF1aXJlZCxcbiAgICAgICAgdmFsdWU6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICAgICAgaXNEaXNhYmxlZDogUHJvcFR5cGVzLmJvb2xcbiAgICAgIH0pXG4gICAgKS5pc1JlcXVpcmVkLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbGVjdGVkIGl0ZW0gdmFsdWUgd2hlbiBjb250cm9sbGVkLlxuICAgICAqL1xuICAgIHZhbHVlOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgdmFsdWUgb2YgdGhlIFJhZGlvIEdyb3VwIHdoZW4gdW5jb250cm9sbGVkLlxuICAgICAqL1xuICAgIGRlZmF1bHRWYWx1ZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIHN0YXRlIGNoYW5nZXMuXG4gICAgICovXG4gICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG5cbiAgICAvKipcbiAgICAgKiBMYWJlbCB0byBkaXNwbGF5IGFib3ZlIHRoZSByYWRpbyBidXR0b24gb3B0aW9ucy5cbiAgICAgKi9cbiAgICBsYWJlbDogUHJvcFR5cGVzLnN0cmluZyxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzaXplIG9mIHRoZSByYWRpbyBjaXJjbGUuIFRoaXMgYWxzbyBpbmZvcm1zIHRoZSB0ZXh0IHNpemUgYW5kIHNwYWNpbmcuXG4gICAgICovXG4gICAgc2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsxMiwgMTZdKS5pc1JlcXVpcmVkLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCB0aGUgcmFkaW8gZ2V0IHRoZSByZXF1aXJlZCBhdHRyaWJ1dGUuXG4gICAgICovXG4gICAgaXNSZXF1aXJlZDogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZFxuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBvcHRpb25zOiBbXSxcbiAgICBvbkNoYW5nZTogKCkgPT4ge30sXG4gICAgc2l6ZTogMTIsXG4gICAgaXNSZXF1aXJlZDogZmFsc2VcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KSB7XG4gICAgc3VwZXIocHJvcHMsIGNvbnRleHQpXG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgdmFsdWU6IHByb3BzLmRlZmF1bHRWYWx1ZSB8fCBwcm9wcy5vcHRpb25zWzBdLnZhbHVlXG4gICAgfVxuXG4gICAgdGhpcy5uYW1lID0gYFJhZGlvR3JvdXAtJHtyYWRpb0NvdW50fWBcbiAgICByYWRpb0NvdW50ICs9IDFcbiAgfVxuXG4gIGhhbmRsZUNoYW5nZSA9IHZhbHVlID0+IHtcbiAgICAvLyBTYXZlIGEgcmVuZGVyIGN5Y2xlIHdoZW4gaXQncyBhIGNvbnRyb2xsZWQgaW5wdXRcbiAgICBpZiAoIXRoaXMucHJvcHMudmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyB2YWx1ZSB9KVxuICAgIH1cblxuICAgIGlmICh0aGlzLnByb3BzLm9uQ2hhbmdlKSB7XG4gICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBzaXplLFxuICAgICAgbGFiZWwsXG4gICAgICBkZWZhdWx0VmFsdWUsXG4gICAgICB2YWx1ZSxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBvbkNoYW5nZSxcbiAgICAgIGlzUmVxdWlyZWQsXG4gICAgICAuLi5wcm9wc1xuICAgIH0gPSB0aGlzLnByb3BzXG5cbiAgICAvLyBBbGxvd3MgaXQgdG8gYmVoYXZlIGxpa2UgYSBjb250cm9sbGVkIGlucHV0XG4gICAgY29uc3Qgc2VsZWN0ZWQgPSB2YWx1ZSB8fCB0aGlzLnN0YXRlLnZhbHVlXG5cbiAgICByZXR1cm4gKFxuICAgICAgPFBhbmUgcm9sZT1cImdyb3VwXCIgYXJpYS1sYWJlbD17bGFiZWx9IHsuLi5wcm9wc30+XG4gICAgICAgIHtsYWJlbCAmJiAoXG4gICAgICAgICAgPFRleHRcbiAgICAgICAgICAgIHNpemU9e3NpemUgPT09IDEyID8gMjAwIDogMzAwfVxuICAgICAgICAgICAgY29sb3I9XCJleHRyYU11dGVkXCJcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ9ezUwMH1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7bGFiZWx9XG4gICAgICAgICAgPC9UZXh0PlxuICAgICAgICApfVxuICAgICAgICB7b3B0aW9ucy5tYXAoaXRlbSA9PiAoXG4gICAgICAgICAgPFJhZGlvXG4gICAgICAgICAgICBrZXk9e2l0ZW0udmFsdWV9XG4gICAgICAgICAgICBzaXplPXtzaXplfVxuICAgICAgICAgICAgbmFtZT17dGhpcy5uYW1lfVxuICAgICAgICAgICAgdmFsdWU9e2l0ZW0udmFsdWV9XG4gICAgICAgICAgICBsYWJlbD17aXRlbS5sYWJlbH1cbiAgICAgICAgICAgIGNoZWNrZWQ9e3NlbGVjdGVkID09PSBpdGVtLnZhbHVlfVxuICAgICAgICAgICAgZGlzYWJsZWQ9e2l0ZW0uaXNEaXNhYmxlZH1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXsoKSA9PiB0aGlzLmhhbmRsZUNoYW5nZShpdGVtLnZhbHVlKX1cbiAgICAgICAgICAgIGlzUmVxdWlyZWQ9e2lzUmVxdWlyZWR9XG4gICAgICAgICAgLz5cbiAgICAgICAgKSl9XG4gICAgICA8L1BhbmU+XG4gICAgKVxuICB9XG59XG4iXX0=