var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import Box from 'ui-box';
import { Text } from '../../typography';
import { TriangleIcon } from '../../icons';
import { getIconSizeForControlHeight, getBorderRadiusForControlHeight, getTextSizeForControlHeight } from '../../shared-styles';
import SelectAppearances from './styles/SelectAppearances';

var Select = function (_PureComponent) {
  _inherits(Select, _PureComponent);

  function Select() {
    _classCallCheck(this, Select);

    return _possibleConstructorReturn(this, (Select.__proto__ || Object.getPrototypeOf(Select)).apply(this, arguments));
  }

  _createClass(Select, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          id = _props.id,
          name = _props.name,
          height = _props.height,
          children = _props.children,
          disabled = _props.disabled,
          onChange = _props.onChange,
          value = _props.value,
          required = _props.required,
          autofocus = _props.autofocus,
          isInvalid = _props.isInvalid,
          appearance = _props.appearance,
          props = _objectWithoutProperties(_props, ['id', 'name', 'height', 'children', 'disabled', 'onChange', 'value', 'required', 'autofocus', 'isInvalid', 'appearance']);

      var appearanceStyle = SelectAppearances[appearance];
      var textSize = getTextSizeForControlHeight({ height: height });
      var borderRadius = getBorderRadiusForControlHeight({ height: height });
      var iconSize = getIconSizeForControlHeight({ height: height });

      return React.createElement(
        Box,
        _extends({
          display: 'inline-flex',
          flex: 1,
          position: 'relative',
          width: 200,
          height: height
        }, props),
        React.createElement(
          Text,
          _extends({
            is: 'select',
            id: id,
            name: name,
            onChange: onChange,
            value: value
          }, required ? { required: true } : {}, autofocus ? { autofocus: true } : {}, disabled ? { disabled: true } : {}, isInvalid ? { 'aria-invalid': true } : {}, {
            css: appearanceStyle,
            size: textSize,
            borderRadius: borderRadius,
            textTransform: 'default',
            paddingLeft: Math.round(height / 3.2)
          }),
          children
        ),
        React.createElement(TriangleIcon, {
          height: height,
          aim: 'down',
          padding: 10,
          boxSizing: 'border-box',
          position: 'absolute',
          right: height >= 36 ? 4 : 0,
          color: disabled ? 'disabled' : 'default',
          iconSize: iconSize,
          css: {
            pointerEvents: 'none'
          }
        })
      );
    }
  }]);

  return Select;
}(PureComponent);

Select.propTypes = _extends({}, Box.propTypes, {
  id: PropTypes.string,
  name: PropTypes.string,
  children: PropTypes.node,
  onChange: PropTypes.func,
  value: PropTypes.any,
  appearance: PropTypes.oneOf(Object.keys(SelectAppearances)),
  required: PropTypes.bool,
  autofocus: PropTypes.bool,
  isInvalid: PropTypes.bool
});
Select.defaultProps = {
  appearance: 'default',
  height: 32
};
export default Select;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zZWxlY3Qvc3JjL1NlbGVjdC5qcyJdLCJuYW1lcyI6WyJSZWFjdCIsIlB1cmVDb21wb25lbnQiLCJQcm9wVHlwZXMiLCJCb3giLCJUZXh0IiwiVHJpYW5nbGVJY29uIiwiZ2V0SWNvblNpemVGb3JDb250cm9sSGVpZ2h0IiwiZ2V0Qm9yZGVyUmFkaXVzRm9yQ29udHJvbEhlaWdodCIsImdldFRleHRTaXplRm9yQ29udHJvbEhlaWdodCIsIlNlbGVjdEFwcGVhcmFuY2VzIiwiU2VsZWN0IiwicHJvcHMiLCJpZCIsIm5hbWUiLCJoZWlnaHQiLCJjaGlsZHJlbiIsImRpc2FibGVkIiwib25DaGFuZ2UiLCJ2YWx1ZSIsInJlcXVpcmVkIiwiYXV0b2ZvY3VzIiwiaXNJbnZhbGlkIiwiYXBwZWFyYW5jZSIsImFwcGVhcmFuY2VTdHlsZSIsInRleHRTaXplIiwiYm9yZGVyUmFkaXVzIiwiaWNvblNpemUiLCJNYXRoIiwicm91bmQiLCJwb2ludGVyRXZlbnRzIiwicHJvcFR5cGVzIiwic3RyaW5nIiwibm9kZSIsImZ1bmMiLCJhbnkiLCJvbmVPZiIsIk9iamVjdCIsImtleXMiLCJib29sIiwiZGVmYXVsdFByb3BzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSxPQUFPQSxLQUFQLElBQWdCQyxhQUFoQixRQUFxQyxPQUFyQztBQUNBLE9BQU9DLFNBQVAsTUFBc0IsWUFBdEI7QUFDQSxPQUFPQyxHQUFQLE1BQWdCLFFBQWhCO0FBQ0EsU0FBU0MsSUFBVCxRQUFxQixrQkFBckI7QUFDQSxTQUFTQyxZQUFULFFBQTZCLGFBQTdCO0FBQ0EsU0FDRUMsMkJBREYsRUFFRUMsK0JBRkYsRUFHRUMsMkJBSEYsUUFJTyxxQkFKUDtBQUtBLE9BQU9DLGlCQUFQLE1BQThCLDRCQUE5Qjs7SUFFcUJDLE07Ozs7Ozs7Ozs7OzZCQW1CVjtBQUFBLG1CQWNILEtBQUtDLEtBZEY7QUFBQSxVQUVMQyxFQUZLLFVBRUxBLEVBRks7QUFBQSxVQUdMQyxJQUhLLFVBR0xBLElBSEs7QUFBQSxVQUlMQyxNQUpLLFVBSUxBLE1BSks7QUFBQSxVQUtMQyxRQUxLLFVBS0xBLFFBTEs7QUFBQSxVQU1MQyxRQU5LLFVBTUxBLFFBTks7QUFBQSxVQU9MQyxRQVBLLFVBT0xBLFFBUEs7QUFBQSxVQVFMQyxLQVJLLFVBUUxBLEtBUks7QUFBQSxVQVNMQyxRQVRLLFVBU0xBLFFBVEs7QUFBQSxVQVVMQyxTQVZLLFVBVUxBLFNBVks7QUFBQSxVQVdMQyxTQVhLLFVBV0xBLFNBWEs7QUFBQSxVQVlMQyxVQVpLLFVBWUxBLFVBWks7QUFBQSxVQWFGWCxLQWJFOztBQWVQLFVBQU1ZLGtCQUFrQmQsa0JBQWtCYSxVQUFsQixDQUF4QjtBQUNBLFVBQU1FLFdBQVdoQiw0QkFBNEIsRUFBRU0sY0FBRixFQUE1QixDQUFqQjtBQUNBLFVBQU1XLGVBQWVsQixnQ0FBZ0MsRUFBRU8sY0FBRixFQUFoQyxDQUFyQjtBQUNBLFVBQU1ZLFdBQVdwQiw0QkFBNEIsRUFBRVEsY0FBRixFQUE1QixDQUFqQjs7QUFFQSxhQUNFO0FBQUMsV0FBRDtBQUFBO0FBQ0UsbUJBQVEsYUFEVjtBQUVFLGdCQUFNLENBRlI7QUFHRSxvQkFBUyxVQUhYO0FBSUUsaUJBQU8sR0FKVDtBQUtFLGtCQUFRQTtBQUxWLFdBTU1ILEtBTk47QUFRRTtBQUFDLGNBQUQ7QUFBQTtBQUNFLGdCQUFHLFFBREw7QUFFRSxnQkFBSUMsRUFGTjtBQUdFLGtCQUFNQyxJQUhSO0FBSUUsc0JBQVVJLFFBSlo7QUFLRSxtQkFBT0M7QUFMVCxhQU1PQyxXQUFXLEVBQUVBLFVBQVUsSUFBWixFQUFYLEdBQWdDLEVBTnZDLEVBT09DLFlBQVksRUFBRUEsV0FBVyxJQUFiLEVBQVosR0FBa0MsRUFQekMsRUFRT0osV0FBVyxFQUFFQSxVQUFVLElBQVosRUFBWCxHQUFnQyxFQVJ2QyxFQVNPSyxZQUFZLEVBQUUsZ0JBQWdCLElBQWxCLEVBQVosR0FBdUMsRUFUOUM7QUFVRSxpQkFBS0UsZUFWUDtBQVdFLGtCQUFNQyxRQVhSO0FBWUUsMEJBQWNDLFlBWmhCO0FBYUUsMkJBQWMsU0FiaEI7QUFjRSx5QkFBYUUsS0FBS0MsS0FBTCxDQUFXZCxTQUFTLEdBQXBCO0FBZGY7QUFnQkdDO0FBaEJILFNBUkY7QUEwQkUsNEJBQUMsWUFBRDtBQUNFLGtCQUFRRCxNQURWO0FBRUUsZUFBSSxNQUZOO0FBR0UsbUJBQVMsRUFIWDtBQUlFLHFCQUFVLFlBSlo7QUFLRSxvQkFBUyxVQUxYO0FBTUUsaUJBQU9BLFVBQVUsRUFBVixHQUFlLENBQWYsR0FBbUIsQ0FONUI7QUFPRSxpQkFBT0UsV0FBVyxVQUFYLEdBQXdCLFNBUGpDO0FBUUUsb0JBQVVVLFFBUlo7QUFTRSxlQUFLO0FBQ0hHLDJCQUFlO0FBRFo7QUFUUDtBQTFCRixPQURGO0FBMENEOzs7O0VBakZpQzVCLGE7O0FBQWZTLE0sQ0FDWm9CLFMsZ0JBQ0YzQixJQUFJMkIsUztBQUNQbEIsTUFBSVYsVUFBVTZCLE07QUFDZGxCLFFBQU1YLFVBQVU2QixNO0FBQ2hCaEIsWUFBVWIsVUFBVThCLEk7QUFDcEJmLFlBQVVmLFVBQVUrQixJO0FBQ3BCZixTQUFPaEIsVUFBVWdDLEc7QUFDakJaLGNBQVlwQixVQUFVaUMsS0FBVixDQUFnQkMsT0FBT0MsSUFBUCxDQUFZNUIsaUJBQVosQ0FBaEIsQztBQUNaVSxZQUFVakIsVUFBVW9DLEk7QUFDcEJsQixhQUFXbEIsVUFBVW9DLEk7QUFDckJqQixhQUFXbkIsVUFBVW9DOztBQVhKNUIsTSxDQWNaNkIsWSxHQUFlO0FBQ3BCakIsY0FBWSxTQURRO0FBRXBCUixVQUFRO0FBRlksQztlQWRISixNIiwiZmlsZSI6IlNlbGVjdC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBQdXJlQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnXG5pbXBvcnQgQm94IGZyb20gJ3VpLWJveCdcbmltcG9ydCB7IFRleHQgfSBmcm9tICcuLi8uLi90eXBvZ3JhcGh5J1xuaW1wb3J0IHsgVHJpYW5nbGVJY29uIH0gZnJvbSAnLi4vLi4vaWNvbnMnXG5pbXBvcnQge1xuICBnZXRJY29uU2l6ZUZvckNvbnRyb2xIZWlnaHQsXG4gIGdldEJvcmRlclJhZGl1c0ZvckNvbnRyb2xIZWlnaHQsXG4gIGdldFRleHRTaXplRm9yQ29udHJvbEhlaWdodFxufSBmcm9tICcuLi8uLi9zaGFyZWQtc3R5bGVzJ1xuaW1wb3J0IFNlbGVjdEFwcGVhcmFuY2VzIGZyb20gJy4vc3R5bGVzL1NlbGVjdEFwcGVhcmFuY2VzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWxlY3QgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAuLi5Cb3gucHJvcFR5cGVzLFxuICAgIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIG5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICB2YWx1ZTogUHJvcFR5cGVzLmFueSxcbiAgICBhcHBlYXJhbmNlOiBQcm9wVHlwZXMub25lT2YoT2JqZWN0LmtleXMoU2VsZWN0QXBwZWFyYW5jZXMpKSxcbiAgICByZXF1aXJlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgYXV0b2ZvY3VzOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBpc0ludmFsaWQ6IFByb3BUeXBlcy5ib29sXG4gIH1cblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIGFwcGVhcmFuY2U6ICdkZWZhdWx0JyxcbiAgICBoZWlnaHQ6IDMyXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgaGVpZ2h0LFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBkaXNhYmxlZCxcbiAgICAgIG9uQ2hhbmdlLFxuICAgICAgdmFsdWUsXG4gICAgICByZXF1aXJlZCxcbiAgICAgIGF1dG9mb2N1cyxcbiAgICAgIGlzSW52YWxpZCxcbiAgICAgIGFwcGVhcmFuY2UsXG4gICAgICAuLi5wcm9wc1xuICAgIH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3QgYXBwZWFyYW5jZVN0eWxlID0gU2VsZWN0QXBwZWFyYW5jZXNbYXBwZWFyYW5jZV1cbiAgICBjb25zdCB0ZXh0U2l6ZSA9IGdldFRleHRTaXplRm9yQ29udHJvbEhlaWdodCh7IGhlaWdodCB9KVxuICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IGdldEJvcmRlclJhZGl1c0ZvckNvbnRyb2xIZWlnaHQoeyBoZWlnaHQgfSlcbiAgICBjb25zdCBpY29uU2l6ZSA9IGdldEljb25TaXplRm9yQ29udHJvbEhlaWdodCh7IGhlaWdodCB9KVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxCb3hcbiAgICAgICAgZGlzcGxheT1cImlubGluZS1mbGV4XCJcbiAgICAgICAgZmxleD17MX1cbiAgICAgICAgcG9zaXRpb249XCJyZWxhdGl2ZVwiXG4gICAgICAgIHdpZHRoPXsyMDB9XG4gICAgICAgIGhlaWdodD17aGVpZ2h0fVxuICAgICAgICB7Li4ucHJvcHN9XG4gICAgICA+XG4gICAgICAgIDxUZXh0XG4gICAgICAgICAgaXM9XCJzZWxlY3RcIlxuICAgICAgICAgIGlkPXtpZH1cbiAgICAgICAgICBuYW1lPXtuYW1lfVxuICAgICAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICAgICAgey4uLihyZXF1aXJlZCA/IHsgcmVxdWlyZWQ6IHRydWUgfSA6IHt9KX1cbiAgICAgICAgICB7Li4uKGF1dG9mb2N1cyA/IHsgYXV0b2ZvY3VzOiB0cnVlIH0gOiB7fSl9XG4gICAgICAgICAgey4uLihkaXNhYmxlZCA/IHsgZGlzYWJsZWQ6IHRydWUgfSA6IHt9KX1cbiAgICAgICAgICB7Li4uKGlzSW52YWxpZCA/IHsgJ2FyaWEtaW52YWxpZCc6IHRydWUgfSA6IHt9KX1cbiAgICAgICAgICBjc3M9e2FwcGVhcmFuY2VTdHlsZX1cbiAgICAgICAgICBzaXplPXt0ZXh0U2l6ZX1cbiAgICAgICAgICBib3JkZXJSYWRpdXM9e2JvcmRlclJhZGl1c31cbiAgICAgICAgICB0ZXh0VHJhbnNmb3JtPVwiZGVmYXVsdFwiXG4gICAgICAgICAgcGFkZGluZ0xlZnQ9e01hdGgucm91bmQoaGVpZ2h0IC8gMy4yKX1cbiAgICAgICAgPlxuICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgPC9UZXh0PlxuICAgICAgICA8VHJpYW5nbGVJY29uXG4gICAgICAgICAgaGVpZ2h0PXtoZWlnaHR9XG4gICAgICAgICAgYWltPVwiZG93blwiXG4gICAgICAgICAgcGFkZGluZz17MTB9XG4gICAgICAgICAgYm94U2l6aW5nPVwiYm9yZGVyLWJveFwiXG4gICAgICAgICAgcG9zaXRpb249XCJhYnNvbHV0ZVwiXG4gICAgICAgICAgcmlnaHQ9e2hlaWdodCA+PSAzNiA/IDQgOiAwfVxuICAgICAgICAgIGNvbG9yPXtkaXNhYmxlZCA/ICdkaXNhYmxlZCcgOiAnZGVmYXVsdCd9XG4gICAgICAgICAgaWNvblNpemU9e2ljb25TaXplfVxuICAgICAgICAgIGNzcz17e1xuICAgICAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnXG4gICAgICAgICAgfX1cbiAgICAgICAgLz5cbiAgICAgIDwvQm94PlxuICAgIClcbiAgfVxufVxuIl19