var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import { Text } from '../../typography';
import { IconMap, IconAim } from '../../icons';
import { getBorderRadiusForControlHeight, getTextStyleForControlHeight, getIconSizeForControlHeight } from '../../shared-styles';
import { Spinner } from '../../spinner';
import ButtonAppearances from './styles/ButtonAppearances';

var Button = function (_PureComponent) {
  _inherits(Button, _PureComponent);

  function Button() {
    _classCallCheck(this, Button);

    return _possibleConstructorReturn(this, (Button.__proto__ || Object.getPrototypeOf(Button)).apply(this, arguments));
  }

  _createClass(Button, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          css = _props.css,
          height = _props.height,
          isActive = _props.isActive,
          children = _props.children,
          disabled = _props.disabled,
          appearance = _props.appearance,
          isLoading = _props.isLoading,
          paddingRight = _props.paddingRight,
          paddingLeft = _props.paddingLeft,
          paddingTop = _props.paddingTop,
          paddingBottom = _props.paddingBottom,
          iconBeforeKey = _props.iconBefore,
          iconBeforeAim = _props.iconBeforeAim,
          iconAfterKey = _props.iconAfter,
          iconAfterAim = _props.iconAfterAim,
          props = _objectWithoutProperties(_props, ['css', 'height', 'isActive', 'children', 'disabled', 'appearance', 'isLoading', 'paddingRight', 'paddingLeft', 'paddingTop', 'paddingBottom', 'iconBefore', 'iconBeforeAim', 'iconAfter', 'iconAfterAim']);

      var appearanceStyle = ButtonAppearances[appearance];
      var textStyle = getTextStyleForControlHeight({ height: height });
      var borderRadius = getBorderRadiusForControlHeight({ height: height });
      var iconHeight = height - 4;
      var iconSize = getIconSizeForControlHeight({ height: iconHeight });

      var pr = paddingRight !== undefined ? paddingRight : Math.round(height / 2); // eslint-disable-line no-negated-condition
      var pl = paddingLeft !== undefined ? paddingLeft : Math.round(height / 2); // eslint-disable-line no-negated-condition

      var iconBefore = void 0;
      if (iconBeforeKey) {
        iconBefore = React.createElement(IconMap[iconBeforeKey], {
          aim: iconBeforeAim,
          iconSize: iconSize,
          color: 'inherit',
          size: iconHeight,
          marginLeft: -Math.round(pl * 0.6)
        });
      }

      var iconAfter = void 0;
      if (iconAfterKey) {
        iconAfter = React.createElement(IconMap[iconAfterKey], {
          aim: iconAfterAim,
          iconSize: iconSize,
          color: 'inherit',
          size: iconHeight,
          marginRight: -Math.round(pl * 0.6)
        });
      }

      return React.createElement(
        Text,
        _extends({
          is: 'button',
          borderTopRightRadius: borderRadius,
          borderBottomRightRadius: borderRadius,
          borderTopLeftRadius: borderRadius,
          borderBottomLeftRadius: borderRadius,
          paddingTop: paddingTop,
          paddingBottom: paddingBottom,
          paddingRight: pr,
          paddingLeft: pl,
          margin: 0 // Removes weird margins in Safari
        }, textStyle, {
          color: null // Prevent the Text color overriding the glamor appearanceStyle color
          , css: _extends({}, appearanceStyle, css),
          height: height,
          lineHeight: height + 'px'
        }, isActive ? { 'data-active': true } : {}, Button.styles, props, {
          disabled: disabled || isLoading
        }),
        isLoading && React.createElement(Spinner, {
          marginLeft: -Math.round(height / 8),
          marginRight: Math.round(height / 4),
          size: Math.round(height / 2)
        }),
        iconBefore || null,
        children,
        iconAfter || null
      );
    }
  }]);

  return Button;
}(PureComponent);

Button.propTypes = _extends({}, Text.propTypes, {

  /**
   * The appearance of the button.
   */
  appearance: PropTypes.oneOf(Object.keys(ButtonAppearances)).isRequired,

  /**
   * When true, show a loading spinner before the children.
   * This also disables the button.
   */
  isLoading: PropTypes.bool,

  /**
   * Forcefully set the active state of a button.
   * Useful in conjuction with a Popover.
   */
  isActive: PropTypes.bool,

  /**
   * Sets an icon before the text. Can be any icon from Evergreen.
   */
  iconBefore: PropTypes.oneOf(Object.keys(IconMap)),

  /**
   * The aim of the left icon. Not a big use case for this.
   */
  iconBeforeAim: PropTypes.oneOf(Object.keys(IconAim)),

  /**
   * Sets an icon after the text. Can be any icon from Evergreen.
   */
  iconAfter: PropTypes.oneOf(Object.keys(IconMap)),

  /**
   * The aim of the right icon. Useful to aim a triangle down.
   */
  iconAfterAim: PropTypes.oneOf(Object.keys(IconAim)),

  /**
   * When true, the button is disabled.
   * isLoading also sets the button to disabled.
   */
  disabled: PropTypes.bool
});
Button.defaultProps = {
  appearance: 'default',
  isActive: false,
  iconBeforeAim: 'none',
  iconAfterAim: 'none',
  height: 32,
  paddingTop: 0,
  paddingBottom: 0
};
Button.styles = {
  position: 'relative',
  fontFamily: 'ui',
  fontWeight: 500,
  display: 'inline-flex',
  alignItems: 'center',
  flexWrap: 'nowrap'
};
export default Button;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9idXR0b25zL3NyYy9CdXR0b24uanMiXSwibmFtZXMiOlsiUmVhY3QiLCJQdXJlQ29tcG9uZW50IiwiUHJvcFR5cGVzIiwiVGV4dCIsIkljb25NYXAiLCJJY29uQWltIiwiZ2V0Qm9yZGVyUmFkaXVzRm9yQ29udHJvbEhlaWdodCIsImdldFRleHRTdHlsZUZvckNvbnRyb2xIZWlnaHQiLCJnZXRJY29uU2l6ZUZvckNvbnRyb2xIZWlnaHQiLCJTcGlubmVyIiwiQnV0dG9uQXBwZWFyYW5jZXMiLCJCdXR0b24iLCJwcm9wcyIsImNzcyIsImhlaWdodCIsImlzQWN0aXZlIiwiY2hpbGRyZW4iLCJkaXNhYmxlZCIsImFwcGVhcmFuY2UiLCJpc0xvYWRpbmciLCJwYWRkaW5nUmlnaHQiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdUb3AiLCJwYWRkaW5nQm90dG9tIiwiaWNvbkJlZm9yZUtleSIsImljb25CZWZvcmUiLCJpY29uQmVmb3JlQWltIiwiaWNvbkFmdGVyS2V5IiwiaWNvbkFmdGVyIiwiaWNvbkFmdGVyQWltIiwiYXBwZWFyYW5jZVN0eWxlIiwidGV4dFN0eWxlIiwiYm9yZGVyUmFkaXVzIiwiaWNvbkhlaWdodCIsImljb25TaXplIiwicHIiLCJ1bmRlZmluZWQiLCJNYXRoIiwicm91bmQiLCJwbCIsImNyZWF0ZUVsZW1lbnQiLCJhaW0iLCJjb2xvciIsInNpemUiLCJtYXJnaW5MZWZ0IiwibWFyZ2luUmlnaHQiLCJzdHlsZXMiLCJwcm9wVHlwZXMiLCJvbmVPZiIsIk9iamVjdCIsImtleXMiLCJpc1JlcXVpcmVkIiwiYm9vbCIsImRlZmF1bHRQcm9wcyIsInBvc2l0aW9uIiwiZm9udEZhbWlseSIsImZvbnRXZWlnaHQiLCJkaXNwbGF5IiwiYWxpZ25JdGVtcyIsImZsZXhXcmFwIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSxPQUFPQSxLQUFQLElBQWdCQyxhQUFoQixRQUFxQyxPQUFyQztBQUNBLE9BQU9DLFNBQVAsTUFBc0IsWUFBdEI7QUFDQSxTQUFTQyxJQUFULFFBQXFCLGtCQUFyQjtBQUNBLFNBQVNDLE9BQVQsRUFBa0JDLE9BQWxCLFFBQWlDLGFBQWpDO0FBQ0EsU0FDRUMsK0JBREYsRUFFRUMsNEJBRkYsRUFHRUMsMkJBSEYsUUFJTyxxQkFKUDtBQUtBLFNBQVNDLE9BQVQsUUFBd0IsZUFBeEI7QUFDQSxPQUFPQyxpQkFBUCxNQUE4Qiw0QkFBOUI7O0lBRXFCQyxNOzs7Ozs7Ozs7Ozs2QkFzRVY7QUFBQSxtQkF1QkgsS0FBS0MsS0F2QkY7QUFBQSxVQUVMQyxHQUZLLFVBRUxBLEdBRks7QUFBQSxVQUdMQyxNQUhLLFVBR0xBLE1BSEs7QUFBQSxVQUlMQyxRQUpLLFVBSUxBLFFBSks7QUFBQSxVQUtMQyxRQUxLLFVBS0xBLFFBTEs7QUFBQSxVQU1MQyxRQU5LLFVBTUxBLFFBTks7QUFBQSxVQU9MQyxVQVBLLFVBT0xBLFVBUEs7QUFBQSxVQVFMQyxTQVJLLFVBUUxBLFNBUks7QUFBQSxVQVdMQyxZQVhLLFVBV0xBLFlBWEs7QUFBQSxVQVlMQyxXQVpLLFVBWUxBLFdBWks7QUFBQSxVQWFMQyxVQWJLLFVBYUxBLFVBYks7QUFBQSxVQWNMQyxhQWRLLFVBY0xBLGFBZEs7QUFBQSxVQWlCT0MsYUFqQlAsVUFpQkxDLFVBakJLO0FBQUEsVUFrQkxDLGFBbEJLLFVBa0JMQSxhQWxCSztBQUFBLFVBbUJNQyxZQW5CTixVQW1CTEMsU0FuQks7QUFBQSxVQW9CTEMsWUFwQkssVUFvQkxBLFlBcEJLO0FBQUEsVUFzQkZqQixLQXRCRTs7QUF3QlAsVUFBTWtCLGtCQUFrQnBCLGtCQUFrQlEsVUFBbEIsQ0FBeEI7QUFDQSxVQUFNYSxZQUFZeEIsNkJBQTZCLEVBQUVPLGNBQUYsRUFBN0IsQ0FBbEI7QUFDQSxVQUFNa0IsZUFBZTFCLGdDQUFnQyxFQUFFUSxjQUFGLEVBQWhDLENBQXJCO0FBQ0EsVUFBTW1CLGFBQWFuQixTQUFTLENBQTVCO0FBQ0EsVUFBTW9CLFdBQVcxQiw0QkFBNEIsRUFBRU0sUUFBUW1CLFVBQVYsRUFBNUIsQ0FBakI7O0FBRUEsVUFBTUUsS0FDSmYsaUJBQWlCZ0IsU0FBakIsR0FBNkJoQixZQUE3QixHQUE0Q2lCLEtBQUtDLEtBQUwsQ0FBV3hCLFNBQVMsQ0FBcEIsQ0FEOUMsQ0E5Qk8sQ0ErQjhEO0FBQ3JFLFVBQU15QixLQUFLbEIsZ0JBQWdCZSxTQUFoQixHQUE0QmYsV0FBNUIsR0FBMENnQixLQUFLQyxLQUFMLENBQVd4QixTQUFTLENBQXBCLENBQXJELENBaENPLENBZ0NxRTs7QUFFNUUsVUFBSVcsbUJBQUo7QUFDQSxVQUFJRCxhQUFKLEVBQW1CO0FBQ2pCQyxxQkFBYXpCLE1BQU13QyxhQUFOLENBQW9CcEMsUUFBUW9CLGFBQVIsQ0FBcEIsRUFBNEM7QUFDdkRpQixlQUFLZixhQURrRDtBQUV2RFEsNEJBRnVEO0FBR3ZEUSxpQkFBTyxTQUhnRDtBQUl2REMsZ0JBQU1WLFVBSmlEO0FBS3ZEVyxzQkFBWSxDQUFDUCxLQUFLQyxLQUFMLENBQVdDLEtBQUssR0FBaEI7QUFMMEMsU0FBNUMsQ0FBYjtBQU9EOztBQUVELFVBQUlYLGtCQUFKO0FBQ0EsVUFBSUQsWUFBSixFQUFrQjtBQUNoQkMsb0JBQVk1QixNQUFNd0MsYUFBTixDQUFvQnBDLFFBQVF1QixZQUFSLENBQXBCLEVBQTJDO0FBQ3JEYyxlQUFLWixZQURnRDtBQUVyREssNEJBRnFEO0FBR3JEUSxpQkFBTyxTQUg4QztBQUlyREMsZ0JBQU1WLFVBSitDO0FBS3JEWSx1QkFBYSxDQUFDUixLQUFLQyxLQUFMLENBQVdDLEtBQUssR0FBaEI7QUFMdUMsU0FBM0MsQ0FBWjtBQU9EOztBQUVELGFBQ0U7QUFBQyxZQUFEO0FBQUE7QUFDRSxjQUFHLFFBREw7QUFFRSxnQ0FBc0JQLFlBRnhCO0FBR0UsbUNBQXlCQSxZQUgzQjtBQUlFLCtCQUFxQkEsWUFKdkI7QUFLRSxrQ0FBd0JBLFlBTDFCO0FBTUUsc0JBQVlWLFVBTmQ7QUFPRSx5QkFBZUMsYUFQakI7QUFRRSx3QkFBY1ksRUFSaEI7QUFTRSx1QkFBYUksRUFUZjtBQVVFLGtCQUFRLENBVlYsQ0FVYTtBQVZiLFdBV01SLFNBWE47QUFZRSxpQkFBTyxJQVpULENBWWU7QUFaZixZQWFFLGtCQUNLRCxlQURMLEVBRUtqQixHQUZMLENBYkY7QUFpQkUsa0JBQVFDLE1BakJWO0FBa0JFLHNCQUFlQSxNQUFmO0FBbEJGLFdBbUJPQyxXQUFXLEVBQUUsZUFBZSxJQUFqQixFQUFYLEdBQXFDLEVBbkI1QyxFQW9CTUosT0FBT21DLE1BcEJiLEVBcUJNbEMsS0FyQk47QUFzQkUsb0JBQVVLLFlBQVlFO0FBdEJ4QjtBQXdCR0EscUJBQ0Msb0JBQUMsT0FBRDtBQUNFLHNCQUFZLENBQUNrQixLQUFLQyxLQUFMLENBQVd4QixTQUFTLENBQXBCLENBRGY7QUFFRSx1QkFBYXVCLEtBQUtDLEtBQUwsQ0FBV3hCLFNBQVMsQ0FBcEIsQ0FGZjtBQUdFLGdCQUFNdUIsS0FBS0MsS0FBTCxDQUFXeEIsU0FBUyxDQUFwQjtBQUhSLFVBekJKO0FBK0JHVyxzQkFBYyxJQS9CakI7QUFnQ0dULGdCQWhDSDtBQWlDR1kscUJBQWE7QUFqQ2hCLE9BREY7QUFxQ0Q7Ozs7RUFuS2lDM0IsYTs7QUFBZlUsTSxDQUNab0MsUyxnQkFJRjVDLEtBQUs0QyxTOztBQUVSOzs7QUFHQTdCLGNBQVloQixVQUFVOEMsS0FBVixDQUFnQkMsT0FBT0MsSUFBUCxDQUFZeEMsaUJBQVosQ0FBaEIsRUFBZ0R5QyxVOztBQUU1RDs7OztBQUlBaEMsYUFBV2pCLFVBQVVrRCxJOztBQUVyQjs7OztBQUlBckMsWUFBVWIsVUFBVWtELEk7O0FBRXBCOzs7QUFHQTNCLGNBQVl2QixVQUFVOEMsS0FBVixDQUFnQkMsT0FBT0MsSUFBUCxDQUFZOUMsT0FBWixDQUFoQixDOztBQUVaOzs7QUFHQXNCLGlCQUFleEIsVUFBVThDLEtBQVYsQ0FBZ0JDLE9BQU9DLElBQVAsQ0FBWTdDLE9BQVosQ0FBaEIsQzs7QUFFZjs7O0FBR0F1QixhQUFXMUIsVUFBVThDLEtBQVYsQ0FBZ0JDLE9BQU9DLElBQVAsQ0FBWTlDLE9BQVosQ0FBaEIsQzs7QUFFWDs7O0FBR0F5QixnQkFBYzNCLFVBQVU4QyxLQUFWLENBQWdCQyxPQUFPQyxJQUFQLENBQVk3QyxPQUFaLENBQWhCLEM7O0FBRWQ7Ozs7QUFJQVksWUFBVWYsVUFBVWtEOztBQWhESHpDLE0sQ0FtRFowQyxZLEdBQWU7QUFDcEJuQyxjQUFZLFNBRFE7QUFFcEJILFlBQVUsS0FGVTtBQUdwQlcsaUJBQWUsTUFISztBQUlwQkcsZ0JBQWMsTUFKTTtBQUtwQmYsVUFBUSxFQUxZO0FBTXBCUSxjQUFZLENBTlE7QUFPcEJDLGlCQUFlO0FBUEssQztBQW5ESFosTSxDQTZEWm1DLE0sR0FBUztBQUNkUSxZQUFVLFVBREk7QUFFZEMsY0FBWSxJQUZFO0FBR2RDLGNBQVksR0FIRTtBQUlkQyxXQUFTLGFBSks7QUFLZEMsY0FBWSxRQUxFO0FBTWRDLFlBQVU7QUFOSSxDO2VBN0RHaEQsTSIsImZpbGUiOiJCdXR0b24uanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgUHVyZUNvbXBvbmVudCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJ1xuaW1wb3J0IHsgVGV4dCB9IGZyb20gJy4uLy4uL3R5cG9ncmFwaHknXG5pbXBvcnQgeyBJY29uTWFwLCBJY29uQWltIH0gZnJvbSAnLi4vLi4vaWNvbnMnXG5pbXBvcnQge1xuICBnZXRCb3JkZXJSYWRpdXNGb3JDb250cm9sSGVpZ2h0LFxuICBnZXRUZXh0U3R5bGVGb3JDb250cm9sSGVpZ2h0LFxuICBnZXRJY29uU2l6ZUZvckNvbnRyb2xIZWlnaHRcbn0gZnJvbSAnLi4vLi4vc2hhcmVkLXN0eWxlcydcbmltcG9ydCB7IFNwaW5uZXIgfSBmcm9tICcuLi8uLi9zcGlubmVyJ1xuaW1wb3J0IEJ1dHRvbkFwcGVhcmFuY2VzIGZyb20gJy4vc3R5bGVzL0J1dHRvbkFwcGVhcmFuY2VzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdXR0b24gZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAvKipcbiAgICAgKiBDb21wb3NlcyB0aGUgVGV4dCBjb21wb25lbnQgYXMgdGhlIGJhc2UuXG4gICAgICovXG4gICAgLi4uVGV4dC5wcm9wVHlwZXMsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXBwZWFyYW5jZSBvZiB0aGUgYnV0dG9uLlxuICAgICAqL1xuICAgIGFwcGVhcmFuY2U6IFByb3BUeXBlcy5vbmVPZihPYmplY3Qua2V5cyhCdXR0b25BcHBlYXJhbmNlcykpLmlzUmVxdWlyZWQsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIHNob3cgYSBsb2FkaW5nIHNwaW5uZXIgYmVmb3JlIHRoZSBjaGlsZHJlbi5cbiAgICAgKiBUaGlzIGFsc28gZGlzYWJsZXMgdGhlIGJ1dHRvbi5cbiAgICAgKi9cbiAgICBpc0xvYWRpbmc6IFByb3BUeXBlcy5ib29sLFxuXG4gICAgLyoqXG4gICAgICogRm9yY2VmdWxseSBzZXQgdGhlIGFjdGl2ZSBzdGF0ZSBvZiBhIGJ1dHRvbi5cbiAgICAgKiBVc2VmdWwgaW4gY29uanVjdGlvbiB3aXRoIGEgUG9wb3Zlci5cbiAgICAgKi9cbiAgICBpc0FjdGl2ZTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGFuIGljb24gYmVmb3JlIHRoZSB0ZXh0LiBDYW4gYmUgYW55IGljb24gZnJvbSBFdmVyZ3JlZW4uXG4gICAgICovXG4gICAgaWNvbkJlZm9yZTogUHJvcFR5cGVzLm9uZU9mKE9iamVjdC5rZXlzKEljb25NYXApKSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBhaW0gb2YgdGhlIGxlZnQgaWNvbi4gTm90IGEgYmlnIHVzZSBjYXNlIGZvciB0aGlzLlxuICAgICAqL1xuICAgIGljb25CZWZvcmVBaW06IFByb3BUeXBlcy5vbmVPZihPYmplY3Qua2V5cyhJY29uQWltKSksXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGFuIGljb24gYWZ0ZXIgdGhlIHRleHQuIENhbiBiZSBhbnkgaWNvbiBmcm9tIEV2ZXJncmVlbi5cbiAgICAgKi9cbiAgICBpY29uQWZ0ZXI6IFByb3BUeXBlcy5vbmVPZihPYmplY3Qua2V5cyhJY29uTWFwKSksXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYWltIG9mIHRoZSByaWdodCBpY29uLiBVc2VmdWwgdG8gYWltIGEgdHJpYW5nbGUgZG93bi5cbiAgICAgKi9cbiAgICBpY29uQWZ0ZXJBaW06IFByb3BUeXBlcy5vbmVPZihPYmplY3Qua2V5cyhJY29uQWltKSksXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIHRoZSBidXR0b24gaXMgZGlzYWJsZWQuXG4gICAgICogaXNMb2FkaW5nIGFsc28gc2V0cyB0aGUgYnV0dG9uIHRvIGRpc2FibGVkLlxuICAgICAqL1xuICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbFxuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBhcHBlYXJhbmNlOiAnZGVmYXVsdCcsXG4gICAgaXNBY3RpdmU6IGZhbHNlLFxuICAgIGljb25CZWZvcmVBaW06ICdub25lJyxcbiAgICBpY29uQWZ0ZXJBaW06ICdub25lJyxcbiAgICBoZWlnaHQ6IDMyLFxuICAgIHBhZGRpbmdUb3A6IDAsXG4gICAgcGFkZGluZ0JvdHRvbTogMFxuICB9XG5cbiAgc3RhdGljIHN0eWxlcyA9IHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICBmb250RmFtaWx5OiAndWknLFxuICAgIGZvbnRXZWlnaHQ6IDUwMCxcbiAgICBkaXNwbGF5OiAnaW5saW5lLWZsZXgnLFxuICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgIGZsZXhXcmFwOiAnbm93cmFwJ1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNzcyxcbiAgICAgIGhlaWdodCxcbiAgICAgIGlzQWN0aXZlLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBkaXNhYmxlZCxcbiAgICAgIGFwcGVhcmFuY2UsXG4gICAgICBpc0xvYWRpbmcsXG5cbiAgICAgIC8vIFBhZGRpbmdzXG4gICAgICBwYWRkaW5nUmlnaHQsXG4gICAgICBwYWRkaW5nTGVmdCxcbiAgICAgIHBhZGRpbmdUb3AsXG4gICAgICBwYWRkaW5nQm90dG9tLFxuXG4gICAgICAvLyBJY29uc1xuICAgICAgaWNvbkJlZm9yZTogaWNvbkJlZm9yZUtleSxcbiAgICAgIGljb25CZWZvcmVBaW0sXG4gICAgICBpY29uQWZ0ZXI6IGljb25BZnRlcktleSxcbiAgICAgIGljb25BZnRlckFpbSxcblxuICAgICAgLi4ucHJvcHNcbiAgICB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IGFwcGVhcmFuY2VTdHlsZSA9IEJ1dHRvbkFwcGVhcmFuY2VzW2FwcGVhcmFuY2VdXG4gICAgY29uc3QgdGV4dFN0eWxlID0gZ2V0VGV4dFN0eWxlRm9yQ29udHJvbEhlaWdodCh7IGhlaWdodCB9KVxuICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IGdldEJvcmRlclJhZGl1c0ZvckNvbnRyb2xIZWlnaHQoeyBoZWlnaHQgfSlcbiAgICBjb25zdCBpY29uSGVpZ2h0ID0gaGVpZ2h0IC0gNFxuICAgIGNvbnN0IGljb25TaXplID0gZ2V0SWNvblNpemVGb3JDb250cm9sSGVpZ2h0KHsgaGVpZ2h0OiBpY29uSGVpZ2h0IH0pXG5cbiAgICBjb25zdCBwciA9XG4gICAgICBwYWRkaW5nUmlnaHQgIT09IHVuZGVmaW5lZCA/IHBhZGRpbmdSaWdodCA6IE1hdGgucm91bmQoaGVpZ2h0IC8gMikgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZWdhdGVkLWNvbmRpdGlvblxuICAgIGNvbnN0IHBsID0gcGFkZGluZ0xlZnQgIT09IHVuZGVmaW5lZCA/IHBhZGRpbmdMZWZ0IDogTWF0aC5yb3VuZChoZWlnaHQgLyAyKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5lZ2F0ZWQtY29uZGl0aW9uXG5cbiAgICBsZXQgaWNvbkJlZm9yZVxuICAgIGlmIChpY29uQmVmb3JlS2V5KSB7XG4gICAgICBpY29uQmVmb3JlID0gUmVhY3QuY3JlYXRlRWxlbWVudChJY29uTWFwW2ljb25CZWZvcmVLZXldLCB7XG4gICAgICAgIGFpbTogaWNvbkJlZm9yZUFpbSxcbiAgICAgICAgaWNvblNpemUsXG4gICAgICAgIGNvbG9yOiAnaW5oZXJpdCcsXG4gICAgICAgIHNpemU6IGljb25IZWlnaHQsXG4gICAgICAgIG1hcmdpbkxlZnQ6IC1NYXRoLnJvdW5kKHBsICogMC42KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBsZXQgaWNvbkFmdGVyXG4gICAgaWYgKGljb25BZnRlcktleSkge1xuICAgICAgaWNvbkFmdGVyID0gUmVhY3QuY3JlYXRlRWxlbWVudChJY29uTWFwW2ljb25BZnRlcktleV0sIHtcbiAgICAgICAgYWltOiBpY29uQWZ0ZXJBaW0sXG4gICAgICAgIGljb25TaXplLFxuICAgICAgICBjb2xvcjogJ2luaGVyaXQnLFxuICAgICAgICBzaXplOiBpY29uSGVpZ2h0LFxuICAgICAgICBtYXJnaW5SaWdodDogLU1hdGgucm91bmQocGwgKiAwLjYpXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8VGV4dFxuICAgICAgICBpcz1cImJ1dHRvblwiXG4gICAgICAgIGJvcmRlclRvcFJpZ2h0UmFkaXVzPXtib3JkZXJSYWRpdXN9XG4gICAgICAgIGJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzPXtib3JkZXJSYWRpdXN9XG4gICAgICAgIGJvcmRlclRvcExlZnRSYWRpdXM9e2JvcmRlclJhZGl1c31cbiAgICAgICAgYm9yZGVyQm90dG9tTGVmdFJhZGl1cz17Ym9yZGVyUmFkaXVzfVxuICAgICAgICBwYWRkaW5nVG9wPXtwYWRkaW5nVG9wfVxuICAgICAgICBwYWRkaW5nQm90dG9tPXtwYWRkaW5nQm90dG9tfVxuICAgICAgICBwYWRkaW5nUmlnaHQ9e3ByfVxuICAgICAgICBwYWRkaW5nTGVmdD17cGx9XG4gICAgICAgIG1hcmdpbj17MH0gLy8gUmVtb3ZlcyB3ZWlyZCBtYXJnaW5zIGluIFNhZmFyaVxuICAgICAgICB7Li4udGV4dFN0eWxlfVxuICAgICAgICBjb2xvcj17bnVsbH0gLy8gUHJldmVudCB0aGUgVGV4dCBjb2xvciBvdmVycmlkaW5nIHRoZSBnbGFtb3IgYXBwZWFyYW5jZVN0eWxlIGNvbG9yXG4gICAgICAgIGNzcz17e1xuICAgICAgICAgIC4uLmFwcGVhcmFuY2VTdHlsZSxcbiAgICAgICAgICAuLi5jc3NcbiAgICAgICAgfX1cbiAgICAgICAgaGVpZ2h0PXtoZWlnaHR9XG4gICAgICAgIGxpbmVIZWlnaHQ9e2Ake2hlaWdodH1weGB9XG4gICAgICAgIHsuLi4oaXNBY3RpdmUgPyB7ICdkYXRhLWFjdGl2ZSc6IHRydWUgfSA6IHt9KX1cbiAgICAgICAgey4uLkJ1dHRvbi5zdHlsZXN9XG4gICAgICAgIHsuLi5wcm9wc31cbiAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkIHx8IGlzTG9hZGluZ31cbiAgICAgID5cbiAgICAgICAge2lzTG9hZGluZyAmJiAoXG4gICAgICAgICAgPFNwaW5uZXJcbiAgICAgICAgICAgIG1hcmdpbkxlZnQ9ey1NYXRoLnJvdW5kKGhlaWdodCAvIDgpfVxuICAgICAgICAgICAgbWFyZ2luUmlnaHQ9e01hdGgucm91bmQoaGVpZ2h0IC8gNCl9XG4gICAgICAgICAgICBzaXplPXtNYXRoLnJvdW5kKGhlaWdodCAvIDIpfVxuICAgICAgICAgIC8+XG4gICAgICAgICl9XG4gICAgICAgIHtpY29uQmVmb3JlIHx8IG51bGx9XG4gICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAge2ljb25BZnRlciB8fCBudWxsfVxuICAgICAgPC9UZXh0PlxuICAgIClcbiAgfVxufVxuIl19