var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _css;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import Box, { css } from 'ui-box';
import { colors } from '../../colors';
import { Text } from '../../typography';
import { getTextSizeForControlHeight, getBorderRadiusForControlHeight } from '../../shared-styles';
import SegmentedControlAppearances from './styles/SegmentedControlAppearances';

var keysSegmentedControlAppearances = Object.keys(SegmentedControlAppearances);

var labelClass = css({
  display: 'flex',
  flex: 1,
  alignItems: 'center',
  justifyContent: 'center',
  position: 'relative'
});

var wrapperClass = css((_css = {
  position: 'relative',
  display: 'flex',
  flex: 1,
  cursor: 'pointer',
  marginLeft: '-1px'
}, _defineProperty(_css, ':first-child .' + labelClass, {
  borderTopLeftRadius: 3,
  borderBottomLeftRadius: 3
}), _defineProperty(_css, ':last-child .' + labelClass, {
  borderTopRightRadius: 3,
  borderBottomRightRadius: 3
}), _css));

var offscreenCss = css({
  overflow: 'hidden',
  position: 'absolute',
  height: '1px',
  width: '1px',
  padding: 0,
  margin: '-1px',
  border: 0,
  clip: 'rect(0 0 0 0)'
});

var SegmentedControlRadio = function (_PureComponent) {
  _inherits(SegmentedControlRadio, _PureComponent);

  function SegmentedControlRadio() {
    _classCallCheck(this, SegmentedControlRadio);

    return _possibleConstructorReturn(this, (SegmentedControlRadio.__proto__ || Object.getPrototypeOf(SegmentedControlRadio)).apply(this, arguments));
  }

  _createClass(SegmentedControlRadio, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          name = _props.name,
          label = _props.label,
          value = _props.value,
          height = _props.height,
          checked = _props.checked,
          _onChange = _props.onChange,
          appearance = _props.appearance,
          isFirstItem = _props.isFirstItem,
          isLastItem = _props.isLastItem;


      var textSize = getTextSizeForControlHeight({ height: height });
      var borderRadius = getBorderRadiusForControlHeight({ height: height });
      var styles = SegmentedControlAppearances[appearance];

      return React.createElement(
        Box,
        _extends({
          is: 'label',
          className: '' + wrapperClass,
          css: styles
        }, checked ? {
          'data-active': true
        } : {}, isFirstItem ? {
          borderTopLeftRadius: borderRadius,
          borderBottomLeftRadius: borderRadius
        } : {}, isLastItem ? {
          borderTopRightRadius: borderRadius,
          borderBottomRightRadius: borderRadius
        } : {}),
        React.createElement('input', {
          type: 'radio',
          className: '' + offscreenCss,
          name: name,
          value: value,
          checked: checked,
          onChange: function onChange(e) {
            return _onChange(e.target.value);
          }
        }),
        React.createElement(
          Text,
          _extends({
            fontWeight: 500,
            size: textSize,
            className: '' + labelClass
          }, checked ? { color: colors.blue['500'] } : {}),
          label
        )
      );
    }
  }]);

  return SegmentedControlRadio;
}(PureComponent);

SegmentedControlRadio.propTypes = {
  /**
   * The name attribute of the radio input.
   */
  name: PropTypes.string.isRequired,

  /**
   * The label used for the radio.
   */
  label: PropTypes.node.isRequired,

  /**
   * The value attribute of the radio input.
   */
  value: PropTypes.string.isRequired,

  /**
   * The height of the control.
   */
  height: PropTypes.number.isRequired,

  /**
   * When true, the radio input is checked.
   */
  checked: PropTypes.bool.isRequired,

  /**
   * Function called when the state changes.
   */
  onChange: PropTypes.func.isRequired,

  /**
   * The appearance of the control. Currently only `default` is possible.
   */
  appearance: PropTypes.oneOf(keysSegmentedControlAppearances).isRequired,

  /**
   * When true, this item is the first item.
   */
  isFirstItem: PropTypes.bool,

  /**
   * When true, this item is the last item.
   */
  isLastItem: PropTypes.bool
};
export default SegmentedControlRadio;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zZWdtZW50ZWQtY29udHJvbC9zcmMvU2VnbWVudGVkQ29udHJvbFJhZGlvLmpzIl0sIm5hbWVzIjpbIlJlYWN0IiwiUHVyZUNvbXBvbmVudCIsIlByb3BUeXBlcyIsIkJveCIsImNzcyIsImNvbG9ycyIsIlRleHQiLCJnZXRUZXh0U2l6ZUZvckNvbnRyb2xIZWlnaHQiLCJnZXRCb3JkZXJSYWRpdXNGb3JDb250cm9sSGVpZ2h0IiwiU2VnbWVudGVkQ29udHJvbEFwcGVhcmFuY2VzIiwia2V5c1NlZ21lbnRlZENvbnRyb2xBcHBlYXJhbmNlcyIsIk9iamVjdCIsImtleXMiLCJsYWJlbENsYXNzIiwiZGlzcGxheSIsImZsZXgiLCJhbGlnbkl0ZW1zIiwianVzdGlmeUNvbnRlbnQiLCJwb3NpdGlvbiIsIndyYXBwZXJDbGFzcyIsImN1cnNvciIsIm1hcmdpbkxlZnQiLCJib3JkZXJUb3BMZWZ0UmFkaXVzIiwiYm9yZGVyQm90dG9tTGVmdFJhZGl1cyIsImJvcmRlclRvcFJpZ2h0UmFkaXVzIiwiYm9yZGVyQm90dG9tUmlnaHRSYWRpdXMiLCJvZmZzY3JlZW5Dc3MiLCJvdmVyZmxvdyIsImhlaWdodCIsIndpZHRoIiwicGFkZGluZyIsIm1hcmdpbiIsImJvcmRlciIsImNsaXAiLCJTZWdtZW50ZWRDb250cm9sUmFkaW8iLCJwcm9wcyIsIm5hbWUiLCJsYWJlbCIsInZhbHVlIiwiY2hlY2tlZCIsIm9uQ2hhbmdlIiwiYXBwZWFyYW5jZSIsImlzRmlyc3RJdGVtIiwiaXNMYXN0SXRlbSIsInRleHRTaXplIiwiYm9yZGVyUmFkaXVzIiwic3R5bGVzIiwiZSIsInRhcmdldCIsImNvbG9yIiwiYmx1ZSIsInByb3BUeXBlcyIsInN0cmluZyIsImlzUmVxdWlyZWQiLCJub2RlIiwibnVtYmVyIiwiYm9vbCIsImZ1bmMiLCJvbmVPZiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQSxPQUFPQSxLQUFQLElBQWdCQyxhQUFoQixRQUFxQyxP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RDs7OztFQTFHZ0RwQyxhOztBQUE5QmlDLHFCLENBQ1ppQixTLEdBQVk7QUFDakI7OztBQUdBZixRQUFNbEMsVUFBVWtELE1BQVYsQ0FBaUJDLFVBSk47O0FBTWpCOzs7QUFHQWhCLFNBQU9uQyxVQUFVb0QsSUFBVixDQUFlRCxVQVRMOztBQVdqQjs7O0FBR0FmLFNBQU9wQyxVQUFVa0QsTUFBVixDQUFpQkMsVUFkUDs7QUFnQmpCOzs7QUFHQXpCLFVBQVExQixVQUFVcUQsTUFBVixDQUFpQkYsVUFuQlI7O0FBcUJqQjs7O0FBR0FkLFdBQVNyQyxVQUFVc0QsSUFBVixDQUFlSCxVQXhCUDs7QUEwQmpCOzs7QUFHQWIsWUFBVXRDLFVBQVV1RCxJQUFWLENBQWVKLFVBN0JSOztBQStCakI7OztBQUdBWixjQUFZdkMsVUFBVXdELEtBQVYsQ0FBZ0JoRCwrQkFBaEIsRUFBaUQyQyxVQWxDNUM7O0FBb0NqQjs7O0FBR0FYLGVBQWF4QyxVQUFVc0QsSUF2Q047O0FBeUNqQjs7O0FBR0FiLGNBQVl6QyxVQUFVc0Q7QUE1Q0wsQztlQURBdEIscUIiLCJmaWxlIjoiU2VnbWVudGVkQ29udHJvbFJhZGlvLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IFB1cmVDb21wb25lbnQgfSBmcm9tICdyZWFjdCdcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcydcbmltcG9ydCBCb3gsIHsgY3NzIH0gZnJvbSAndWktYm94J1xuaW1wb3J0IHsgY29sb3JzIH0gZnJvbSAnLi4vLi4vY29sb3JzJ1xuaW1wb3J0IHsgVGV4dCB9IGZyb20gJy4uLy4uL3R5cG9ncmFwaHknXG5pbXBvcnQge1xuICBnZXRUZXh0U2l6ZUZvckNvbnRyb2xIZWlnaHQsXG4gIGdldEJvcmRlclJhZGl1c0ZvckNvbnRyb2xIZWlnaHRcbn0gZnJvbSAnLi4vLi4vc2hhcmVkLXN0eWxlcydcbmltcG9ydCBTZWdtZW50ZWRDb250cm9sQXBwZWFyYW5jZXMgZnJvbSAnLi9zdHlsZXMvU2VnbWVudGVkQ29udHJvbEFwcGVhcmFuY2VzJ1xuXG5jb25zdCBrZXlzU2VnbWVudGVkQ29udHJvbEFwcGVhcmFuY2VzID0gT2JqZWN0LmtleXMoU2VnbWVudGVkQ29udHJvbEFwcGVhcmFuY2VzKVxuXG5jb25zdCBsYWJlbENsYXNzID0gY3NzKHtcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICBmbGV4OiAxLFxuICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxuICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xufSlcblxuY29uc3Qgd3JhcHBlckNsYXNzID0gY3NzKHtcbiAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gIGRpc3BsYXk6ICdmbGV4JyxcbiAgZmxleDogMSxcbiAgY3Vyc29yOiAncG9pbnRlcicsXG4gIG1hcmdpbkxlZnQ6ICctMXB4JyxcbiAgW2A6Zmlyc3QtY2hpbGQgLiR7bGFiZWxDbGFzc31gXToge1xuICAgIGJvcmRlclRvcExlZnRSYWRpdXM6IDMsXG4gICAgYm9yZGVyQm90dG9tTGVmdFJhZGl1czogM1xuICB9LFxuICBbYDpsYXN0LWNoaWxkIC4ke2xhYmVsQ2xhc3N9YF06IHtcbiAgICBib3JkZXJUb3BSaWdodFJhZGl1czogMyxcbiAgICBib3JkZXJCb3R0b21SaWdodFJhZGl1czogM1xuICB9XG59KVxuXG5jb25zdCBvZmZzY3JlZW5Dc3MgPSBjc3Moe1xuICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICBoZWlnaHQ6ICcxcHgnLFxuICB3aWR0aDogJzFweCcsXG4gIHBhZGRpbmc6IDAsXG4gIG1hcmdpbjogJy0xcHgnLFxuICBib3JkZXI6IDAsXG4gIGNsaXA6ICdyZWN0KDAgMCAwIDApJ1xufSlcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VnbWVudGVkQ29udHJvbFJhZGlvIGV4dGVuZHMgUHVyZUNvbXBvbmVudCB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgYXR0cmlidXRlIG9mIHRoZSByYWRpbyBpbnB1dC5cbiAgICAgKi9cbiAgICBuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFiZWwgdXNlZCBmb3IgdGhlIHJhZGlvLlxuICAgICAqL1xuICAgIGxhYmVsOiBQcm9wVHlwZXMubm9kZS5pc1JlcXVpcmVkLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGF0dHJpYnV0ZSBvZiB0aGUgcmFkaW8gaW5wdXQuXG4gICAgICovXG4gICAgdmFsdWU6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIGNvbnRyb2wuXG4gICAgICovXG4gICAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIHRoZSByYWRpbyBpbnB1dCBpcyBjaGVja2VkLlxuICAgICAqL1xuICAgIGNoZWNrZWQ6IFByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWQsXG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgc3RhdGUgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcHBlYXJhbmNlIG9mIHRoZSBjb250cm9sLiBDdXJyZW50bHkgb25seSBgZGVmYXVsdGAgaXMgcG9zc2libGUuXG4gICAgICovXG4gICAgYXBwZWFyYW5jZTogUHJvcFR5cGVzLm9uZU9mKGtleXNTZWdtZW50ZWRDb250cm9sQXBwZWFyYW5jZXMpLmlzUmVxdWlyZWQsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIHRoaXMgaXRlbSBpcyB0aGUgZmlyc3QgaXRlbS5cbiAgICAgKi9cbiAgICBpc0ZpcnN0SXRlbTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIHRoaXMgaXRlbSBpcyB0aGUgbGFzdCBpdGVtLlxuICAgICAqL1xuICAgIGlzTGFzdEl0ZW06IFByb3BUeXBlcy5ib29sXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIGxhYmVsLFxuICAgICAgdmFsdWUsXG4gICAgICBoZWlnaHQsXG4gICAgICBjaGVja2VkLFxuICAgICAgb25DaGFuZ2UsXG4gICAgICBhcHBlYXJhbmNlLFxuICAgICAgaXNGaXJzdEl0ZW0sXG4gICAgICBpc0xhc3RJdGVtXG4gICAgfSA9IHRoaXMucHJvcHNcblxuICAgIGNvbnN0IHRleHRTaXplID0gZ2V0VGV4dFNpemVGb3JDb250cm9sSGVpZ2h0KHsgaGVpZ2h0IH0pXG4gICAgY29uc3QgYm9yZGVyUmFkaXVzID0gZ2V0Qm9yZGVyUmFkaXVzRm9yQ29udHJvbEhlaWdodCh7IGhlaWdodCB9KVxuICAgIGNvbnN0IHN0eWxlcyA9IFNlZ21lbnRlZENvbnRyb2xBcHBlYXJhbmNlc1thcHBlYXJhbmNlXVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxCb3hcbiAgICAgICAgaXM9XCJsYWJlbFwiXG4gICAgICAgIGNsYXNzTmFtZT17YCR7d3JhcHBlckNsYXNzfWB9XG4gICAgICAgIGNzcz17c3R5bGVzfVxuICAgICAgICB7Li4uKGNoZWNrZWRcbiAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgJ2RhdGEtYWN0aXZlJzogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIDoge30pfVxuICAgICAgICB7Li4uKGlzRmlyc3RJdGVtXG4gICAgICAgICAgPyB7XG4gICAgICAgICAgICAgIGJvcmRlclRvcExlZnRSYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgICAgICAgICAgYm9yZGVyQm90dG9tTGVmdFJhZGl1czogYm9yZGVyUmFkaXVzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiB7fSl9XG4gICAgICAgIHsuLi4oaXNMYXN0SXRlbVxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICBib3JkZXJUb3BSaWdodFJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICAgICAgICBib3JkZXJCb3R0b21SaWdodFJhZGl1czogYm9yZGVyUmFkaXVzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiB7fSl9XG4gICAgICA+XG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgIHR5cGU9XCJyYWRpb1wiXG4gICAgICAgICAgY2xhc3NOYW1lPXtgJHtvZmZzY3JlZW5Dc3N9YH1cbiAgICAgICAgICBuYW1lPXtuYW1lfVxuICAgICAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgICAgICBjaGVja2VkPXtjaGVja2VkfVxuICAgICAgICAgIG9uQ2hhbmdlPXtlID0+IG9uQ2hhbmdlKGUudGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgLz5cbiAgICAgICAgPFRleHRcbiAgICAgICAgICBmb250V2VpZ2h0PXs1MDB9XG4gICAgICAgICAgc2l6ZT17dGV4dFNpemV9XG4gICAgICAgICAgY2xhc3NOYW1lPXtgJHtsYWJlbENsYXNzfWB9XG4gICAgICAgICAgey4uLihjaGVja2VkID8geyBjb2xvcjogY29sb3JzLmJsdWVbJzUwMCddIH0gOiB7fSl9XG4gICAgICAgID5cbiAgICAgICAgICB7bGFiZWx9XG4gICAgICAgIDwvVGV4dD5cbiAgICAgIDwvQm94PlxuICAgIClcbiAgfVxufVxuIl19